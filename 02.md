# II. Klasy i struktury danych
## 10. Enumy — więcej niż kolorowe stałe

*Cześć! Dziś porozmawiamy o enumach - jednej z tych funkcjonalności Javy, która na pierwszy rzut oka wydaje się prosta, ale kryje w sobie prawdziwą moc. Jeśli myślisz, że enumy to tylko sposób na definiowanie stałych jak kolory czy dni tygodnia, to czeka Cię miła niespodzianka. Enumy w Javie to pełnoprawne klasy z supermocarmi!*

---

#### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Enum (enumeracja) to specjalny typ danych, który pozwala definiować zestaw nazwanych stałych. To jak lista opcji do wyboru - dni tygodnia, kolory, statusy zamówienia. Ale w przeciwieństwie do zwykłych stałych, enumy są type-safe i mają wiele przydatnych funkcjonalności.

```java
// Prosty enum
public enum DzienTygodnia {
    PONIEDZIALEK, WTOREK, SRODA, CZWARTEK, PIATEK, SOBOTA, NIEDZIELA
}

// Użycie
DzienTygodnia dzis = DzienTygodnia.PONIEDZIALEK;
System.out.println("Dziś jest: " + dzis);  // "Dziś jest: PONIEDZIALEK"
```

#### Dlaczego to ważne?

Enumy zapewniają type safety - kompilator nie pozwoli Ci przypisać nieprawidłowej wartości. To znacznie bezpieczniejsze niż używanie int czy String do reprezentowania ograniczonego zestawu wartości.

```java
// Bez enum - niebezpieczne!
public static final int PONIEDZIALEK = 1;
public static final int WTOREK = 2;
// ...
int dzien = 999;  // Kompilator nie protestuje, ale to błąd!

// Z enum - bezpieczne!
DzienTygodnia dzien = DzienTygodnia.PONIEDZIALEK;  // Tylko prawidłowe wartości
```

#### Jak to działa w praktyce?

**Podstawowe operacje na enum:**

```java
public class PodstawoweEnum {
    public enum Status {
        NOWY, W_TRAKCIE, ZAKONCZONY, ANULOWANY
    }
    
    public static void main(String[] args) {
        Status status = Status.W_TRAKCIE;
        
        // Porównywanie (można używać == lub equals)
        if (status == Status.W_TRAKCIE) {
            System.out.println("Zadanie jest w trakcie realizacji");
        }
        
        // Switch z enum
        switch (status) {
            case NOWY -> System.out.println("Nowe zadanie");
            case W_TRAKCIE -> System.out.println("Zadanie w realizacji");
            case ZAKONCZONY -> System.out.println("Zadanie ukończone");
            case ANULOWANY -> System.out.println("Zadanie anulowane");
        }
        
        // Wszystkie wartości enum
        System.out.println("Dostępne statusy:");
        for (Status s : Status.values()) {
            System.out.println("- " + s);
        }
        
        // Konwersja String -> enum
        Status statusZTekstu = Status.valueOf("NOWY");
        System.out.println("Status z tekstu: " + statusZTekstu);
        
        // Pozycja w enum (ordinal)
        System.out.println("Pozycja W_TRAKCIE: " + Status.W_TRAKCIE.ordinal());  // 1
        
        // Nazwa jako String
        System.out.println("Nazwa: " + status.name());  // "W_TRAKCIE"
    }
}
```

**Enum z dodatkowymi danymi:**

```java
public enum Planeta {
    MERKURY(3.303e+23, 2.4397e6),
    WENUS(4.869e+24, 6.0518e6),
    ZIEMIA(5.976e+24, 6.37814e6),
    MARS(6.421e+23, 3.3972e6);
    
    private final double masa;        // w kilogramach
    private final double promien;     // w metrach
    
    // Konstruktor enum (zawsze private)
    Planeta(double masa, double promien) {
        this.masa = masa;
        this.promien = promien;
    }
    
    // Metody
    public double getMasa() { return masa; }
    public double getPromien() { return promien; }
    
    public double grawitacja() {
        final double G = 6.67300E-11;
        return G * masa / (promien * promien);
    }
    
    public double wagaNaPlanecie(double masaObiektu) {
        return masaObiektu * grawitacja();
    }
}

// Użycie
public class TestPlanet {
    public static void main(String[] args) {
        double masaCzlowieka = 70; // kg
        
        for (Planeta p : Planeta.values()) {
            System.out.printf("Twoja waga na %s: %.2f kg%n", 
                            p, p.wagaNaPlanecie(masaCzlowieka));
        }
    }
}
```

**Enum z metodami:**

```java
public enum Operacja {
    DODAWANIE {
        @Override
        public double wykonaj(double x, double y) {
            return x + y;
        }
    },
    ODEJMOWANIE {
        @Override
        public double wykonaj(double x, double y) {
            return x - y;
        }
    },
    MNOZENIE {
        @Override
        public double wykonaj(double x, double y) {
            return x * y;
        }
    },
    DZIELENIE {
        @Override
        public double wykonaj(double x, double y) {
            if (y == 0) throw new ArithmeticException("Dzielenie przez zero!");
            return x / y;
        }
    };
    
    // Abstrakcyjna metoda - każda wartość enum musi ją zaimplementować
    public abstract double wykonaj(double x, double y);
}

// Użycie
public class Kalkulator {
    public static void main(String[] args) {
        double a = 10, b = 3;
        
        for (Operacja op : Operacja.values()) {
            System.out.printf("%.1f %s %.1f = %.2f%n", 
                            a, op, b, op.wykonaj(a, b));
        }
    }
}
```

#### Praktyczne przykłady

```java
// Enum dla poziomów logowania
public enum PoziomLogu {
    DEBUG(1, "DEBUG"),
    INFO(2, "INFO"),
    WARNING(3, "WARN"),
    ERROR(4, "ERROR"),
    FATAL(5, "FATAL");
    
    private final int poziom;
    private final String nazwa;
    
    PoziomLogu(int poziom, String nazwa) {
        this.poziom = poziom;
        this.nazwa = nazwa;
    }
    
    public boolean czyWazniejszyNiz(PoziomLogu inny) {
        return this.poziom > inny.poziom;
    }
    
    public String getNazwa() { return nazwa; }
}

// Enum dla statusów HTTP
public enum StatusHTTP {
    OK(200, "OK"),
    NOT_FOUND(404, "Not Found"),
    INTERNAL_ERROR(500, "Internal Server Error"),
    BAD_REQUEST(400, "Bad Request");
    
    private final int kod;
    private final String opis;
    
    StatusHTTP(int kod, String opis) {
        this.kod = kod;
        this.opis = opis;
    }
    
    public int getKod() { return kod; }
    public String getOpis() { return opis; }
    
    public boolean czyBladKlienta() {
        return kod >= 400 && kod < 500;
    }
    
    public boolean czyBladSerwera() {
        return kod >= 500;
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Używanie ordinal() do logiki biznesowej**

```java
// ŹLE - ordinal może się zmienić!
public enum Priorytet {
    NISKI, SREDNI, WYSOKI
}

if (priorytet.ordinal() > 1) {  // Kruche! Co jeśli dodamy nowy priorytet?
    // logika
}

// DOBRZE - jawne wartości
public enum Priorytet {
    NISKI(1), SREDNI(2), WYSOKI(3);
    
    private final int wartosc;
    Priorytet(int wartosc) { this.wartosc = wartosc; }
    public int getWartosc() { return wartosc; }
}
```

**Pułapka 2: valueOf() z nieprawidłowym String**

```java
try {
    Status status = Status.valueOf("NIEPRAWIDLOWY");  // IllegalArgumentException!
} catch (IllegalArgumentException e) {
    System.out.println("Nieprawidłowy status: " + e.getMessage());
}

// Bezpieczniejsza wersja
public static Status bezpiecznyValueOf(String nazwa) {
    try {
        return Status.valueOf(nazwa.toUpperCase());
    } catch (IllegalArgumentException e) {
        return Status.NOWY;  // domyślna wartość
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Używaj enum** zamiast stałych int/String dla ograniczonych zestawów wartości
- **Dodawaj dane i metody** do enum gdy potrzebujesz więcej funkcjonalności
- **Unikaj ordinal()** w logice biznesowej
- **Enum są thread-safe** - idealne do singletonów
- **Switch z enum** jest bardzo wydajny

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz enum `Miesiac` z liczbą dni w każdym miesiącu i metodą sprawdzającą, czy rok jest przestępny.

**Zadanie 2:** Zaprojektuj enum `RozmiarKawy` (MALA, SREDNIA, DUZA) z pojemnością w ml i ceną.

**Zadanie 3:** Napisz enum `KierunekKompasu` z metodami do obracania w lewo/prawo.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest główna zaleta enum nad stałymi int?
2. Czy można dodawać pola i metody do enum?
3. Dlaczego nie należy używać ordinal() w logice biznesowej?

---

#### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Enumy w Javie to znacznie więcej niż syntactic sugar dla stałych. To pełnoprawne klasy z zaawansowanymi możliwościami, które mogą implementować interfejsy, mieć abstrakcyjne metody i służyć jako efektywne implementacje wzorców projektowych.

##### Wewnętrzna implementacja enum

```java
// Jak kompilator widzi enum
public enum Color { RED, GREEN, BLUE; }

// Jest kompilowane do czegoś podobnego:
public final class Color extends Enum<Color> {
    public static final Color RED = new Color("RED", 0);
    public static final Color GREEN = new Color("GREEN", 1);
    public static final Color BLUE = new Color("BLUE", 2);
    
    private static final Color[] $VALUES = {RED, GREEN, BLUE};
    
    private Color(String name, int ordinal) {
        super(name, ordinal);
    }
    
    public static Color[] values() {
        return $VALUES.clone();
    }
    
    public static Color valueOf(String name) {
        return Enum.valueOf(Color.class, name);
    }
}
```

##### Zaawansowane wzorce z enum

```java
// Strategy Pattern z enum
public enum SortingStrategy {
    BUBBLE_SORT {
        @Override
        public <T extends Comparable<T>> void sort(T[] array) {
            // Implementacja bubble sort
            for (int i = 0; i < array.length - 1; i++) {
                for (int j = 0; j < array.length - i - 1; j++) {
                    if (array[j].compareTo(array[j + 1]) > 0) {
                        T temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            }
        }
    },
    
    QUICK_SORT {
        @Override
        public <T extends Comparable<T>> void sort(T[] array) {
            quickSort(array, 0, array.length - 1);
        }
        
        private <T extends Comparable<T>> void quickSort(T[] array, int low, int high) {
            if (low < high) {
                int pi = partition(array, low, high);
                quickSort(array, low, pi - 1);
                quickSort(array, pi + 1, high);
            }
        }
        
        private <T extends Comparable<T>> int partition(T[] array, int low, int high) {
            T pivot = array[high];
            int i = low - 1;
            
            for (int j = low; j < high; j++) {
                if (array[j].compareTo(pivot) <= 0) {
                    i++;
                    T temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
            
            T temp = array[i + 1];
            array[i + 1] = array[high];
            array[high] = temp;
            
            return i + 1;
        }
    };
    
    public abstract <T extends Comparable<T>> void sort(T[] array);
}

// State Machine z enum
public enum OrderState {
    PENDING {
        @Override
        public OrderState nextState(OrderEvent event) {
            return switch (event) {
                case CONFIRM -> CONFIRMED;
                case CANCEL -> CANCELLED;
                default -> this;
            };
        }
        
        @Override
        public boolean canTransitionTo(OrderState newState) {
            return newState == CONFIRMED || newState == CANCELLED;
        }
    },
    
    CONFIRMED {
        @Override
        public OrderState nextState(OrderEvent event) {
            return switch (event) {
                case SHIP -> SHIPPED;
                case CANCEL -> CANCELLED;
                default -> this;
            };
        }
        
        @Override
        public boolean canTransitionTo(OrderState newState) {
            return newState == SHIPPED || newState == CANCELLED;
        }
    },
    
    SHIPPED {
        @Override
        public OrderState nextState(OrderEvent event) {
            return switch (event) {
                case DELIVER -> DELIVERED;
                case RETURN -> RETURNED;
                default -> this;
            };
        }
        
        @Override
        public boolean canTransitionTo(OrderState newState) {
            return newState == DELIVERED || newState == RETURNED;
        }
    },
    
    DELIVERED {
        @Override
        public OrderState nextState(OrderEvent event) {
            return switch (event) {
                case RETURN -> RETURNED;
                default -> this;
            };
        }
        
        @Override
        public boolean canTransitionTo(OrderState newState) {
            return newState == RETURNED;
        }
    },
    
    CANCELLED, RETURNED {
        @Override
        public OrderState nextState(OrderEvent event) {
            return this; // Terminal states
        }
        
        @Override
        public boolean canTransitionTo(OrderState newState) {
            return false; // No transitions from terminal states
        }
    };
    
    public abstract OrderState nextState(OrderEvent event);
    public abstract boolean canTransitionTo(OrderState newState);
    
    public enum OrderEvent {
        CONFIRM, CANCEL, SHIP, DELIVER, RETURN
    }
}
```

##### Enum implementing interfaces

```java
// Enum implementujący interfejsy
public interface Calculable {
    double calculate(double x, double y);
    String getSymbol();
}

public enum MathOperation implements Calculable {
    ADDITION("+") {
        @Override
        public double calculate(double x, double y) {
            return x + y;
        }
    },
    
    SUBTRACTION("-") {
        @Override
        public double calculate(double x, double y) {
            return x - y;
        }
    },
    
    MULTIPLICATION("*") {
        @Override
        public double calculate(double x, double y) {
            return x * y;
        }
    },
    
    DIVISION("/") {
        @Override
        public double calculate(double x, double y) {
            if (y == 0) throw new ArithmeticException("Division by zero");
            return x / y;
        }
    },
    
    POWER("^") {
        @Override
        public double calculate(double x, double y) {
            return Math.pow(x, y);
        }
    };
    
    private final String symbol;
    
    MathOperation(String symbol) {
        this.symbol = symbol;
    }
    
    @Override
    public String getSymbol() {
        return symbol;
    }
    
    // Factory method
    public static MathOperation fromSymbol(String symbol) {
        for (MathOperation op : values()) {
            if (op.getSymbol().equals(symbol)) {
                return op;
            }
        }
        throw new IllegalArgumentException("Unknown operation: " + symbol);
    }
}
```

##### Enum-based Singleton pattern

```java
// Najlepszy sposób implementacji Singleton w Javie
public enum DatabaseConnection {
    INSTANCE;
    
    private Connection connection;
    
    DatabaseConnection() {
        // Inicjalizacja połączenia
        try {
            this.connection = DriverManager.getConnection(
                "jdbc:h2:mem:testdb", "sa", ""
            );
        } catch (SQLException e) {
            throw new RuntimeException("Failed to initialize database connection", e);
        }
    }
    
    public Connection getConnection() {
        return connection;
    }
    
    public void executeQuery(String sql) {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute(sql);
        } catch (SQLException e) {
            throw new RuntimeException("Query execution failed", e);
        }
    }
    
    // Thread-safe, lazy initialization, serialization-safe
    // Odporny na reflection attacks
}

// Użycie
DatabaseConnection.INSTANCE.executeQuery("CREATE TABLE users (id INT, name VARCHAR(50))");
```

#### Performance considerations

```java
public class EnumPerformance {
    // EnumSet - najbardziej efektywna implementacja Set dla enum
    public void demonstrateEnumSet() {
        EnumSet<DayOfWeek> weekdays = EnumSet.range(DayOfWeek.MONDAY, DayOfWeek.FRIDAY);
        EnumSet<DayOfWeek> weekend = EnumSet.of(DayOfWeek.SATURDAY, DayOfWeek.SUNDAY);
        EnumSet<DayOfWeek> allDays = EnumSet.allOf(DayOfWeek.class);
        
        // EnumSet używa bitowych operacji - bardzo szybkie
        weekdays.add(DayOfWeek.SATURDAY);  // O(1)
        boolean isWeekend = weekend.contains(DayOfWeek.SUNDAY);  // O(1)
    }
    
    // EnumMap - najbardziej efektywna implementacja Map dla enum keys
    public void demonstrateEnumMap() {
        EnumMap<DayOfWeek, String> activities = new EnumMap<>(DayOfWeek.class);
        activities.put(DayOfWeek.MONDAY, "Work");
        activities.put(DayOfWeek.SATURDAY, "Rest");
        
        // EnumMap używa array internally - bardzo szybkie
        String mondayActivity = activities.get(DayOfWeek.MONDAY);  // O(1)
    }
    
    // Switch z enum - kompilator optymalizuje do jump table
    public String getActivityOptimized(DayOfWeek day) {
        return switch (day) {
            case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> "Work";
            case SATURDAY, SUNDAY -> "Rest";
        };
    }
}
```

#### Advanced enum patterns

```java
// Hierarchical enum pattern
public class HierarchicalEnums {
    public interface PaymentMethod {
        void process(double amount);
        String getDisplayName();
    }
    
    public enum CreditCardType implements PaymentMethod {
        VISA("Visa") {
            @Override
            public void process(double amount) {
                System.out.println("Processing $" + amount + " via Visa");
                // Visa-specific processing
            }
        },
        
        MASTERCARD("MasterCard") {
            @Override
            public void process(double amount) {
                System.out.println("Processing $" + amount + " via MasterCard");
                // MasterCard-specific processing
            }
        },
        
        AMEX("American Express") {
            @Override
            public void process(double amount) {
                if (amount > 10000) {
                    throw new IllegalArgumentException("Amount exceeds Amex limit");
                }
                System.out.println("Processing $" + amount + " via Amex");
            }
        };
        
        private final String displayName;
        
        CreditCardType(String displayName) {
            this.displayName = displayName;
        }
        
        @Override
        public String getDisplayName() {
            return displayName;
        }
    }
    
    public enum DigitalPayment implements PaymentMethod {
        PAYPAL("PayPal") {
            @Override
            public void process(double amount) {
                System.out.println("Processing $" + amount + " via PayPal");
            }
        },
        
        APPLE_PAY("Apple Pay") {
            @Override
            public void process(double amount) {
                System.out.println("Processing $" + amount + " via Apple Pay");
            }
        };
        
        private final String displayName;
        
        DigitalPayment(String displayName) {
            this.displayName = displayName;
        }
        
        @Override
        public String getDisplayName() {
            return displayName;
        }
    }
}

// Extensible enum pattern (workaround for enum limitations)
public abstract class ExtensibleOperation {
    private final String symbol;
    
    protected ExtensibleOperation(String symbol) {
        this.symbol = symbol;
    }
    
    public abstract double apply(double x, double y);
    
    public String getSymbol() {
        return symbol;
    }
    
    @Override
    public String toString() {
        return symbol;
    }
    
    // Basic operations
    public static final ExtensibleOperation PLUS = new ExtensibleOperation("+") {
        @Override
        public double apply(double x, double y) {
            return x + y;
        }
    };
    
    public static final ExtensibleOperation MINUS = new ExtensibleOperation("-") {
        @Override
        public double apply(double x, double y) {
            return x - y;
        }
    };
    
    // Extended operations (can be in different class/package)
    public static final ExtensibleOperation EXP = new ExtensibleOperation("^") {
        @Override
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    };
    
    public static final ExtensibleOperation REMAINDER = new ExtensibleOperation("%") {
        @Override
        public double apply(double x, double y) {
            return x % y;
        }
    };
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj thread-safe state machine używając enum, który obsługuje concurrent transitions i callbacks.

**Zadanie Zaawansowane 2:** Stwórz system permission management używając enum z bitowymi operacjami dla efektywnego sprawdzania uprawnień.

**Zadanie Zaawansowane 3:** Zaprojektuj extensible command pattern używając enum jako base, z możliwością dodawania nowych komend w runtime.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Dlaczego enum-based singleton jest uważany za najlepszą implementację wzorca Singleton?
2. Jak EnumSet i EnumMap osiągają tak wysoką wydajność?
3. Jakie są ograniczenia enum w Javie i jak można je obejść?

---

#### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public enum Miesiac {
    STYCZEN(31), LUTY(28), MARZEC(31), KWIECIEN(30),
    MAJ(31), CZERWIEC(30), LIPIEC(31), SIERPIEN(31),
    WRZESIEN(30), PAZDZIERNIK(31), LISTOPAD(30), GRUDZIEN(31);
    
    private final int dni;
    
    Miesiac(int dni) {
        this.dni = dni;
    }
    
    public int getDni(boolean rokPrzestepny) {
        if (this == LUTY && rokPrzestepny) {
            return 29;
        }
        return dni;
    }
    
    public static boolean czyRokPrzestepny(int rok) {
        return (rok % 4 == 0 && rok % 100 != 0) || (rok % 400 == 0);
    }
}
```

**Zadanie 2:**
```java
public enum RozmiarKawy {
    MALA(200, 8.50),
    SREDNIA(300, 12.00),
    DUZA(400, 15.50);
    
    private final int pojemnoscMl;
    private final double cena;
    
    RozmiarKawy(int pojemnoscMl, double cena) {
        this.pojemnoscMl = pojemnoscMl;
        this.cena = cena;
    }
    
    public int getPojemnoscMl() { return pojemnoscMl; }
    public double getCena() { return cena; }
    
    public double getCenaZaLitr() {
        return (cena / pojemnoscMl) * 1000;
    }
}
```

**Zadanie 3:**
```java
public enum KierunekKompasu {
    POLNOC(0), WSCHOD(90), POLUDNIE(180), ZACHOD(270);
    
    private final int stopnie;
    
    KierunekKompasu(int stopnie) {
        this.stopnie = stopnie;
    }
    
    public KierunekKompasu obrocWLewo() {
        return switch (this) {
            case POLNOC -> ZACHOD;
            case WSCHOD -> POLNOC;
            case POLUDNIE -> WSCHOD;
            case ZACHOD -> POLUDNIE;
        };
    }
    
    public KierunekKompasu obrocWPrawo() {
        return switch (this) {
            case POLNOC -> WSCHOD;
            case WSCHOD -> POLUDNIE;
            case POLUDNIE -> ZACHOD;
            case ZACHOD -> POLNOC;
        };
    }
    
    public int getStopnie() { return stopnie; }
}
```

**Pytania kontrolne:**
1. Type safety - kompilator zapewnia, że można używać tylko prawidłowych wartości, plus dodatkowe metody i funkcjonalności.
2. Tak, enum może mieć pola, konstruktory, metody i nawet implementować interfejsy.
3. Ordinal może się zmienić przy dodawaniu/usuwaniu wartości enum, co może złamać logikę biznesową.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public enum ThreadSafeStateMachine {
    IDLE {
        @Override
        public ThreadSafeStateMachine transition(Event event, StateCallback callback) {
            return switch (event) {
                case START -> {
                    callback.onTransition(this, RUNNING, event);
                    yield RUNNING;
                }
                case SHUTDOWN -> {
                    callback.onTransition(this, TERMINATED, event);
                    yield TERMINATED;
                }
                default -> this;
            };
        }
    },
    
    RUNNING {
        @Override
        public ThreadSafeStateMachine transition(Event event, StateCallback callback) {
            return switch (event) {
                case PAUSE -> {
                    callback.onTransition(this, PAUSED, event);
                    yield PAUSED;
                }
                case STOP -> {
                    callback.onTransition(this, IDLE, event);
                    yield IDLE;
                }
                case SHUTDOWN -> {
                    callback.onTransition(this, TERMINATED, event);
                    yield TERMINATED;
                }
                default -> this;
            };
        }
    },
    
    PAUSED {
        @Override
        public ThreadSafeStateMachine transition(Event event, StateCallback callback) {
            return switch (event) {
                case RESUME -> {
                    callback.onTransition(this, RUNNING, event);
                    yield RUNNING;
                }
                case STOP -> {
                    callback.onTransition(this, IDLE, event);
                    yield IDLE;
                }
                default -> this;
            };
        }
    },
    
    TERMINATED {
        @Override
        public ThreadSafeStateMachine transition(Event event, StateCallback callback) {
            return this; // Terminal state
        }
    };
    
    public abstract ThreadSafeStateMachine transition(Event event, StateCallback callback);
    
    public enum Event {
        START, PAUSE, RESUME, STOP, SHUTDOWN
    }
    
    @FunctionalInterface
    public interface StateCallback {
        void onTransition(ThreadSafeStateMachine from, ThreadSafeStateMachine to, Event event);
    }
    
    // Thread-safe state machine controller
    public static class StateMachineController {
        private volatile ThreadSafeStateMachine currentState = IDLE;
        private final Object lock = new Object();
        private final StateCallback callback;
        
        public StateMachineController(StateCallback callback) {
            this.callback = callback;
        }
        
        public ThreadSafeStateMachine processEvent(Event event) {
            synchronized (lock) {
                ThreadSafeStateMachine newState = currentState.transition(event, callback);
                currentState = newState;
                return newState;
            }
        }
        
        public ThreadSafeStateMachine getCurrentState() {
            return currentState;
        }
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public enum Permission {
    READ(1),
    WRITE(2),
    EXECUTE(4),
    DELETE(8),
    ADMIN(16),
    SUPER_ADMIN(32);
    
    private final int bitValue;
    
    Permission(int bitValue) {
        this.bitValue = bitValue;
    }
    
    public int getBitValue() {
        return bitValue;
    }
    
    public static class PermissionSet {
        private int permissions = 0;
        
        public PermissionSet grant(Permission... perms) {
            for (Permission perm : perms) {
                permissions |= perm.getBitValue();
            }
            return this;
        }
        
        public PermissionSet revoke(Permission... perms) {
            for (Permission perm : perms) {
                permissions &= ~perm.getBitValue();
            }
            return this;
        }
        
        public boolean has(Permission perm) {
            return (permissions & perm.getBitValue()) != 0;
        }
        
        public boolean hasAll(Permission... perms) {
            int required = 0;
            for (Permission perm : perms) {
                required |= perm.getBitValue();
            }
            return (permissions & required) == required;
        }
        
        public boolean hasAny(Permission... perms) {
            for (Permission perm : perms) {
                if (has(perm)) return true;
            }
            return false;
        }
        
        public EnumSet<Permission> getPermissions() {
            EnumSet<Permission> result = EnumSet.noneOf(Permission.class);
            for (Permission perm : Permission.values()) {
                if (has(perm)) {
                    result.add(perm);
                }
            }
            return result;
        }
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public abstract class ExtensibleCommand {
    private static final Map<String, ExtensibleCommand> commands = new ConcurrentHashMap<>();
    
    private final String name;
    
    protected ExtensibleCommand(String name) {
        this.name = name;
        commands.put(name, this);
    }
    
    public abstract void execute(String... args);
    
    public String getName() {
        return name;
    }
    
    public static ExtensibleCommand getCommand(String name) {
        return commands.get(name);
    }
    
    public static void registerCommand(ExtensibleCommand command) {
        commands.put(command.getName(), command);
    }
    
    public static Set<String> getAvailableCommands() {
        return commands.keySet();
    }
    
    // Built-in commands
    public static final ExtensibleCommand HELP = new ExtensibleCommand("help") {
        @Override
        public void execute(String... args) {
            System.out.println("Available commands:");
            commands.keySet().forEach(cmd -> System.out.println("  " + cmd));
        }
    };
    
    public static final ExtensibleCommand EXIT = new ExtensibleCommand("exit") {
        @Override
        public void execute(String... args) {
            System.out.println("Goodbye!");
            System.exit(0);
        }
    };
    
    // Runtime command registration
    public static void addCustomCommand(String name, Consumer<String[]> action) {
        new ExtensibleCommand(name) {
            @Override
            public void execute(String... args) {
                action.accept(args);
            }
        };
    }
}
```

**Pytania kontrolne:**
1. Enum singleton jest thread-safe z natury, odporny na reflection attacks, automatycznie obsługuje serializację i ma lazy initialization.
2. EnumSet używa bitowych operacji na long/long[], EnumMap używa array z enum ordinal jako index - oba O(1) operations.
3. Ograniczenia: nie można dziedziczyć, nie można dodawać wartości w runtime. Obejścia: abstract classes, composition patterns, registry patterns.

---

#### 📚 Co dalej?

*Świetnie! Teraz rozumiesz pełną moc enum w Javie. To znacznie więcej niż proste stałe - to potężne narzędzie do modelowania domeny i implementacji wzorców projektowych. W następnym rozdziale porozmawiamy o kolekcjach - Listach, Setach, Mapach i ich magicznych sztuczkach!*

---

*💡 Pamiętaj: Enum to nie tylko stałe, to pełnoprawne klasy z supermocarmi. Używaj ich do modelowania stanów, strategii i wszędzie tam, gdzie masz ograniczony zestaw wartości!*


## 11. Kolekcje: List, Set, Map — czyli jak ogarnąć dane

*Cześć! Dziś zagłębimy się w jeden z najważniejszych tematów w Javie - kolekcje. To jak skrzynka narzędzi dla programistki - masz w niej wszystko, czego potrzebujesz do przechowywania, organizowania i manipulowania danymi. ArrayList, HashMap, TreeSet... brzmi znajomo? To dopiero początek! Przygotuj się na odkrycie całego uniwersum kolekcji Java!*

---

#### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Kolekcje to struktury danych, które pozwalają przechowywać i manipulować grupami obiektów. W przeciwieństwie do tablic, kolekcje są dynamiczne - mogą rosnąć i maleć w trakcie działania programu. Java Collections Framework to przemyślana hierarchia interfejsów i klas, która daje Ci narzędzia do każdej sytuacji.

```java
// Tablica - stały rozmiar
String[] tablicaImion = new String[3];
tablicaImion[0] = "Anna";
// Nie można łatwo dodać więcej elementów!

// Lista - dynamiczny rozmiar
List<String> listaImion = new ArrayList<>();
listaImion.add("Anna");
listaImion.add("Kasia");
listaImion.add("Ola");
// Można dodawać ile chcesz!
```

#### Dlaczego to ważne?

Kolekcje to podstawa każdej aplikacji. Czy to lista użytkowników, zestaw uprawnień, czy mapa konfiguracji - bez kolekcji nie da się napisać żadnego sensownego programu. Znajomość różnych typów kolekcji i ich charakterystyk to klucz do pisania wydajnego kodu.

#### Hierarchia kolekcji

```java
// Główne interfejsy:
Collection<E>           // Podstawowy interfejs
├── List<E>            // Uporządkowana kolekcja z duplikatami
├── Set<E>             // Kolekcja bez duplikatów
└── Queue<E>           // Kolejka FIFO

Map<K,V>               // Osobna hierarchia - pary klucz-wartość
```

#### List - uporządkowane listy z duplikatami

**ArrayList - najczęściej używana lista:**

```java
public class ArrayListPrzyklad {
    public static void main(String[] args) {
        // Tworzenie ArrayList
        List<String> lista = new ArrayList<>();
        
        // Dodawanie elementów
        lista.add("Java");
        lista.add("Python");
        lista.add("JavaScript");
        lista.add("Java");  // Duplikaty są dozwolone!
        
        // Dostęp po indeksie
        System.out.println("Pierwszy element: " + lista.get(0));  // "Java"
        System.out.println("Rozmiar: " + lista.size());           // 4
        
        // Wstawianie w określonym miejscu
        lista.add(1, "C++");  // Wstawia na pozycji 1
        System.out.println("Po wstawieniu: " + lista);
        
        // Usuwanie
        lista.remove("Python");        // Usuwa pierwszy wystąpienie
        lista.remove(0);               // Usuwa element na pozycji 0
        System.out.println("Po usunięciu: " + lista);
        
        // Sprawdzanie zawartości
        if (lista.contains("Java")) {
            System.out.println("Lista zawiera Java");
        }
        
        // Iterowanie
        System.out.println("Wszystkie elementy:");
        for (String element : lista) {
            System.out.println("- " + element);
        }
        
        // Lub z indeksami
        for (int i = 0; i < lista.size(); i++) {
            System.out.println(i + ": " + lista.get(i));
        }
    }
}
```

**LinkedList - lista dwukierunkowa:**

```java
public class LinkedListPrzyklad {
    public static void main(String[] args) {
        LinkedList<String> lista = new LinkedList<>();
        
        // LinkedList ma dodatkowe metody
        lista.addFirst("Pierwszy");
        lista.addLast("Ostatni");
        lista.add("Środkowy");
        
        System.out.println("Lista: " + lista);
        
        // Dostęp do końców
        System.out.println("Pierwszy: " + lista.getFirst());
        System.out.println("Ostatni: " + lista.getLast());
        
        // Usuwanie z końców
        String pierwszy = lista.removeFirst();
        String ostatni = lista.removeLast();
        
        System.out.println("Usunięto: " + pierwszy + " i " + ostatni);
        System.out.println("Pozostało: " + lista);
        
        // LinkedList może służyć jako stos (stack)
        lista.push("Nowy element");  // Dodaje na początek
        String zdjety = lista.pop(); // Usuwa z początku
        
        // Lub jako kolejka (queue)
        lista.offer("Do kolejki");   // Dodaje na koniec
        String zKolejki = lista.poll(); // Usuwa z początku
    }
}
```

**Kiedy używać której listy:**

```java
public class PorownanieList {
    public static void main(String[] args) {
        // ArrayList - najczęściej używana
        // + Szybki dostęp po indeksie O(1)
        // + Mało pamięci overhead
        // - Wolne wstawianie/usuwanie w środku O(n)
        List<String> arrayList = new ArrayList<>();
        
        // LinkedList - specjalne przypadki
        // + Szybkie wstawianie/usuwanie na początku/końcu O(1)
        // + Dobra do implementacji stosów/kolejek
        // - Wolny dostęp po indeksie O(n)
        // - Więcej pamięci (każdy element ma referencje)
        List<String> linkedList = new LinkedList<>();
        
        // Vector - przestarzała, używaj ArrayList
        // Jedyna różnica: Vector jest synchronized (thread-safe)
        List<String> vector = new Vector<>();
        
        // Demonstracja wydajności
        demonstrujWydajnosc();
    }
    
    private static void demonstrujWydajnosc() {
        int rozmiar = 100000;
        
        // Test dodawania na końcu
        List<Integer> arrayList = new ArrayList<>();
        long start = System.currentTimeMillis();
        for (int i = 0; i < rozmiar; i++) {
            arrayList.add(i);
        }
        long arrayListTime = System.currentTimeMillis() - start;
        
        List<Integer> linkedList = new LinkedList<>();
        start = System.currentTimeMillis();
        for (int i = 0; i < rozmiar; i++) {
            linkedList.add(i);
        }
        long linkedListTime = System.currentTimeMillis() - start;
        
        System.out.println("Dodawanie " + rozmiar + " elementów:");
        System.out.println("ArrayList: " + arrayListTime + "ms");
        System.out.println("LinkedList: " + linkedListTime + "ms");
    }
}
```

#### Set - kolekcje bez duplikatów

**HashSet - najszybszy set:**

```java
public class HashSetPrzyklad {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        
        // Dodawanie elementów
        set.add("Java");
        set.add("Python");
        set.add("JavaScript");
        set.add("Java");  // Duplikat - zostanie zignorowany!
        
        System.out.println("Set: " + set);  // Tylko unikalne elementy
        System.out.println("Rozmiar: " + set.size());  // 3, nie 4!
        
        // Sprawdzanie zawartości
        if (set.contains("Java")) {
            System.out.println("Set zawiera Java");
        }
        
        // Usuwanie
        set.remove("Python");
        System.out.println("Po usunięciu Python: " + set);
        
        // Iterowanie (kolejność może być różna!)
        System.out.println("Wszystkie elementy:");
        for (String element : set) {
            System.out.println("- " + element);
        }
        
        // Operacje na setach
        Set<String> innySet = Set.of("Java", "C++", "Go");
        
        // Przecięcie (intersection)
        Set<String> przeciecie = new HashSet<>(set);
        przeciecie.retainAll(innySet);
        System.out.println("Przecięcie: " + przeciecie);
        
        // Suma (union)
        Set<String> suma = new HashSet<>(set);
        suma.addAll(innySet);
        System.out.println("Suma: " + suma);
        
        // Różnica
        Set<String> roznica = new HashSet<>(set);
        roznica.removeAll(innySet);
        System.out.println("Różnica: " + roznica);
    }
}
```

**TreeSet - posortowany set:**

```java
public class TreeSetPrzyklad {
    public static void main(String[] args) {
        // TreeSet automatycznie sortuje elementy
        Set<String> sortowanySet = new TreeSet<>();
        sortowanySet.add("Zebra");
        sortowanySet.add("Antylopa");
        sortowanySet.add("Słoń");
        sortowanySet.add("Kot");
        
        System.out.println("TreeSet (posortowany): " + sortowanySet);
        // Wynik: [Antylopa, Kot, Słoń, Zebra]
        
        // TreeSet z liczbami
        TreeSet<Integer> liczby = new TreeSet<>();
        liczby.addAll(Arrays.asList(5, 2, 8, 1, 9, 3));
        System.out.println("Posortowane liczby: " + liczby);
        
        // Dodatkowe metody TreeSet
        System.out.println("Najmniejsza: " + liczby.first());     // 1
        System.out.println("Największa: " + liczby.last());       // 9
        System.out.println("Mniejsze od 5: " + liczby.headSet(5)); // [1, 2, 3]
        System.out.println("Większe od 5: " + liczby.tailSet(5));  // [5, 8, 9]
        System.out.println("Od 3 do 8: " + liczby.subSet(3, 8));   // [3, 5]
        
        // Własny komparator
        Set<String> odwrotnie = new TreeSet<>(Collections.reverseOrder());
        odwrotnie.addAll(Arrays.asList("A", "C", "B", "D"));
        System.out.println("Odwrotnie: " + odwrotnie);  // [D, C, B, A]
    }
}
```

**LinkedHashSet - set z zachowaną kolejnością:**

```java
public class LinkedHashSetPrzyklad {
    public static void main(String[] args) {
        // LinkedHashSet zachowuje kolejność dodawania
        Set<String> linkedSet = new LinkedHashSet<>();
        linkedSet.add("Pierwszy");
        linkedSet.add("Drugi");
        linkedSet.add("Trzeci");
        linkedSet.add("Pierwszy");  // Duplikat - zignorowany
        
        System.out.println("LinkedHashSet: " + linkedSet);
        // Wynik: [Pierwszy, Drugi, Trzeci] - w kolejności dodawania!
        
        // Porównanie z HashSet
        Set<String> hashSet = new HashSet<>();
        hashSet.addAll(linkedSet);
        System.out.println("HashSet: " + hashSet);
        // Kolejność może być inna!
    }
}
```

#### Map - pary klucz-wartość

**HashMap - najczęściej używana mapa:**

```java
public class HashMapPrzyklad {
    public static void main(String[] args) {
        // Tworzenie HashMap
        Map<String, Integer> wiek = new HashMap<>();
        
        // Dodawanie par klucz-wartość
        wiek.put("Anna", 25);
        wiek.put("Kasia", 30);
        wiek.put("Ola", 28);
        wiek.put("Anna", 26);  // Nadpisuje poprzednią wartość!
        
        System.out.println("Mapa wieku: " + wiek);
        
        // Pobieranie wartości
        Integer wiekAnny = wiek.get("Anna");
        System.out.println("Wiek Anny: " + wiekAnny);  // 26
        
        // Bezpieczne pobieranie z domyślną wartością
        Integer wiekNieznajomej = wiek.getOrDefault("Magda", 0);
        System.out.println("Wiek Magdy: " + wiekNieznajomej);  // 0
        
        // Sprawdzanie zawartości
        if (wiek.containsKey("Kasia")) {
            System.out.println("Mamy wiek Kasi");
        }
        
        if (wiek.containsValue(30)) {
            System.out.println("Ktoś ma 30 lat");
        }
        
        // Usuwanie
        wiek.remove("Ola");
        System.out.println("Po usunięciu Oli: " + wiek);
        
        // Iterowanie po mapie
        System.out.println("Wszystkie wpisy:");
        for (Map.Entry<String, Integer> wpis : wiek.entrySet()) {
            System.out.println(wpis.getKey() + " ma " + wpis.getValue() + " lat");
        }
        
        // Iterowanie tylko po kluczach
        System.out.println("Wszystkie imiona:");
        for (String imie : wiek.keySet()) {
            System.out.println("- " + imie);
        }
        
        // Iterowanie tylko po wartościach
        System.out.println("Wszystkie wieki:");
        for (Integer w : wiek.values()) {
            System.out.println("- " + w + " lat");
        }
    }
}
```

**Przydatne metody HashMap:**

```java
public class ZaawansowaneHashMap {
    public static void main(String[] args) {
        Map<String, List<String>> grupy = new HashMap<>();
        
        // putIfAbsent - dodaje tylko jeśli klucz nie istnieje
        grupy.putIfAbsent("programistki", new ArrayList<>());
        grupy.putIfAbsent("programistki", Arrays.asList("Nie zostanie dodane"));
        
        // computeIfAbsent - tworzy wartość jeśli klucz nie istnieje
        grupy.computeIfAbsent("designerki", k -> new ArrayList<>()).add("Anna");
        grupy.computeIfAbsent("programistki", k -> new ArrayList<>()).add("Kasia");
        
        System.out.println("Grupy: " + grupy);
        
        // merge - łączy wartości
        Map<String, Integer> liczniki = new HashMap<>();
        liczniki.put("Java", 5);
        liczniki.put("Python", 3);
        
        // Dodaj 1 do licznika Java (lub ustaw na 1 jeśli nie istnieje)
        liczniki.merge("Java", 1, Integer::sum);      // 5 + 1 = 6
        liczniki.merge("JavaScript", 1, Integer::sum); // Nowy klucz = 1
        
        System.out.println("Liczniki: " + liczniki);
        
        // replace vs put
        Map<String, String> ustawienia = new HashMap<>();
        ustawienia.put("theme", "dark");
        
        ustawienia.replace("theme", "light");     // Zamienia tylko jeśli klucz istnieje
        ustawienia.replace("language", "pl");    // Nie dodaje, bo klucz nie istnieje
        ustawienia.put("language", "pl");        // Dodaje nowy klucz
        
        System.out.println("Ustawienia: " + ustawienia);
    }
}
```

**TreeMap - posortowana mapa:**

```java
public class TreeMapPrzyklad {
    public static void main(String[] args) {
        // TreeMap sortuje po kluczach
        Map<String, String> kraje = new TreeMap<>();
        kraje.put("PL", "Polska");
        kraje.put("DE", "Niemcy");
        kraje.put("FR", "Francja");
        kraje.put("ES", "Hiszpania");
        
        System.out.println("Kraje (posortowane): " + kraje);
        // Wynik: {DE=Niemcy, ES=Hiszpania, FR=Francja, PL=Polska}
        
        // TreeMap z liczbami jako klucze
        TreeMap<Integer, String> ranking = new TreeMap<>();
        ranking.put(3, "Brąz");
        ranking.put(1, "Złoto");
        ranking.put(2, "Srebro");
        
        System.out.println("Ranking: " + ranking);  // {1=Złoto, 2=Srebro, 3=Brąz}
        
        // Dodatkowe metody TreeMap
        System.out.println("Pierwszy klucz: " + ranking.firstKey());    // 1
        System.out.println("Ostatni klucz: " + ranking.lastKey());      // 3
        System.out.println("Klucze < 3: " + ranking.headMap(3));        // {1=Złoto, 2=Srebro}
        System.out.println("Klucze >= 2: " + ranking.tailMap(2));       // {2=Srebro, 3=Brąz}
    }
}
```

#### Praktyczne przykłady użycia

```java
public class PraktycznePrzykladyKolekcji {
    // Zliczanie wystąpień słów
    public static Map<String, Integer> zliczSlowa(String tekst) {
        Map<String, Integer> licznik = new HashMap<>();
        String[] slowa = tekst.toLowerCase().split("\\s+");
        
        for (String slowo : slowa) {
            licznik.merge(slowo, 1, Integer::sum);
        }
        
        return licznik;
    }
    
    // Grupowanie obiektów
    public static Map<String, List<Osoba>> grupujPoMiescie(List<Osoba> osoby) {
        Map<String, List<Osoba>> grupy = new HashMap<>();
        
        for (Osoba osoba : osoby) {
            grupy.computeIfAbsent(osoba.getMiasto(), k -> new ArrayList<>()).add(osoba);
        }
        
        return grupy;
    }
    
    // Cache z LRU (Least Recently Used)
    public static class SimpleCache<K, V> extends LinkedHashMap<K, V> {
        private final int maxSize;
        
        public SimpleCache(int maxSize) {
            super(16, 0.75f, true);  // accessOrder = true
            this.maxSize = maxSize;
        }
        
        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            return size() > maxSize;
        }
    }
    
    public static void main(String[] args) {
        // Test zliczania słów
        String tekst = "Java jest super Java to najlepszy język Java";
        Map<String, Integer> slowa = zliczSlowa(tekst);
        System.out.println("Zliczenie słów: " + slowa);
        
        // Test grupowania
        List<Osoba> osoby = Arrays.asList(
            new Osoba("Anna", "Warszawa"),
            new Osoba("Kasia", "Kraków"),
            new Osoba("Ola", "Warszawa"),
            new Osoba("Magda", "Kraków")
        );
        
        Map<String, List<Osoba>> grupy = grupujPoMiescie(osoby);
        System.out.println("Grupowanie po mieście:");
        grupy.forEach((miasto, lista) -> {
            System.out.println(miasto + ": " + lista.size() + " osób");
        });
        
        // Test cache
        SimpleCache<String, String> cache = new SimpleCache<>(3);
        cache.put("1", "Pierwszy");
        cache.put("2", "Drugi");
        cache.put("3", "Trzeci");
        cache.get("1");  // Użyj "1"
        cache.put("4", "Czwarty");  // "2" zostanie usunięte (LRU)
        
        System.out.println("Cache: " + cache);  // {3=Trzeci, 1=Pierwszy, 4=Czwarty}
    }
    
    static class Osoba {
        private String imie;
        private String miasto;
        
        public Osoba(String imie, String miasto) {
            this.imie = imie;
            this.miasto = miasto;
        }
        
        public String getImie() { return imie; }
        public String getMiasto() { return miasto; }
        
        @Override
        public String toString() {
            return imie;
        }
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Modyfikowanie kolekcji podczas iteracji**

```java
// ŹLE - ConcurrentModificationException!
List<String> lista = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
for (String element : lista) {
    if (element.equals("B")) {
        lista.remove(element);  // Błąd!
    }
}

// DOBRZE - użyj Iterator
Iterator<String> iterator = lista.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    if (element.equals("B")) {
        iterator.remove();  // Bezpieczne
    }
}

// LUB użyj removeIf
lista.removeIf(element -> element.equals("B"));
```

**Pułapka 2: Null w kolekcjach**

```java
List<String> lista = new ArrayList<>();
lista.add(null);  // ArrayList pozwala na null
lista.add("Test");

// HashSet też pozwala na jeden null
Set<String> set = new HashSet<>();
set.add(null);
set.add("Test");

// Ale TreeSet nie pozwala na null!
Set<String> treeSet = new TreeSet<>();
// treeSet.add(null);  // NullPointerException!

// HashMap pozwala na null jako klucz i wartość
Map<String, String> mapa = new HashMap<>();
mapa.put(null, "wartość dla null");
mapa.put("klucz", null);
```

**Pułapka 3: equals() i hashCode() w kolekcjach**

```java
class ZlaOsoba {
    String imie;
    
    public ZlaOsoba(String imie) {
        this.imie = imie;
    }
    
    // Brak equals() i hashCode() - problemy z HashSet/HashMap!
}

class DobraOsoba {
    String imie;
    
    public DobraOsoba(String imie) {
        this.imie = imie;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        DobraOsoba osoba = (DobraOsoba) obj;
        return Objects.equals(imie, osoba.imie);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(imie);
    }
}

// Test
Set<ZlaOsoba> zleOsoby = new HashSet<>();
zleOsoby.add(new ZlaOsoba("Anna"));
zleOsoby.add(new ZlaOsoba("Anna"));  // Dwie różne instancje!
System.out.println("Złe osoby: " + zleOsoby.size());  // 2 - źle!

Set<DobraOsoba> dobreOsoby = new HashSet<>();
dobreOsoby.add(new DobraOsoba("Anna"));
dobreOsoby.add(new DobraOsoba("Anna"));  // Ta sama osoba
System.out.println("Dobre osoby: " + dobreOsoby.size());  // 1 - dobrze!
```

#### 💡 Wskazówki dla Juniorek

- **ArrayList** dla większości przypadków z listami
- **HashSet** dla unikalnych elementów bez kolejności
- **HashMap** dla mapowania klucz-wartość
- **TreeSet/TreeMap** gdy potrzebujesz sortowania
- **LinkedHashSet/LinkedHashMap** gdy ważna jest kolejność
- **Zawsze implementuj equals() i hashCode()** dla własnych klas w kolekcjach

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz metodę, która znajduje najczęściej występujące słowo w tekście.

**Zadanie 2:** Stwórz prostą książkę telefoniczną używając Map.

**Zadanie 3:** Zaimplementuj metodę, która usuwa duplikaty z listy zachowując kolejność.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między ArrayList a LinkedList?
2. Kiedy używać Set zamiast List?
3. Dlaczego ważne jest implementowanie equals() i hashCode() dla klas używanych w HashSet?

---

#### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Java Collections Framework to nie tylko wygodne API - to przemyślana architektura oparta na wzorcach projektowych, z zaawansowanymi optymalizacjami wydajnościowymi i mechanizmami zapewniającymi thread safety. Przyjrzyjmy się wewnętrznym implementacjom i zaawansowanym wzorcom użycia.

##### Wewnętrzne implementacje i optymalizacje

```java
public class CollectionInternals {
    // ArrayList - dynamiczna tablica
    public void demonstrateArrayListGrowth() {
        List<Integer> list = new ArrayList<>(2);  // Początkowa pojemność: 2
        
        for (int i = 0; i < 20; i++) {
            list.add(i);
            // Sprawdź pojemność używając reflection (tylko do demonstracji!)
            try {
                Field elementDataField = ArrayList.class.getDeclaredField("elementData");
                elementDataField.setAccessible(true);
                Object[] elementData = (Object[]) elementDataField.get(list);
                System.out.printf("Size: %d, Capacity: %d%n", list.size(), elementData.length);
            } catch (Exception e) {
                // Ignore
            }
        }
        // ArrayList rośnie o ~50% gdy potrzebuje więcej miejsca
    }
    
    // HashMap - hash table z separate chaining
    public void demonstrateHashMapStructure() {
        Map<String, String> map = new HashMap<>();
        
        // HashMap używa tablicy bucket'ów
        // Każdy bucket to linked list (lub tree dla dużych kolizji)
        
        // Demonstracja kolizji hash
        String key1 = "Aa";  // hashCode: 2112
        String key2 = "BB";  // hashCode: 2112 (kolizja!)
        
        map.put(key1, "Wartość 1");
        map.put(key2, "Wartość 2");
        
        System.out.println("Hash key1: " + key1.hashCode());
        System.out.println("Hash key2: " + key2.hashCode());
        System.out.println("Mapa: " + map);
    }
    
    // TreeMap - Red-Black Tree
    public void demonstrateTreeMapStructure() {
        TreeMap<Integer, String> treeMap = new TreeMap<>();
        
        // TreeMap używa Red-Black Tree dla O(log n) operacji
        treeMap.put(5, "Five");
        treeMap.put(3, "Three");
        treeMap.put(7, "Seven");
        treeMap.put(1, "One");
        treeMap.put(9, "Nine");
        
        // Demonstracja nawigacji w drzewie
        System.out.println("Lower than 5: " + treeMap.lowerEntry(5));    // 3=Three
        System.out.println("Higher than 5: " + treeMap.higherEntry(5));  // 7=Seven
        System.out.println("Floor of 6: " + treeMap.floorEntry(6));      // 5=Five
        System.out.println("Ceiling of 6: " + treeMap.ceilingEntry(6));  // 7=Seven
    }
}
```

##### Concurrent Collections

```java
public class ConcurrentCollections {
    // ConcurrentHashMap - thread-safe HashMap
    public void demonstrateConcurrentHashMap() {
        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
        
        // Atomowe operacje
        concurrentMap.put("counter", 0);
        
        // Thread-safe increment
        concurrentMap.compute("counter", (key, val) -> val == null ? 1 : val + 1);
        
        // Bulk operations
        concurrentMap.putAll(Map.of("a", 1, "b", 2, "c", 3));
        
        // Parallel operations (Java 8+)
        int sum = concurrentMap.reduceValues(1, Integer::sum);
        System.out.println("Sum of values: " + sum);
        
        // Search operations
        String found = concurrentMap.search(1, (key, value) -> 
            value > 2 ? key : null);
        System.out.println("First key with value > 2: " + found);
    }
    
    // CopyOnWriteArrayList - thread-safe List dla read-heavy scenarios
    public void demonstrateCopyOnWriteArrayList() {
        CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>();
        
        // Writes są kosztowne (kopiuje całą tablicę)
        cowList.add("Element 1");
        cowList.add("Element 2");
        
        // Reads są bardzo szybkie i nie wymagają synchronizacji
        for (String element : cowList) {
            System.out.println(element);
            // Można bezpiecznie modyfikować listę podczas iteracji
            cowList.add("Nowy element");  // Nie wpłynie na bieżącą iterację
        }
    }
    
    // BlockingQueue - thread-safe queue z blocking operations
    public void demonstrateBlockingQueue() throws InterruptedException {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);
        
        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    queue.put("Item " + i);  // Blokuje jeśli queue jest pełna
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                while (true) {
                    String item = queue.take();  // Blokuje jeśli queue jest pusta
                    System.out.println("Consumed: " + item);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        Thread.sleep(1000);
        consumer.interrupt();
    }
}
```

##### Custom Collections i wzorce

```java
// Immutable Collections
public class ImmutableCollections {
    // Guava-style immutable list
    public static class ImmutableList<T> implements List<T> {
        private final T[] elements;
        
        @SafeVarargs
        public static <T> ImmutableList<T> of(T... elements) {
            return new ImmutableList<>(elements.clone());
        }
        
        private ImmutableList(T[] elements) {
            this.elements = elements;
        }
        
        @Override
        public T get(int index) {
            return elements[index];
        }
        
        @Override
        public int size() {
            return elements.length;
        }
        
        // Wszystkie mutating operations rzucają UnsupportedOperationException
        @Override
        public boolean add(T t) {
            throw new UnsupportedOperationException("Immutable list");
        }
        
        // ... pozostałe metody
        
        @Override
        public Iterator<T> iterator() {
            return new Iterator<T>() {
                private int index = 0;
                
                @Override
                public boolean hasNext() {
                    return index < elements.length;
                }
                
                @Override
                public T next() {
                    if (!hasNext()) throw new NoSuchElementException();
                    return elements[index++];
                }
            };
        }
        
        // Pozostałe metody interfejsu List...
        @Override public boolean isEmpty() { return elements.length == 0; }
        @Override public boolean contains(Object o) { return indexOf(o) >= 0; }
        @Override public Object[] toArray() { return elements.clone(); }
        @Override public <T1> T1[] toArray(T1[] a) { throw new UnsupportedOperationException(); }
        @Override public boolean remove(Object o) { throw new UnsupportedOperationException(); }
        @Override public boolean containsAll(Collection<?> c) { throw new UnsupportedOperationException(); }
        @Override public boolean addAll(Collection<? extends T> c) { throw new UnsupportedOperationException(); }
        @Override public boolean addAll(int index, Collection<? extends T> c) { throw new UnsupportedOperationException(); }
        @Override public boolean removeAll(Collection<?> c) { throw new UnsupportedOperationException(); }
        @Override public boolean retainAll(Collection<?> c) { throw new UnsupportedOperationException(); }
        @Override public void clear() { throw new UnsupportedOperationException(); }
        @Override public T set(int index, T element) { throw new UnsupportedOperationException(); }
        @Override public void add(int index, T element) { throw new UnsupportedOperationException(); }
        @Override public T remove(int index) { throw new UnsupportedOperationException(); }
        @Override public int indexOf(Object o) { 
            for (int i = 0; i < elements.length; i++) {
                if (Objects.equals(elements[i], o)) return i;
            }
            return -1;
        }
        @Override public int lastIndexOf(Object o) { 
            for (int i = elements.length - 1; i >= 0; i--) {
                if (Objects.equals(elements[i], o)) return i;
            }
            return -1;
        }
        @Override public ListIterator<T> listIterator() { throw new UnsupportedOperationException(); }
        @Override public ListIterator<T> listIterator(int index) { throw new UnsupportedOperationException(); }
        @Override public List<T> subList(int fromIndex, int toIndex) { throw new UnsupportedOperationException(); }
    }
    
    // Multimap - mapa z wieloma wartościami dla klucza
    public static class ListMultimap<K, V> {
        private final Map<K, List<V>> map = new HashMap<>();
        
        public void put(K key, V value) {
            map.computeIfAbsent(key, k -> new ArrayList<>()).add(value);
        }
        
        public List<V> get(K key) {
            return map.getOrDefault(key, Collections.emptyList());
        }
        
        public boolean remove(K key, V value) {
            List<V> values = map.get(key);
            if (values != null) {
                boolean removed = values.remove(value);
                if (values.isEmpty()) {
                    map.remove(key);
                }
                return removed;
            }
            return false;
        }
        
        public Set<K> keySet() {
            return map.keySet();
        }
        
        public Collection<V> values() {
            return map.values().stream()
                     .flatMap(List::stream)
                     .collect(Collectors.toList());
        }
        
        public int size() {
            return map.values().stream()
                     .mapToInt(List::size)
                     .sum();
        }
    }
    
    // BiMap - dwukierunkowa mapa
    public static class BiMap<K, V> {
        private final Map<K, V> forward = new HashMap<>();
        private final Map<V, K> reverse = new HashMap<>();
        
        public V put(K key, V value) {
            // Usuń poprzednie mapowania
            V oldValue = forward.remove(key);
            if (oldValue != null) {
                reverse.remove(oldValue);
            }
            
            K oldKey = reverse.remove(value);
            if (oldKey != null) {
                forward.remove(oldKey);
            }
            
            // Dodaj nowe mapowanie
            forward.put(key, value);
            reverse.put(value, key);
            
            return oldValue;
        }
        
        public V get(K key) {
            return forward.get(key);
        }
        
        public K getKey(V value) {
            return reverse.get(value);
        }
        
        public BiMap<V, K> inverse() {
            BiMap<V, K> inverseBiMap = new BiMap<>();
            inverseBiMap.forward.putAll(this.reverse);
            inverseBiMap.reverse.putAll(this.forward);
            return inverseBiMap;
        }
    }
}
```

##### Performance optimization patterns

```java
public class CollectionOptimizations {
    // Object pooling dla kolekcji
    public static class CollectionPool {
        private final Queue<List<Object>> listPool = new ConcurrentLinkedQueue<>();
        private final Queue<Set<Object>> setPool = new ConcurrentLinkedQueue<>();
        private final Queue<Map<Object, Object>> mapPool = new ConcurrentLinkedQueue<>();
        
        @SuppressWarnings("unchecked")
        public <T> List<T> borrowList() {
            List<Object> list = listPool.poll();
            if (list == null) {
                list = new ArrayList<>();
            } else {
                list.clear();
            }
            return (List<T>) list;
        }
        
        public void returnList(List<?> list) {
            if (list instanceof ArrayList && list.size() < 1000) {
                listPool.offer((List<Object>) list);
            }
        }
        
        // Podobnie dla Set i Map...
    }
    
    // Lazy collections
    public static class LazyList<T> implements List<T> {
        private final Supplier<List<T>> supplier;
        private volatile List<T> delegate;
        
        public LazyList(Supplier<List<T>> supplier) {
            this.supplier = supplier;
        }
        
        private List<T> getDelegate() {
            if (delegate == null) {
                synchronized (this) {
                    if (delegate == null) {
                        delegate = supplier.get();
                    }
                }
            }
            return delegate;
        }
        
        @Override
        public T get(int index) {
            return getDelegate().get(index);
        }
        
        @Override
        public int size() {
            return delegate == null ? 0 : delegate.size();
        }
        
        // Pozostałe metody delegują do getDelegate()...
        @Override public boolean isEmpty() { return size() == 0; }
        @Override public boolean contains(Object o) { return getDelegate().contains(o); }
        @Override public Iterator<T> iterator() { return getDelegate().iterator(); }
        @Override public Object[] toArray() { return getDelegate().toArray(); }
        @Override public <T1> T1[] toArray(T1[] a) { return getDelegate().toArray(a); }
        @Override public boolean add(T t) { return getDelegate().add(t); }
        @Override public boolean remove(Object o) { return getDelegate().remove(o); }
        @Override public boolean containsAll(Collection<?> c) { return getDelegate().containsAll(c); }
        @Override public boolean addAll(Collection<? extends T> c) { return getDelegate().addAll(c); }
        @Override public boolean addAll(int index, Collection<? extends T> c) { return getDelegate().addAll(index, c); }
        @Override public boolean removeAll(Collection<?> c) { return getDelegate().removeAll(c); }
        @Override public boolean retainAll(Collection<?> c) { return getDelegate().retainAll(c); }
        @Override public void clear() { getDelegate().clear(); }
        @Override public T set(int index, T element) { return getDelegate().set(index, element); }
        @Override public void add(int index, T element) { getDelegate().add(index, element); }
        @Override public T remove(int index) { return getDelegate().remove(index); }
        @Override public int indexOf(Object o) { return getDelegate().indexOf(o); }
        @Override public int lastIndexOf(Object o) { return getDelegate().lastIndexOf(o); }
        @Override public ListIterator<T> listIterator() { return getDelegate().listIterator(); }
        @Override public ListIterator<T> listIterator(int index) { return getDelegate().listIterator(index); }
        @Override public List<T> subList(int fromIndex, int toIndex) { return getDelegate().subList(fromIndex, toIndex); }
    }
    
    // Memory-efficient collections dla primitive types
    public static class IntList {
        private int[] elements;
        private int size;
        
        public IntList() {
            this(10);
        }
        
        public IntList(int initialCapacity) {
            this.elements = new int[initialCapacity];
            this.size = 0;
        }
        
        public void add(int value) {
            ensureCapacity(size + 1);
            elements[size++] = value;
        }
        
        public int get(int index) {
            if (index >= size) throw new IndexOutOfBoundsException();
            return elements[index];
        }
        
        public int size() {
            return size;
        }
        
        private void ensureCapacity(int minCapacity) {
            if (minCapacity > elements.length) {
                int newCapacity = Math.max(elements.length * 2, minCapacity);
                elements = Arrays.copyOf(elements, newCapacity);
            }
        }
        
        // Znacznie mniej pamięci niż List<Integer>!
        // int[] vs Integer[] + object overhead
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj thread-safe LRU cache używając LinkedHashMap z automatic eviction i metrics.

**Zadanie Zaawansowane 2:** Stwórz custom collection implementującą trie (prefix tree) dla efektywnego wyszukiwania stringów z autocompletionem.

**Zadanie Zaawansowane 3:** Zaprojektuj memory-efficient collection dla sparse arrays z compression i lazy loading.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak HashMap radzi sobie z kolizjami hash i kiedy przechodzi z linked list na tree?
2. Jakie są trade-offs między ConcurrentHashMap a Collections.synchronizedMap()?
3. Dlaczego CopyOnWriteArrayList jest efektywna dla read-heavy scenarios?

---

#### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static String najczestszeSłowo(String tekst) {
    Map<String, Integer> licznik = new HashMap<>();
    String[] slowa = tekst.toLowerCase().split("\\s+");
    
    // Zlicz wystąpienia
    for (String slowo : slowa) {
        licznik.merge(slowo, 1, Integer::sum);
    }
    
    // Znajdź najczęstsze
    String najczestsze = null;
    int maxLiczba = 0;
    
    for (Map.Entry<String, Integer> wpis : licznik.entrySet()) {
        if (wpis.getValue() > maxLiczba) {
            maxLiczba = wpis.getValue();
            najczestsze = wpis.getKey();
        }
    }
    
    return najczestsze;
}
```

**Zadanie 2:**
```java
public class KsiazkaAdresowa {
    private Map<String, String> kontakty = new HashMap<>();
    
    public void dodajKontakt(String imie, String telefon) {
        kontakty.put(imie, telefon);
    }
    
    public String znajdzTelefon(String imie) {
        return kontakty.get(imie);
    }
    
    public void usunKontakt(String imie) {
        kontakty.remove(imie);
    }
    
    public Set<String> wszystkieImiona() {
        return kontakty.keySet();
    }
    
    public void wyswietlWszystkie() {
        kontakty.forEach((imie, telefon) -> 
            System.out.println(imie + ": " + telefon));
    }
}
```

**Zadanie 3:**
```java
public static <T> List<T> usunDuplikaty(List<T> lista) {
    Set<T> widziane = new LinkedHashSet<>();
    List<T> wynik = new ArrayList<>();
    
    for (T element : lista) {
        if (widziane.add(element)) {  // add() zwraca true jeśli element był nowy
            wynik.add(element);
        }
    }
    
    return wynik;
}

// Lub krócej:
public static <T> List<T> usunDuplikatyKrotko(List<T> lista) {
    return new ArrayList<>(new LinkedHashSet<>(lista));
}
```

**Pytania kontrolne:**
1. ArrayList: szybki dostęp O(1), wolne wstawianie O(n). LinkedList: wolny dostęp O(n), szybkie wstawianie na końcach O(1).
2. Set gdy potrzebujesz unikalnych elementów i szybkiego sprawdzania zawartości.
3. HashSet używa hashCode() do określenia bucket'a i equals() do porównania w bucket'cie. Bez poprawnej implementacji duplikaty nie będą wykrywane.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class ThreadSafeLRUCache<K, V> {
    private final int maxSize;
    private final Map<K, V> cache;
    private final AtomicLong hits = new AtomicLong(0);
    private final AtomicLong misses = new AtomicLong(0);
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public ThreadSafeLRUCache(int maxSize) {
        this.maxSize = maxSize;
        this.cache = new LinkedHashMap<K, V>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > ThreadSafeLRUCache.this.maxSize;
            }
        };
    }
    
    public V get(K key) {
        lock.readLock().lock();
        try {
            V value = cache.get(key);
            if (value != null) {
                hits.incrementAndGet();
            } else {
                misses.incrementAndGet();
            }
            return value;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void put(K key, V value) {
        lock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public CacheMetrics getMetrics() {
        long totalHits = hits.get();
        long totalMisses = misses.get();
        long total = totalHits + totalMisses;
        double hitRate = total > 0 ? (double) totalHits / total : 0.0;
        
        return new CacheMetrics(totalHits, totalMisses, hitRate, cache.size());
    }
    
    public static class CacheMetrics {
        public final long hits;
        public final long misses;
        public final double hitRate;
        public final int size;
        
        public CacheMetrics(long hits, long misses, double hitRate, int size) {
            this.hits = hits;
            this.misses = misses;
            this.hitRate = hitRate;
            this.size = size;
        }
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class TrieCollection implements Collection<String> {
    private static class TrieNode {
        Map<Character, TrieNode> children = new HashMap<>();
        boolean isEndOfWord = false;
        String word = null;
    }
    
    private final TrieNode root = new TrieNode();
    private int size = 0;
    
    @Override
    public boolean add(String word) {
        if (word == null) return false;
        
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            current = current.children.computeIfAbsent(c, k -> new TrieNode());
        }
        
        if (!current.isEndOfWord) {
            current.isEndOfWord = true;
            current.word = word;
            size++;
            return true;
        }
        return false;
    }
    
    @Override
    public boolean contains(Object o) {
        if (!(o instanceof String)) return false;
        String word = (String) o;
        
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            current = current.children.get(c);
            if (current == null) return false;
        }
        return current.isEndOfWord;
    }
    
    public List<String> getWordsWithPrefix(String prefix) {
        List<String> result = new ArrayList<>();
        TrieNode current = root;
        
        // Znajdź węzeł dla prefiksu
        for (char c : prefix.toCharArray()) {
            current = current.children.get(c);
            if (current == null) return result;
        }
        
        // Zbierz wszystkie słowa z tego węzła
        collectWords(current, result);
        return result;
    }
    
    private void collectWords(TrieNode node, List<String> result) {
        if (node.isEndOfWord) {
            result.add(node.word);
        }
        for (TrieNode child : node.children.values()) {
            collectWords(child, result);
        }
    }
    
    @Override
    public int size() {
        return size;
    }
    
    @Override
    public boolean isEmpty() {
        return size == 0;
    }
    
    // Pozostałe metody Collection...
    @Override public Iterator<String> iterator() { 
        List<String> words = new ArrayList<>();
        collectWords(root, words);
        return words.iterator();
    }
    @Override public Object[] toArray() { throw new UnsupportedOperationException(); }
    @Override public <T> T[] toArray(T[] a) { throw new UnsupportedOperationException(); }
    @Override public boolean remove(Object o) { throw new UnsupportedOperationException(); }
    @Override public boolean containsAll(Collection<?> c) { throw new UnsupportedOperationException(); }
    @Override public boolean addAll(Collection<? extends String> c) { 
        boolean modified = false;
        for (String s : c) {
            if (add(s)) modified = true;
        }
        return modified;
    }
    @Override public boolean removeAll(Collection<?> c) { throw new UnsupportedOperationException(); }
    @Override public boolean retainAll(Collection<?> c) { throw new UnsupportedOperationException(); }
    @Override public void clear() { throw new UnsupportedOperationException(); }
}
```

**Pytania kontrolne:**
1. HashMap używa linked list do Java 7, od Java 8 przechodzi na balanced tree (Red-Black) gdy bucket ma >8 elementów, wraca do list gdy <6.
2. ConcurrentHashMap używa segment locking i lock-free algorithms, lepsze performance. Collections.synchronizedMap synchronizuje całą mapę, gorsze performance ale prostsze.
3. CopyOnWriteArrayList kopiuje array tylko przy write operations, reads są lock-free i bardzo szybkie. Idealne gdy reads >> writes.

---

#### 📚 Co dalej?

*Fantastycznie! Teraz masz pełne zrozumienie kolekcji Java - od podstawowych List i Set po zaawansowane concurrent collections i custom implementations. Kolekcje to fundament każdej aplikacji, więc ta wiedza będzie Ci służyć w każdym projekcie. W następnym rozdziale porozmawiamy o Optional - czyli jak elegancko radzić sobie z null!*

---

*💡 Pamiętaj: Wybór odpowiedniej kolekcji to klucz do wydajności. ArrayList dla większości przypadków, HashMap dla mapowań, TreeSet gdy potrzebujesz sortowania!*


## 12. Optional — koniec z NullPointerException!

*Cześć! Dziś porozmawiamy o Optional - jednej z najlepszych rzeczy, które przydarzyły się Javie w ostatnich latach. Jeśli kiedykolwiek spotkałaś się z przerażającym NullPointerException (a kto się nie spotkał?), to Optional to Twój nowy najlepszy przyjaciel. To elegancki sposób na radzenie sobie z wartościami, które mogą nie istnieć. Przygotuj się na odkrycie, jak pisać kod bez strachu przed null!*

---

#### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Optional to kontener, który może zawierać wartość lub być pusty. To jak pudełko, które albo ma w sobie coś ciekawego, albo jest puste. Zamiast zwracać null (i ryzykować NPE), zwracasz Optional, które jasno komunikuje: "ta wartość może nie istnieć".

```java
// Stary sposób - niebezpieczny!
public String znajdzEmail(String userId) {
    User user = database.findUser(userId);
    if (user != null) {
        return user.getEmail();  // A co jeśli email też jest null?
    }
    return null;  // Kto pamięta o sprawdzeniu null?
}

// Nowy sposób - bezpieczny!
public Optional<String> znajdzEmail(String userId) {
    return database.findUser(userId)
                  .map(User::getEmail);  // Jasne: email może nie istnieć
}
```

#### Dlaczego to ważne?

Optional eliminuje większość NullPointerException i czyni kod bardziej czytelnym. Gdy widzisz Optional w sygnaturze metody, od razu wiesz, że wartość może nie istnieć i musisz to obsłużyć.

#### Jak to działa w praktyce?

**Tworzenie Optional:**

```java
public class TworzenieOptional {
    public static void main(String[] args) {
        // Pusty Optional
        Optional<String> pusty = Optional.empty();
        System.out.println("Pusty: " + pusty);  // Optional.empty
        
        // Optional z wartością
        Optional<String> zWartoscia = Optional.of("Hello");
        System.out.println("Z wartością: " + zWartoscia);  // Optional[Hello]
        
        // Optional z możliwym null
        String mozliwyNull = Math.random() > 0.5 ? "Wartość" : null;
        Optional<String> mozePusty = Optional.ofNullable(mozliwyNull);
        System.out.println("Może pusty: " + mozePusty);
        
        // UWAGA: Optional.of(null) rzuci NullPointerException!
        // Optional<String> blad = Optional.of(null);  // Błąd!
    }
}
```

**Sprawdzanie i pobieranie wartości:**

```java
public class PobieranieWartosci {
    public static void main(String[] args) {
        Optional<String> optional = Optional.of("Java");
        
        // Sprawdzanie czy wartość istnieje
        if (optional.isPresent()) {
            System.out.println("Wartość: " + optional.get());
        }
        
        // Sprawdzanie czy jest pusty
        if (optional.isEmpty()) {  // Java 11+
            System.out.println("Optional jest pusty");
        }
        
        // Bezpieczne pobieranie z domyślną wartością
        String wartosc = optional.orElse("Domyślna wartość");
        System.out.println("Wartość lub domyślna: " + wartosc);
        
        // Lazy domyślna wartość
        String wartoscLazy = optional.orElseGet(() -> {
            System.out.println("Tworzę domyślną wartość");
            return "Domyślna";
        });
        
        // Rzucenie wyjątku jeśli pusty
        try {
            String wartoscLubWyjatek = optional.orElseThrow();  // Java 10+
            System.out.println("Wartość: " + wartoscLubWyjatek);
        } catch (NoSuchElementException e) {
            System.out.println("Optional był pusty!");
        }
        
        // Własny wyjątek
        String wartoscLubWlasnyWyjatek = optional.orElseThrow(
            () -> new IllegalStateException("Brak wartości!")
        );
    }
}
```

**Transformacje Optional:**

```java
public class TransformacjeOptional {
    public static void main(String[] args) {
        Optional<String> imie = Optional.of("anna");
        
        // map - transformuje wartość jeśli istnieje
        Optional<String> wielkaLitera = imie.map(String::toUpperCase);
        System.out.println("Wielka litera: " + wielkaLitera);  // Optional[ANNA]
        
        Optional<Integer> dlugosc = imie.map(String::length);
        System.out.println("Długość: " + dlugosc);  // Optional[4]
        
        // filter - filtruje wartość
        Optional<String> dlugie = imie.filter(s -> s.length() > 3);
        System.out.println("Długie imię: " + dlugie);  // Optional[anna]
        
        Optional<String> krotkie = imie.filter(s -> s.length() < 3);
        System.out.println("Krótkie imię: " + krotkie);  // Optional.empty
        
        // flatMap - dla zagnieżdżonych Optional
        Optional<Optional<String>> zagniezdzone = Optional.of(Optional.of("test"));
        Optional<String> plaskie = zagniezdzone.flatMap(opt -> opt);
        System.out.println("Płaskie: " + plaskie);  // Optional[test]
        
        // Łańcuchowanie operacji
        Optional<String> wynik = imie
            .filter(s -> s.length() > 2)
            .map(String::toUpperCase)
            .map(s -> "Pani " + s);
        
        System.out.println("Wynik: " + wynik);  // Optional[Pani ANNA]
    }
}
```

**Działania na Optional:**

```java
public class DzialaniaOptional {
    public static void main(String[] args) {
        Optional<String> imie = Optional.of("Kasia");
        Optional<String> pusty = Optional.empty();
        
        // ifPresent - wykonaj akcję jeśli wartość istnieje
        imie.ifPresent(s -> System.out.println("Cześć " + s + "!"));
        pusty.ifPresent(s -> System.out.println("To się nie wykona"));
        
        // ifPresentOrElse - wykonaj akcję lub alternatywę (Java 9+)
        imie.ifPresentOrElse(
            s -> System.out.println("Znaleziono: " + s),
            () -> System.out.println("Nie znaleziono")
        );
        
        pusty.ifPresentOrElse(
            s -> System.out.println("Znaleziono: " + s),
            () -> System.out.println("Nie znaleziono")
        );
        
        // or - alternatywny Optional (Java 9+)
        Optional<String> alternatywa = pusty.or(() -> Optional.of("Domyślne"));
        System.out.println("Alternatywa: " + alternatywa);  // Optional[Domyślne]
        
        // stream - konwersja do Stream (Java 9+)
        List<String> lista = imie.stream()
                                .map(String::toUpperCase)
                                .collect(Collectors.toList());
        System.out.println("Lista: " + lista);  // [KASIA]
    }
}
```

#### Praktyczne przykłady

```java
public class PraktyczneOptional {
    // Wyszukiwanie użytkownika
    public static Optional<User> znajdzUzytkownika(String email) {
        // Symulacja bazy danych
        Map<String, User> baza = Map.of(
            "anna@example.com", new User("Anna", "anna@example.com"),
            "kasia@example.com", new User("Kasia", "kasia@example.com")
        );
        
        return Optional.ofNullable(baza.get(email));
    }
    
    // Bezpieczne parsowanie
    public static Optional<Integer> bezpieczneParsowanie(String tekst) {
        try {
            return Optional.of(Integer.parseInt(tekst));
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }
    
    // Łańcuchowanie operacji
    public static Optional<String> pobierzNazweKategorii(String produktId) {
        return znajdzProdukt(produktId)
            .flatMap(Product::getCategory)
            .map(Category::getName);
    }
    
    // Konfiguracja z domyślnymi wartościami
    public static class Konfiguracja {
        private final Map<String, String> ustawienia;
        
        public Konfiguracja(Map<String, String> ustawienia) {
            this.ustawienia = ustawienia;
        }
        
        public Optional<String> getString(String klucz) {
            return Optional.ofNullable(ustawienia.get(klucz));
        }
        
        public Optional<Integer> getInt(String klucz) {
            return getString(klucz).flatMap(PraktyczneOptional::bezpieczneParsowanie);
        }
        
        public String getStringOrDefault(String klucz, String domyslna) {
            return getString(klucz).orElse(domyslna);
        }
        
        public int getIntOrDefault(String klucz, int domyslna) {
            return getInt(klucz).orElse(domyslna);
        }
    }
    
    public static void main(String[] args) {
        // Test wyszukiwania użytkownika
        znajdzUzytkownika("anna@example.com")
            .ifPresentOrElse(
                user -> System.out.println("Znaleziono: " + user.getName()),
                () -> System.out.println("Użytkownik nie istnieje")
            );
        
        // Test parsowania
        bezpieczneParsowanie("123")
            .ifPresent(liczba -> System.out.println("Liczba: " + liczba));
        
        bezpieczneParsowanie("abc")
            .ifPresentOrElse(
                liczba -> System.out.println("Liczba: " + liczba),
                () -> System.out.println("Nieprawidłowy format liczby")
            );
        
        // Test konfiguracji
        Map<String, String> ustawienia = Map.of(
            "port", "8080",
            "host", "localhost"
        );
        
        Konfiguracja config = new Konfiguracja(ustawienia);
        
        int port = config.getIntOrDefault("port", 3000);
        String host = config.getStringOrDefault("host", "127.0.0.1");
        int timeout = config.getIntOrDefault("timeout", 30);
        
        System.out.printf("Serwer: %s:%d, timeout: %d%n", host, port, timeout);
    }
    
    // Pomocnicze klasy
    static class User {
        private String name;
        private String email;
        
        public User(String name, String email) {
            this.name = name;
            this.email = email;
        }
        
        public String getName() { return name; }
        public String getEmail() { return email; }
    }
    
    static class Product {
        private String id;
        private Optional<Category> category;
        
        public Product(String id, Category category) {
            this.id = id;
            this.category = Optional.ofNullable(category);
        }
        
        public String getId() { return id; }
        public Optional<Category> getCategory() { return category; }
    }
    
    static class Category {
        private String name;
        
        public Category(String name) {
            this.name = name;
        }
        
        public String getName() { return name; }
    }
    
    private static Optional<Product> znajdzProdukt(String id) {
        // Symulacja
        return Optional.of(new Product(id, new Category("Elektronika")));
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Nadużywanie Optional**

```java
// ŹLE - Optional w polach klasy
public class ZlaKlasa {
    private Optional<String> imie;  // Nie rób tego!
    
    public Optional<String> getImie() {
        return imie;
    }
}

// DOBRZE - Optional tylko w return types
public class DobraKlasa {
    private String imie;  // Może być null
    
    public Optional<String> getImie() {
        return Optional.ofNullable(imie);
    }
}
```

**Pułapka 2: get() bez sprawdzenia**

```java
Optional<String> optional = Optional.empty();

// ŹLE - może rzucić NoSuchElementException!
String wartosc = optional.get();

// DOBRZE - zawsze sprawdź lub użyj orElse
if (optional.isPresent()) {
    String wartosc = optional.get();
}

// LUB lepiej:
String wartosc = optional.orElse("domyślna");
```

**Pułapka 3: Optional.of() z null**

```java
String mozliwyNull = null;

// ŹLE - rzuci NullPointerException!
Optional<String> optional = Optional.of(mozliwyNull);

// DOBRZE - użyj ofNullable
Optional<String> optional = Optional.ofNullable(mozliwyNull);
```

#### 💡 Wskazówki dla Juniorek

- **Optional tylko w return types**, nie w polach klasy
- **Nigdy nie zwracaj null** zamiast Optional.empty()
- **Używaj orElse/orElseGet** zamiast get()
- **Łańcuchuj operacje** map/filter/flatMap
- **ifPresent** zamiast isPresent() + get()

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz metodę, która bezpiecznie pobiera pierwszy element z listy.

**Zadanie 2:** Stwórz klasę UserService z metodami zwracającymi Optional.

**Zadanie 3:** Zaimplementuj cache z Optional dla miss'ów.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między Optional.of() a Optional.ofNullable()?
2. Kiedy używać orElse() a kiedy orElseGet()?
3. Dlaczego nie należy używać Optional w polach klasy?

---

#### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Optional to nie tylko wrapper na null - to monad, który wprowadza funkcyjny styl programowania do Javy. Zrozumienie jego wewnętrznej implementacji i zaawansowanych wzorców użycia pozwala pisać bardziej elegancki i bezpieczny kod.

##### Wewnętrzna implementacja Optional

```java
public class OptionalInternals {
    // Uproszczona implementacja Optional (podobna do rzeczywistej)
    public static final class SimpleOptional<T> {
        private static final SimpleOptional<?> EMPTY = new SimpleOptional<>(null);
        
        private final T value;
        
        private SimpleOptional(T value) {
            this.value = value;
        }
        
        @SuppressWarnings("unchecked")
        public static <T> SimpleOptional<T> empty() {
            return (SimpleOptional<T>) EMPTY;
        }
        
        public static <T> SimpleOptional<T> of(T value) {
            if (value == null) {
                throw new NullPointerException("Value cannot be null");
            }
            return new SimpleOptional<>(value);
        }
        
        public static <T> SimpleOptional<T> ofNullable(T value) {
            return value == null ? empty() : of(value);
        }
        
        public boolean isPresent() {
            return value != null;
        }
        
        public T get() {
            if (value == null) {
                throw new NoSuchElementException("No value present");
            }
            return value;
        }
        
        public T orElse(T other) {
            return value != null ? value : other;
        }
        
        public T orElseGet(Supplier<? extends T> supplier) {
            return value != null ? value : supplier.get();
        }
        
        public <U> SimpleOptional<U> map(Function<? super T, ? extends U> mapper) {
            if (!isPresent()) {
                return empty();
            }
            return SimpleOptional.ofNullable(mapper.apply(value));
        }
        
        public <U> SimpleOptional<U> flatMap(Function<? super T, ? extends SimpleOptional<? extends U>> mapper) {
            if (!isPresent()) {
                return empty();
            }
            @SuppressWarnings("unchecked")
            SimpleOptional<U> result = (SimpleOptional<U>) mapper.apply(value);
            return Objects.requireNonNull(result);
        }
        
        public SimpleOptional<T> filter(Predicate<? super T> predicate) {
            if (!isPresent()) {
                return this;
            }
            return predicate.test(value) ? this : empty();
        }
    }
    
    // Performance analysis
    public void demonstrateOptionalPerformance() {
        // Optional ma minimalny overhead
        // Główny koszt to alokacja obiektów
        
        // Benchmark: Optional vs null checking
        String value = "test";
        
        // Traditional null checking
        long start = System.nanoTime();
        for (int i = 0; i < 1_000_000; i++) {
            String result = value != null ? value.toUpperCase() : "DEFAULT";
        }
        long traditionalTime = System.nanoTime() - start;
        
        // Optional approach
        Optional<String> optional = Optional.ofNullable(value);
        start = System.nanoTime();
        for (int i = 0; i < 1_000_000; i++) {
            String result = optional.map(String::toUpperCase).orElse("DEFAULT");
        }
        long optionalTime = System.nanoTime() - start;
        
        System.out.printf("Traditional: %d ns, Optional: %d ns%n", 
                         traditionalTime, optionalTime);
        // Optional jest ~2-3x wolniejszy, ale różnica jest minimalna
    }
}
```

##### Zaawansowane wzorce z Optional

```java
public class AdvancedOptionalPatterns {
    // Optional chaining dla complex object graphs
    public static class Address {
        private final String street;
        private final String city;
        private final String country;
        
        public Address(String street, String city, String country) {
            this.street = street;
            this.city = city;
            this.country = country;
        }
        
        public Optional<String> getStreet() { return Optional.ofNullable(street); }
        public Optional<String> getCity() { return Optional.ofNullable(city); }
        public Optional<String> getCountry() { return Optional.ofNullable(country); }
    }
    
    public static class Person {
        private final String name;
        private final Address address;
        
        public Person(String name, Address address) {
            this.name = name;
            this.address = address;
        }
        
        public Optional<String> getName() { return Optional.ofNullable(name); }
        public Optional<Address> getAddress() { return Optional.ofNullable(address); }
    }
    
    // Safe navigation through object graph
    public static Optional<String> getPersonCountry(Person person) {
        return Optional.ofNullable(person)
                      .flatMap(Person::getAddress)
                      .flatMap(Address::getCountry);
    }
    
    // Optional accumulation pattern
    public static class ValidationResult {
        private final List<String> errors;
        
        private ValidationResult(List<String> errors) {
            this.errors = errors;
        }
        
        public static ValidationResult success() {
            return new ValidationResult(Collections.emptyList());
        }
        
        public static ValidationResult failure(String error) {
            return new ValidationResult(List.of(error));
        }
        
        public ValidationResult and(ValidationResult other) {
            List<String> combinedErrors = new ArrayList<>(this.errors);
            combinedErrors.addAll(other.errors);
            return new ValidationResult(combinedErrors);
        }
        
        public boolean isValid() {
            return errors.isEmpty();
        }
        
        public List<String> getErrors() {
            return errors;
        }
        
        public <T> Optional<T> toOptional(T value) {
            return isValid() ? Optional.of(value) : Optional.empty();
        }
    }
    
    // Validation with Optional
    public static Optional<Person> validateAndCreatePerson(String name, String street, String city, String country) {
        ValidationResult nameValidation = validateName(name);
        ValidationResult addressValidation = validateAddress(street, city, country);
        
        ValidationResult combined = nameValidation.and(addressValidation);
        
        if (combined.isValid()) {
            Address address = new Address(street, city, country);
            Person person = new Person(name, address);
            return Optional.of(person);
        } else {
            System.out.println("Validation errors: " + combined.getErrors());
            return Optional.empty();
        }
    }
    
    private static ValidationResult validateName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return ValidationResult.failure("Name cannot be empty");
        }
        if (name.length() < 2) {
            return ValidationResult.failure("Name must be at least 2 characters");
        }
        return ValidationResult.success();
    }
    
    private static ValidationResult validateAddress(String street, String city, String country) {
        ValidationResult result = ValidationResult.success();
        
        if (street == null || street.trim().isEmpty()) {
            result = result.and(ValidationResult.failure("Street cannot be empty"));
        }
        if (city == null || city.trim().isEmpty()) {
            result = result.and(ValidationResult.failure("City cannot be empty"));
        }
        if (country == null || country.trim().isEmpty()) {
            result = result.and(ValidationResult.failure("Country cannot be empty"));
        }
        
        return result;
    }
    
    // Optional-based caching
    public static class OptionalCache<K, V> {
        private final Map<K, Optional<V>> cache = new ConcurrentHashMap<>();
        private final Function<K, Optional<V>> loader;
        
        public OptionalCache(Function<K, Optional<V>> loader) {
            this.loader = loader;
        }
        
        public Optional<V> get(K key) {
            return cache.computeIfAbsent(key, loader);
        }
        
        public void invalidate(K key) {
            cache.remove(key);
        }
        
        public void clear() {
            cache.clear();
        }
        
        // Cache statistics
        public int size() {
            return cache.size();
        }
        
        public long hitCount() {
            return cache.values().stream()
                       .mapToLong(opt -> opt.isPresent() ? 1 : 0)
                       .sum();
        }
        
        public long missCount() {
            return cache.values().stream()
                       .mapToLong(opt -> opt.isEmpty() ? 1 : 0)
                       .sum();
        }
    }
    
    // Try-Optional pattern for exception handling
    public static class Try<T> {
        private final Optional<T> value;
        private final Optional<Exception> exception;
        
        private Try(T value, Exception exception) {
            this.value = Optional.ofNullable(value);
            this.exception = Optional.ofNullable(exception);
        }
        
        public static <T> Try<T> success(T value) {
            return new Try<>(value, null);
        }
        
        public static <T> Try<T> failure(Exception exception) {
            return new Try<>(null, exception);
        }
        
        public static <T> Try<T> of(Supplier<T> supplier) {
            try {
                return success(supplier.get());
            } catch (Exception e) {
                return failure(e);
            }
        }
        
        public boolean isSuccess() {
            return value.isPresent();
        }
        
        public boolean isFailure() {
            return exception.isPresent();
        }
        
        public Optional<T> toOptional() {
            return value;
        }
        
        public T get() {
            return value.orElseThrow(() -> new RuntimeException("Try failed", exception.orElse(null)));
        }
        
        public T getOrElse(T defaultValue) {
            return value.orElse(defaultValue);
        }
        
        public <U> Try<U> map(Function<T, U> mapper) {
            if (isSuccess()) {
                return Try.of(() -> mapper.apply(value.get()));
            } else {
                return Try.failure(exception.get());
            }
        }
        
        public <U> Try<U> flatMap(Function<T, Try<U>> mapper) {
            if (isSuccess()) {
                try {
                    return mapper.apply(value.get());
                } catch (Exception e) {
                    return Try.failure(e);
                }
            } else {
                return Try.failure(exception.get());
            }
        }
        
        public Try<T> recover(Function<Exception, T> recovery) {
            if (isFailure()) {
                return Try.of(() -> recovery.apply(exception.get()));
            } else {
                return this;
            }
        }
    }
}
```

##### Functional programming patterns

```java
public class FunctionalOptionalPatterns {
    // Optional as a Monad
    public static <T> Optional<T> unit(T value) {
        return Optional.ofNullable(value);
    }
    
    public static <T, U> Optional<U> bind(Optional<T> optional, Function<T, Optional<U>> function) {
        return optional.flatMap(function);
    }
    
    // Applicative functor pattern
    public static <T, U, R> Optional<R> lift2(Optional<T> opt1, Optional<U> opt2, BiFunction<T, U, R> function) {
        return opt1.flatMap(t -> opt2.map(u -> function.apply(t, u)));
    }
    
    public static <T, U, V, R> Optional<R> lift3(Optional<T> opt1, Optional<U> opt2, Optional<V> opt3, 
                                                 TriFunction<T, U, V, R> function) {
        return opt1.flatMap(t -> 
               opt2.flatMap(u -> 
               opt3.map(v -> function.apply(t, u, v))));
    }
    
    @FunctionalInterface
    public interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }
    
    // Optional sequence operations
    public static <T> Optional<List<T>> sequence(List<Optional<T>> optionals) {
        List<T> result = new ArrayList<>();
        for (Optional<T> optional : optionals) {
            if (optional.isPresent()) {
                result.add(optional.get());
            } else {
                return Optional.empty();
            }
        }
        return Optional.of(result);
    }
    
    public static <T> List<T> catOptionals(List<Optional<T>> optionals) {
        return optionals.stream()
                       .filter(Optional::isPresent)
                       .map(Optional::get)
                       .collect(Collectors.toList());
    }
    
    // Optional-based parser combinators
    public static class Parser<T> {
        private final Function<String, Optional<ParseResult<T>>> parseFunction;
        
        public Parser(Function<String, Optional<ParseResult<T>>> parseFunction) {
            this.parseFunction = parseFunction;
        }
        
        public Optional<ParseResult<T>> parse(String input) {
            return parseFunction.apply(input);
        }
        
        public <U> Parser<U> map(Function<T, U> mapper) {
            return new Parser<>(input -> 
                parse(input).map(result -> 
                    new ParseResult<>(mapper.apply(result.value), result.remaining)));
        }
        
        public <U> Parser<U> flatMap(Function<T, Parser<U>> mapper) {
            return new Parser<>(input ->
                parse(input).flatMap(result ->
                    mapper.apply(result.value).parse(result.remaining)));
        }
        
        public Parser<T> or(Parser<T> alternative) {
            return new Parser<>(input -> {
                Optional<ParseResult<T>> result = parse(input);
                return result.isPresent() ? result : alternative.parse(input);
            });
        }
        
        public static class ParseResult<T> {
            public final T value;
            public final String remaining;
            
            public ParseResult(T value, String remaining) {
                this.value = value;
                this.remaining = remaining;
            }
        }
        
        // Basic parsers
        public static Parser<Character> character(char c) {
            return new Parser<>(input -> {
                if (!input.isEmpty() && input.charAt(0) == c) {
                    return Optional.of(new ParseResult<>(c, input.substring(1)));
                }
                return Optional.empty();
            });
        }
        
        public static Parser<String> string(String s) {
            return new Parser<>(input -> {
                if (input.startsWith(s)) {
                    return Optional.of(new ParseResult<>(s, input.substring(s.length())));
                }
                return Optional.empty();
            });
        }
        
        public static Parser<Integer> integer() {
            return new Parser<>(input -> {
                StringBuilder sb = new StringBuilder();
                int i = 0;
                
                if (i < input.length() && input.charAt(i) == '-') {
                    sb.append('-');
                    i++;
                }
                
                while (i < input.length() && Character.isDigit(input.charAt(i))) {
                    sb.append(input.charAt(i));
                    i++;
                }
                
                if (sb.length() > 0 && !sb.toString().equals("-")) {
                    try {
                        int value = Integer.parseInt(sb.toString());
                        return Optional.of(new ParseResult<>(value, input.substring(i)));
                    } catch (NumberFormatException e) {
                        return Optional.empty();
                    }
                }
                
                return Optional.empty();
            });
        }
    }
    
    public static void demonstrateParsers() {
        Parser<Integer> intParser = Parser.integer();
        Parser<Character> plusParser = Parser.character('+');
        
        // Parse "123+456"
        Parser<Integer> additionParser = intParser.flatMap(left ->
            plusParser.flatMap(op ->
                intParser.map(right -> left + right)));
        
        Optional<Parser.ParseResult<Integer>> result = additionParser.parse("123+456");
        result.ifPresent(r -> System.out.println("Result: " + r.value)); // Result: 579
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj Optional-based Result type z error handling i recovery mechanisms.

**Zadanie Zaawansowane 2:** Stwórz system validation rules używając Optional i functional composition.

**Zadanie Zaawansowane 3:** Zaprojektuj Optional-based query builder z lazy evaluation i optimization.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak Optional implementuje monad laws i jakie to ma praktyczne implikacje?
2. Jakie są performance implications używania Optional w hot paths?
3. Jak Optional wpływa na garbage collection i memory allocation patterns?

---

#### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static <T> Optional<T> pierwszyElement(List<T> lista) {
    if (lista == null || lista.isEmpty()) {
        return Optional.empty();
    }
    return Optional.ofNullable(lista.get(0));
}

// Lub krócej:
public static <T> Optional<T> pierwszyElementKrotko(List<T> lista) {
    return Optional.ofNullable(lista)
                  .filter(l -> !l.isEmpty())
                  .map(l -> l.get(0));
}
```

**Zadanie 2:**
```java
public class UserService {
    private final Map<String, User> users = new HashMap<>();
    
    public Optional<User> findById(String id) {
        return Optional.ofNullable(users.get(id));
    }
    
    public Optional<User> findByEmail(String email) {
        return users.values().stream()
                   .filter(user -> email.equals(user.getEmail()))
                   .findFirst();
    }
    
    public Optional<String> getUserDisplayName(String userId) {
        return findById(userId)
                .map(User::getName)
                .filter(name -> !name.trim().isEmpty())
                .or(() -> findById(userId).map(User::getEmail));
    }
    
    public boolean updateUser(String id, Function<User, User> updater) {
        return findById(id)
                .map(user -> {
                    User updated = updater.apply(user);
                    users.put(id, updated);
                    return true;
                })
                .orElse(false);
    }
}
```

**Zadanie 3:**
```java
public class OptionalCache<K, V> {
    private final Map<K, Optional<V>> cache = new HashMap<>();
    private final Function<K, V> loader;
    
    public OptionalCache(Function<K, V> loader) {
        this.loader = loader;
    }
    
    public Optional<V> get(K key) {
        return cache.computeIfAbsent(key, k -> {
            V value = loader.apply(k);
            return Optional.ofNullable(value);
        });
    }
    
    public void put(K key, V value) {
        cache.put(key, Optional.ofNullable(value));
    }
    
    public void invalidate(K key) {
        cache.remove(key);
    }
    
    public boolean isCached(K key) {
        return cache.containsKey(key);
    }
}
```

**Pytania kontrolne:**
1. Optional.of() rzuca NPE jeśli wartość jest null, Optional.ofNullable() zwraca Optional.empty() dla null.
2. orElse() zawsze wykonuje argument, orElseGet() wykonuje Supplier tylko gdy Optional jest pusty (lazy evaluation).
3. Optional w polach zwiększa memory overhead, komplikuje serializację i nie jest thread-safe. Używaj tylko w return types.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public abstract class Result<T, E> {
    public abstract boolean isSuccess();
    public abstract boolean isFailure();
    public abstract T getValue();
    public abstract E getError();
    
    public static <T, E> Result<T, E> success(T value) {
        return new Success<>(value);
    }
    
    public static <T, E> Result<T, E> failure(E error) {
        return new Failure<>(error);
    }
    
    public <U> Result<U, E> map(Function<T, U> mapper) {
        if (isSuccess()) {
            try {
                return success(mapper.apply(getValue()));
            } catch (Exception e) {
                @SuppressWarnings("unchecked")
                E error = (E) e;
                return failure(error);
            }
        } else {
            return failure(getError());
        }
    }
    
    public <U> Result<U, E> flatMap(Function<T, Result<U, E>> mapper) {
        if (isSuccess()) {
            try {
                return mapper.apply(getValue());
            } catch (Exception e) {
                @SuppressWarnings("unchecked")
                E error = (E) e;
                return failure(error);
            }
        } else {
            return failure(getError());
        }
    }
    
    public Result<T, E> recover(Function<E, T> recovery) {
        if (isFailure()) {
            try {
                return success(recovery.apply(getError()));
            } catch (Exception e) {
                @SuppressWarnings("unchecked")
                E error = (E) e;
                return failure(error);
            }
        } else {
            return this;
        }
    }
    
    public Optional<T> toOptional() {
        return isSuccess() ? Optional.of(getValue()) : Optional.empty();
    }
    
    private static class Success<T, E> extends Result<T, E> {
        private final T value;
        
        public Success(T value) {
            this.value = value;
        }
        
        @Override public boolean isSuccess() { return true; }
        @Override public boolean isFailure() { return false; }
        @Override public T getValue() { return value; }
        @Override public E getError() { throw new IllegalStateException("Success has no error"); }
    }
    
    private static class Failure<T, E> extends Result<T, E> {
        private final E error;
        
        public Failure(E error) {
            this.error = error;
        }
        
        @Override public boolean isSuccess() { return false; }
        @Override public boolean isFailure() { return true; }
        @Override public T getValue() { throw new IllegalStateException("Failure has no value"); }
        @Override public E getError() { return error; }
    }
}
```

**Pytania kontrolne:**
1. Optional spełnia monad laws: left identity, right identity, associativity. Praktycznie oznacza to przewidywalne zachowanie przy łańcuchowaniu operacji.
2. Optional ma overhead ~16 bytes per instance + GC pressure. W hot paths lepiej używać tradycyjnego null checking.
3. Optional tworzy dodatkowe obiekty, zwiększając allocation rate. Może wpływać na GC frequency, szczególnie w young generation.

---

#### 📚 Co dalej?

*Świetnie! Teraz rozumiesz pełną moc Optional - od podstawowego użycia po zaawansowane wzorce funkcyjne. Optional to nie tylko sposób na unikanie NPE, to wprowadzenie funkcyjnego stylu programowania do Javy. W następnym rozdziale porozmawiamy o rekordach - czyli jak elegancko tworzyć immutable data classes!*

---

*💡 Pamiętaj: Optional to nie tylko wrapper na null, to monad, który pozwala elegancko łańcuchować operacje i obsługiwać brak wartości w funkcyjny sposób!*


## 13. Rekordy (Records) — immutable data classes bez bólu

*Cześć! Na koniec drugiej sekcji porozmawiamy o rekordach - jednej z najfajniejszych nowości w Javie 14+. Jeśli kiedykolwiek męczyłaś się z pisaniem getterów, setterów, equals(), hashCode() i toString() dla prostych klas danych, to rekordy to Twój nowy najlepszy przyjaciel. Przygotuj się na odkrycie, jak pisać czyste, immutable data classes w jednej linii!*

---

#### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Record to specjalny typ klasy wprowadzony w Javie 14 (preview) i stabilny od Javy 16. To sposób na tworzenie immutable data classes bez pisania boilerplate code. Kompilator automatycznie generuje konstruktor, gettery, equals(), hashCode() i toString().

```java
// Stary sposób - dużo kodu!
public class StaraOsoba {
    private final String imie;
    private final int wiek;
    
    public StaraOsoba(String imie, int wiek) {
        this.imie = imie;
        this.wiek = wiek;
    }
    
    public String getImie() { return imie; }
    public int getWiek() { return wiek; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        StaraOsoba osoba = (StaraOsoba) obj;
        return wiek == osoba.wiek && Objects.equals(imie, osoba.imie);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(imie, wiek);
    }
    
    @Override
    public String toString() {
        return "StaraOsoba{imie='" + imie + "', wiek=" + wiek + "}";
    }
}

// Nowy sposób - jedna linia!
public record Osoba(String imie, int wiek) {}
```

#### Dlaczego to ważne?

Rekordy eliminują boilerplate code i czyni kod bardziej czytelnym. Są idealne do reprezentowania immutable data - DTOs, value objects, konfiguracji. Kompilator gwarantuje poprawność implementacji equals/hashCode.

#### Jak to działa w praktyce?

**Podstawowe użycie rekordów:**

```java
public class PodstawoweRekordy {
    // Prosty rekord
    public record Punkt(int x, int y) {}
    
    // Rekord z różnymi typami
    public record Uzytkownik(String imie, String email, int wiek, boolean aktywny) {}
    
    // Rekord z kolekcjami
    public record Zespol(String nazwa, List<String> czlonkowie) {}
    
    public static void main(String[] args) {
        // Tworzenie rekordów
        Punkt punkt = new Punkt(10, 20);
        Uzytkownik user = new Uzytkownik("Anna", "anna@example.com", 25, true);
        
        // Automatyczne gettery (bez "get" prefix!)
        System.out.println("X: " + punkt.x());        // 10
        System.out.println("Y: " + punkt.y());        // 20
        System.out.println("Imię: " + user.imie());   // Anna
        System.out.println("Email: " + user.email()); // anna@example.com
        
        // Automatyczny toString()
        System.out.println("Punkt: " + punkt);        // Punkt[x=10, y=20]
        System.out.println("User: " + user);          // Uzytkownik[imie=Anna, email=anna@example.com, wiek=25, aktywny=true]
        
        // Automatyczny equals() i hashCode()
        Punkt punkt2 = new Punkt(10, 20);
        System.out.println("Punkty równe: " + punkt.equals(punkt2));  // true
        System.out.println("Hash punkt1: " + punkt.hashCode());
        System.out.println("Hash punkt2: " + punkt2.hashCode());      // Ten sam!
        
        // Rekordy w kolekcjach
        Set<Punkt> punkty = Set.of(
            new Punkt(1, 1),
            new Punkt(2, 2),
            new Punkt(1, 1)  // Duplikat - zostanie zignorowany
        );
        System.out.println("Unikalne punkty: " + punkty.size());  // 2
    }
}
```

**Rekordy z walidacją:**

```java
public class RekordzWalidacja {
    // Rekord z compact constructor
    public record Email(String adres) {
        public Email {  // Compact constructor
            if (adres == null || !adres.contains("@")) {
                throw new IllegalArgumentException("Nieprawidłowy email: " + adres);
            }
            // adres jest automatycznie przypisywany do pola
        }
    }
    
    // Rekord z normalizacją danych
    public record Imie(String wartosc) {
        public Imie {
            if (wartosc == null || wartosc.trim().isEmpty()) {
                throw new IllegalArgumentException("Imię nie może być puste");
            }
            // Normalizacja - pierwsza litera wielka, reszta małe
            wartosc = wartosc.trim().toLowerCase();
            wartosc = Character.toUpperCase(wartosc.charAt(0)) + wartosc.substring(1);
        }
    }
    
    // Rekord z zakresem wartości
    public record Wiek(int lata) {
        public Wiek {
            if (lata < 0 || lata > 150) {
                throw new IllegalArgumentException("Nieprawidłowy wiek: " + lata);
            }
        }
        
        public boolean czyPelnoletni() {
            return lata >= 18;
        }
        
        public String kategoria() {
            if (lata < 13) return "dziecko";
            if (lata < 18) return "nastolatek";
            if (lata < 65) return "dorosły";
            return "senior";
        }
    }
    
    public static void main(String[] args) {
        try {
            Email email = new Email("anna@example.com");
            System.out.println("Email: " + email.adres());
            
            Imie imie = new Imie("  ANNA  ");
            System.out.println("Imię: " + imie.wartosc());  // Anna
            
            Wiek wiek = new Wiek(25);
            System.out.println("Wiek: " + wiek.lata());
            System.out.println("Pełnoletni: " + wiek.czyPelnoletni());
            System.out.println("Kategoria: " + wiek.kategoria());
            
            // To rzuci wyjątek
            // Email zlyEmail = new Email("nieprawidlowy");
            
        } catch (IllegalArgumentException e) {
            System.out.println("Błąd: " + e.getMessage());
        }
    }
}
```

**Rekordy z dodatkowymi metodami:**

```java
public class RekordzMetodami {
    // Rekord reprezentujący prostokąt
    public record Prostokat(int szerokosc, int wysokosc) {
        // Dodatkowe metody
        public int pole() {
            return szerokosc * wysokosc;
        }
        
        public int obwod() {
            return 2 * (szerokosc + wysokosc);
        }
        
        public boolean czyKwadrat() {
            return szerokosc == wysokosc;
        }
        
        public Prostokat skaluj(double skala) {
            return new Prostokat(
                (int) (szerokosc * skala),
                (int) (wysokosc * skala)
            );
        }
        
        // Statyczne factory methods
        public static Prostokat kwadrat(int bok) {
            return new Prostokat(bok, bok);
        }
        
        public static Prostokat zlotaProporja(int szerokosc) {
            return new Prostokat(szerokosc, (int) (szerokosc / 1.618));
        }
    }
    
    // Rekord z nested records
    public record Adres(String ulica, String miasto, String kodPocztowy) {}
    
    public record Osoba(String imie, String nazwisko, Adres adres) {
        public String pelneImie() {
            return imie + " " + nazwisko;
        }
        
        public String miasto() {
            return adres.miasto();
        }
        
        // Builder pattern dla rekordów
        public static class Builder {
            private String imie;
            private String nazwisko;
            private Adres adres;
            
            public Builder imie(String imie) {
                this.imie = imie;
                return this;
            }
            
            public Builder nazwisko(String nazwisko) {
                this.nazwisko = nazwisko;
                return this;
            }
            
            public Builder adres(String ulica, String miasto, String kodPocztowy) {
                this.adres = new Adres(ulica, miasto, kodPocztowy);
                return this;
            }
            
            public Osoba build() {
                return new Osoba(imie, nazwisko, adres);
            }
        }
        
        public static Builder builder() {
            return new Builder();
        }
    }
    
    public static void main(String[] args) {
        // Test prostokąta
        Prostokat prostokat = new Prostokat(10, 5);
        System.out.println("Prostokąt: " + prostokat);
        System.out.println("Pole: " + prostokat.pole());
        System.out.println("Obwód: " + prostokat.obwod());
        System.out.println("Czy kwadrat: " + prostokat.czyKwadrat());
        
        Prostokat kwadrat = Prostokat.kwadrat(8);
        System.out.println("Kwadrat: " + kwadrat);
        System.out.println("Czy kwadrat: " + kwadrat.czyKwadrat());
        
        Prostokat skalowany = prostokat.skaluj(1.5);
        System.out.println("Skalowany: " + skalowany);
        
        // Test osoby z builderem
        Osoba osoba = Osoba.builder()
            .imie("Anna")
            .nazwisko("Kowalska")
            .adres("Marszałkowska 1", "Warszawa", "00-001")
            .build();
        
        System.out.println("Osoba: " + osoba.pelneImie());
        System.out.println("Miasto: " + osoba.miasto());
    }
}
```

**Rekordy w praktycznych zastosowaniach:**

```java
public class PraktyczneRekordy {
    // DTO dla API
    public record UserDto(String id, String name, String email, boolean active) {}
    
    public record CreateUserRequest(String name, String email) {}
    
    public record ApiResponse<T>(boolean success, T data, String message) {
        public static <T> ApiResponse<T> success(T data) {
            return new ApiResponse<>(true, data, null);
        }
        
        public static <T> ApiResponse<T> error(String message) {
            return new ApiResponse<>(false, null, message);
        }
    }
    
    // Configuration records
    public record DatabaseConfig(String host, int port, String database, String username) {}
    
    public record ServerConfig(int port, String host, DatabaseConfig database) {}
    
    // Event records
    public record UserCreatedEvent(String userId, String name, String email, long timestamp) {
        public UserCreatedEvent(String userId, String name, String email) {
            this(userId, name, email, System.currentTimeMillis());
        }
    }
    
    public record UserUpdatedEvent(String userId, String field, String oldValue, String newValue, long timestamp) {}
    
    // Result/Error handling
    public record ValidationError(String field, String message) {}
    
    public record ValidationResult(boolean valid, List<ValidationError> errors) {
        public static ValidationResult success() {
            return new ValidationResult(true, List.of());
        }
        
        public static ValidationResult failure(List<ValidationError> errors) {
            return new ValidationResult(false, errors);
        }
        
        public static ValidationResult failure(String field, String message) {
            return new ValidationResult(false, List.of(new ValidationError(field, message)));
        }
    }
    
    // Tuple-like records
    public record Pair<T, U>(T first, U second) {}
    
    public record Triple<T, U, V>(T first, U second, V third) {}
    
    public static void main(String[] args) {
        // Test API response
        ApiResponse<UserDto> response = ApiResponse.success(
            new UserDto("1", "Anna", "anna@example.com", true)
        );
        System.out.println("Response: " + response);
        
        // Test konfiguracji
        DatabaseConfig dbConfig = new DatabaseConfig("localhost", 5432, "myapp", "user");
        ServerConfig serverConfig = new ServerConfig(8080, "0.0.0.0", dbConfig);
        System.out.println("Server config: " + serverConfig);
        
        // Test eventów
        UserCreatedEvent event = new UserCreatedEvent("user123", "Anna", "anna@example.com");
        System.out.println("Event: " + event);
        
        // Test walidacji
        ValidationResult result = ValidationResult.failure("email", "Nieprawidłowy format email");
        System.out.println("Validation: " + result);
        
        // Test tuple
        Pair<String, Integer> pair = new Pair<>("Anna", 25);
        System.out.println("Para: " + pair);
        
        Triple<String, String, Integer> triple = new Triple<>("Anna", "Kowalska", 25);
        System.out.println("Trójka: " + triple);
    }
}
```

#### Ograniczenia rekordów

```java
public class OgraniczeniaRekordow {
    // Rekordy są zawsze final - nie można dziedziczyć
    // public record BaseRecord() {}
    // public record ExtendedRecord() extends BaseRecord {}  // Błąd!
    
    // Rekordy nie mogą dziedziczyć z innych klas (tylko Object)
    // public record MyRecord() extends SomeClass {}  // Błąd!
    
    // Ale mogą implementować interfejsy
    public interface Drawable {
        void draw();
    }
    
    public record Circle(int radius) implements Drawable {
        @Override
        public void draw() {
            System.out.println("Rysowanie koła o promieniu " + radius);
        }
    }
    
    // Wszystkie pola są final - nie można ich modyfikować
    public record MutableRecord(List<String> items) {
        // Lista jest final, ale jej zawartość można modyfikować!
        public void addItem(String item) {
            items.add(item);  // To działa, ale łamie immutability
        }
        
        // Lepsze podejście - defensive copy
        public MutableRecord(List<String> items) {
            this.items = List.copyOf(items);  // Immutable copy
        }
        
        public MutableRecord withNewItem(String item) {
            List<String> newItems = new ArrayList<>(items);
            newItems.add(item);
            return new MutableRecord(newItems);
        }
    }
    
    public static void main(String[] args) {
        Circle circle = new Circle(5);
        circle.draw();
        
        // Test immutable list
        MutableRecord record = new MutableRecord(List.of("item1", "item2"));
        MutableRecord newRecord = record.withNewItem("item3");
        
        System.out.println("Original: " + record.items());
        System.out.println("New: " + newRecord.items());
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Używaj rekordów** dla immutable data classes
- **Compact constructor** do walidacji i normalizacji
- **Defensive copying** dla mutable fields
- **Factory methods** dla czytelności
- **Rekordy idealne** do DTOs, value objects, konfiguracji

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz rekord `Money` z walidacją i operacjami matematycznymi.

**Zadanie 2:** Zaprojektuj system eventów używając rekordów.

**Zadanie 3:** Zaimplementuj immutable `Person` record z builderem.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jakie metody automatycznie generuje kompilator dla rekordów?
2. Czym różni się compact constructor od zwykłego konstruktora?
3. Dlaczego rekordy są zawsze immutable?

---

#### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Rekordy to nie tylko syntactic sugar - to przemyślana implementacja value objects z zaawansowanymi możliwościami optymalizacji i integracji z ekosystemem Java. Przyjrzyjmy się wewnętrznym mechanizmom i zaawansowanym wzorcom użycia.

##### Wewnętrzna implementacja rekordów

```java
public class RecordInternals {
    // Jak kompilator widzi rekord
    public record Point(int x, int y) {}
    
    // Jest kompilowane do czegoś podobnego:
    public static final class CompiledPoint extends Record {
        private final int x;
        private final int y;
        
        public CompiledPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        public int x() { return x; }
        public int y() { return y; }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            CompiledPoint point = (CompiledPoint) obj;
            return x == point.x && y == point.y;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
        
        @Override
        public String toString() {
            return "Point[x=" + x + ", y=" + y + "]";
        }
    }
    
    // Performance implications
    public void demonstrateRecordPerformance() {
        // Records mają minimalny overhead w porównaniu do zwykłych klas
        // Główne optymalizacje:
        // 1. Compact object layout
        // 2. Optimized equals/hashCode
        // 3. String concatenation optimization w toString
        
        Point point = new Point(10, 20);
        
        // JVM może optymalizować record allocation
        // Escape analysis może eliminować alokację w niektórych przypadkach
        
        // Benchmark: Record vs Class
        long start = System.nanoTime();
        for (int i = 0; i < 1_000_000; i++) {
            Point p = new Point(i, i * 2);
            int hash = p.hashCode();
        }
        long recordTime = System.nanoTime() - start;
        
        System.out.println("Record creation time: " + recordTime + " ns");
    }
}
```

##### Zaawansowane wzorce z rekordami

```java
public class AdvancedRecordPatterns {
    // Sealed records dla type-safe unions
    public sealed interface Shape permits Circle, Rectangle, Triangle {}
    
    public record Circle(double radius) implements Shape {
        public double area() {
            return Math.PI * radius * radius;
        }
    }
    
    public record Rectangle(double width, double height) implements Shape {
        public double area() {
            return width * height;
        }
    }
    
    public record Triangle(double base, double height) implements Shape {
        public double area() {
            return 0.5 * base * height;
        }
    }
    
    // Pattern matching z records (Java 17+)
    public static double calculateArea(Shape shape) {
        return switch (shape) {
            case Circle(var radius) -> Math.PI * radius * radius;
            case Rectangle(var width, var height) -> width * height;
            case Triangle(var base, var height) -> 0.5 * base * height;
        };
    }
    
    // Recursive records dla tree structures
    public sealed interface Tree<T> permits Leaf, Node {}
    
    public record Leaf<T>(T value) implements Tree<T> {}
    
    public record Node<T>(Tree<T> left, Tree<T> right) implements Tree<T> {}
    
    public static <T> int size(Tree<T> tree) {
        return switch (tree) {
            case Leaf<T> leaf -> 1;
            case Node<T>(var left, var right) -> size(left) + size(right);
        };
    }
    
    public static <T> List<T> inorder(Tree<T> tree) {
        return switch (tree) {
            case Leaf<T>(var value) -> List.of(value);
            case Node<T>(var left, var right) -> {
                List<T> result = new ArrayList<>(inorder(left));
                result.addAll(inorder(right));
                yield result;
            }
        };
    }
    
    // Generic records z constraints
    public record Pair<T extends Comparable<T>>(T first, T second) {
        public T min() {
            return first.compareTo(second) <= 0 ? first : second;
        }
        
        public T max() {
            return first.compareTo(second) >= 0 ? first : second;
        }
        
        public Pair<T> sorted() {
            return first.compareTo(second) <= 0 ? this : new Pair<>(second, first);
        }
    }
    
    // Record-based state machines
    public sealed interface State permits Idle, Running, Paused, Stopped {}
    public record Idle() implements State {}
    public record Running(long startTime) implements State {}
    public record Paused(long pauseTime, long elapsedTime) implements State {}
    public record Stopped(long totalTime) implements State {}
    
    public static class StateMachine {
        private State currentState = new Idle();
        
        public State transition(String event) {
            currentState = switch (currentState) {
                case Idle() -> switch (event) {
                    case "start" -> new Running(System.currentTimeMillis());
                    default -> currentState;
                };
                case Running(var startTime) -> switch (event) {
                    case "pause" -> new Paused(System.currentTimeMillis(), 
                                             System.currentTimeMillis() - startTime);
                    case "stop" -> new Stopped(System.currentTimeMillis() - startTime);
                    default -> currentState;
                };
                case Paused(var pauseTime, var elapsedTime) -> switch (event) {
                    case "resume" -> new Running(System.currentTimeMillis() - elapsedTime);
                    case "stop" -> new Stopped(elapsedTime);
                    default -> currentState;
                };
                case Stopped(var totalTime) -> switch (event) {
                    case "reset" -> new Idle();
                    default -> currentState;
                };
            };
            return currentState;
        }
        
        public State getCurrentState() {
            return currentState;
        }
    }
    
    // Record-based builders
    public record PersonBuilder(
        Optional<String> name,
        Optional<String> email,
        Optional<Integer> age,
        Optional<String> city
    ) {
        public PersonBuilder() {
            this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
        }
        
        public PersonBuilder withName(String name) {
            return new PersonBuilder(Optional.of(name), email, age, city);
        }
        
        public PersonBuilder withEmail(String email) {
            return new PersonBuilder(name, Optional.of(email), age, city);
        }
        
        public PersonBuilder withAge(int age) {
            return new PersonBuilder(name, email, Optional.of(age), city);
        }
        
        public PersonBuilder withCity(String city) {
            return new PersonBuilder(name, email, age, Optional.of(city));
        }
        
        public Person build() {
            return new Person(
                name.orElseThrow(() -> new IllegalStateException("Name is required")),
                email.orElse(""),
                age.orElse(0),
                city.orElse("")
            );
        }
    }
    
    public record Person(String name, String email, int age, String city) {}
}
```

##### Serialization i persistence

```java
public class RecordSerialization {
    // Records z Jackson
    public record UserJson(
        @JsonProperty("user_id") String id,
        @JsonProperty("full_name") String name,
        @JsonProperty("email_address") String email,
        @JsonProperty("is_active") boolean active
    ) {}
    
    // Records z JPA (wymaga dodatkowych adnotacji)
    @Entity
    @Table(name = "users")
    public record UserEntity(
        @Id String id,
        @Column(name = "full_name") String name,
        @Column(name = "email") String email,
        @Column(name = "active") boolean active
    ) {}
    
    // Custom serialization
    public record SerializableRecord(String data, int value) implements Serializable {
        private static final long serialVersionUID = 1L;
        
        // Custom serialization logic jeśli potrzebna
        private void writeObject(ObjectOutputStream out) throws IOException {
            out.defaultWriteObject();
            // Custom logic
        }
        
        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
            in.defaultReadObject();
            // Custom logic
        }
    }
    
    // Record versioning dla backward compatibility
    public record VersionedRecord(
        String data,
        int value,
        @JsonProperty(defaultValue = "1") int version
    ) {
        public VersionedRecord(String data, int value) {
            this(data, value, 1);
        }
        
        // Migration logic
        public static VersionedRecord fromLegacy(LegacyRecord legacy) {
            return new VersionedRecord(legacy.data(), legacy.value(), 1);
        }
    }
    
    public record LegacyRecord(String data, int value) {}
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj immutable event sourcing system używając sealed records i pattern matching.

**Zadanie Zaawansowane 2:** Stwórz type-safe configuration system z record validation i environment variable binding.

**Zadanie Zaawansowane 3:** Zaprojektuj functional data structures (List, Tree) używając recursive records.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak rekordy wpływają na performance w porównaniu do zwykłych klas?
2. Jakie są ograniczenia rekordów w kontekście frameworks (JPA, Spring)?
3. Jak rekordy współpracują z pattern matching i sealed classes?

---

#### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public record Money(BigDecimal amount, String currency) {
    public Money {
        if (amount == null) {
            throw new IllegalArgumentException("Amount cannot be null");
        }
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Amount cannot be negative");
        }
        if (currency == null || currency.trim().isEmpty()) {
            throw new IllegalArgumentException("Currency cannot be empty");
        }
        currency = currency.toUpperCase().trim();
    }
    
    public Money add(Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot add different currencies");
        }
        return new Money(amount.add(other.amount), currency);
    }
    
    public Money subtract(Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot subtract different currencies");
        }
        return new Money(amount.subtract(other.amount), currency);
    }
    
    public Money multiply(BigDecimal factor) {
        return new Money(amount.multiply(factor), currency);
    }
    
    public boolean isZero() {
        return amount.compareTo(BigDecimal.ZERO) == 0;
    }
    
    public static Money zero(String currency) {
        return new Money(BigDecimal.ZERO, currency);
    }
    
    public static Money of(double amount, String currency) {
        return new Money(BigDecimal.valueOf(amount), currency);
    }
}
```

**Zadanie 2:**
```java
public sealed interface Event permits UserEvent, OrderEvent, SystemEvent {}

public sealed interface UserEvent extends Event permits UserCreated, UserUpdated, UserDeleted {}
public record UserCreated(String userId, String name, String email, long timestamp) implements UserEvent {}
public record UserUpdated(String userId, String field, String oldValue, String newValue, long timestamp) implements UserEvent {}
public record UserDeleted(String userId, long timestamp) implements UserEvent {}

public sealed interface OrderEvent extends Event permits OrderCreated, OrderShipped, OrderCancelled {}
public record OrderCreated(String orderId, String userId, BigDecimal amount, long timestamp) implements OrderEvent {}
public record OrderShipped(String orderId, String trackingNumber, long timestamp) implements OrderEvent {}
public record OrderCancelled(String orderId, String reason, long timestamp) implements OrderEvent {}

public sealed interface SystemEvent extends Event permits SystemStarted, SystemStopped {}
public record SystemStarted(String version, long timestamp) implements SystemEvent {}
public record SystemStopped(String reason, long timestamp) implements SystemEvent {}

public class EventProcessor {
    public void process(Event event) {
        switch (event) {
            case UserCreated(var userId, var name, var email, var timestamp) ->
                System.out.println("User created: " + name + " (" + email + ")");
            case UserUpdated(var userId, var field, var oldValue, var newValue, var timestamp) ->
                System.out.println("User " + userId + " updated: " + field + " = " + newValue);
            case OrderCreated(var orderId, var userId, var amount, var timestamp) ->
                System.out.println("Order " + orderId + " created for " + amount);
            // ... inne przypadki
        }
    }
}
```

**Zadanie 3:**
```java
public record Person(String firstName, String lastName, String email, int age, String city) {
    public Person {
        if (firstName == null || firstName.trim().isEmpty()) {
            throw new IllegalArgumentException("First name is required");
        }
        if (lastName == null || lastName.trim().isEmpty()) {
            throw new IllegalArgumentException("Last name is required");
        }
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException("Invalid age: " + age);
        }
        
        firstName = firstName.trim();
        lastName = lastName.trim();
        email = email != null ? email.trim() : "";
        city = city != null ? city.trim() : "";
    }
    
    public String fullName() {
        return firstName + " " + lastName;
    }
    
    public static class Builder {
        private String firstName;
        private String lastName;
        private String email = "";
        private int age = 0;
        private String city = "";
        
        public Builder firstName(String firstName) {
            this.firstName = firstName;
            return this;
        }
        
        public Builder lastName(String lastName) {
            this.lastName = lastName;
            return this;
        }
        
        public Builder email(String email) {
            this.email = email;
            return this;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder city(String city) {
            this.city = city;
            return this;
        }
        
        public Person build() {
            return new Person(firstName, lastName, email, age, city);
        }
    }
    
    public static Builder builder() {
        return new Builder();
    }
}
```

**Pytania kontrolne:**
1. Konstruktor, gettery (bez "get" prefix), equals(), hashCode(), toString().
2. Compact constructor pozwala na walidację i modyfikację parametrów przed przypisaniem do pól.
3. Wszystkie pola są final, nie ma setterów, co gwarantuje immutability.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public sealed interface DomainEvent permits UserEvent, OrderEvent, PaymentEvent {}

public sealed interface UserEvent extends DomainEvent permits UserRegistered, UserActivated, UserDeactivated {}
public record UserRegistered(String userId, String email, String name, Instant timestamp) implements UserEvent {}
public record UserActivated(String userId, Instant timestamp) implements UserEvent {}
public record UserDeactivated(String userId, String reason, Instant timestamp) implements UserEvent {}

public sealed interface OrderEvent extends DomainEvent permits OrderPlaced, OrderShipped, OrderDelivered {}
public record OrderPlaced(String orderId, String userId, List<OrderItem> items, BigDecimal total, Instant timestamp) implements OrderEvent {}
public record OrderShipped(String orderId, String trackingNumber, Instant timestamp) implements OrderEvent {}
public record OrderDelivered(String orderId, Instant timestamp) implements OrderEvent {}

public record OrderItem(String productId, int quantity, BigDecimal price) {}

public sealed interface PaymentEvent extends DomainEvent permits PaymentProcessed, PaymentFailed {}
public record PaymentProcessed(String paymentId, String orderId, BigDecimal amount, Instant timestamp) implements PaymentEvent {}
public record PaymentFailed(String paymentId, String orderId, String reason, Instant timestamp) implements PaymentEvent {}

public class EventStore {
    private final List<DomainEvent> events = new ArrayList<>();
    
    public void append(DomainEvent event) {
        events.add(event);
    }
    
    public List<DomainEvent> getEvents() {
        return List.copyOf(events);
    }
    
    public <T extends DomainEvent> List<T> getEventsOfType(Class<T> type) {
        return events.stream()
                    .filter(type::isInstance)
                    .map(type::cast)
                    .collect(Collectors.toList());
    }
}

public class EventProcessor {
    public void process(DomainEvent event) {
        switch (event) {
            case UserRegistered(var userId, var email, var name, var timestamp) -> {
                System.out.println("Processing user registration: " + name);
                // Send welcome email, create user profile, etc.
            }
            case OrderPlaced(var orderId, var userId, var items, var total, var timestamp) -> {
                System.out.println("Processing order: " + orderId + " for " + total);
                // Reserve inventory, process payment, etc.
            }
            case PaymentProcessed(var paymentId, var orderId, var amount, var timestamp) -> {
                System.out.println("Payment processed: " + paymentId + " for " + amount);
                // Update order status, send confirmation, etc.
            }
            // ... inne przypadki
        }
    }
}
```

**Pytania kontrolne:**
1. Records mają minimalny overhead, kompilator generuje zoptymalizowane equals/hashCode, JVM może optymalizować allocation przez escape analysis.
2. JPA wymaga no-arg constructor (można użyć @Entity z records od Hibernate 6), Spring może mieć problemy z dependency injection.
3. Records doskonale współpracują z pattern matching i sealed classes, umożliwiając type-safe exhaustive matching.

---

### 📚 Koniec drugiej sekcji!

*Gratulacje! Ukończyłaś drugą sekcję przewodnika - "Klasy i struktury danych". Poznałaś enumy, kolekcje, Optional i rekordy - czyli wszystkie nowoczesne narzędzia do organizowania i manipulowania danymi w Javie. To potężny arsenał, który pozwoli Ci pisać czysty, bezpieczny i wydajny kod.*

*W następnej sekcji zagłębimy się w obiektowość i zaawansowane typy - dziedziczenie, polimorfizm, interfejsy, generyki i adnotacje. To będzie kolejny krok w Twojej podróży do mistrzostwa w Javie!*

---

*💡 Pamiętaj: Nowoczesna Java to nie tylko składnia - to nowe sposoby myślenia o danych. Enumy, Optional i rekordy to narzędzia, które czynią kod bardziej bezpiecznym i czytelnym!*

