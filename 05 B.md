### B. Diagnostyka, profilowanie i optymalizacja

## 38. Profilowanie i debugging

*Cze≈õƒá! Dzi≈õ nauczysz siƒô byƒá detektywem kodu - znajdowaƒá problemy, analizowaƒá performance i rozwiƒÖzywaƒá zagadki, kt√≥re Twoja aplikacja przed TobƒÖ ukrywa!*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Podstawy debugowania

```java
public class DebuggingBasics {
    public static void demonstrateDebugging() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Punkt przerwania tutaj - sprawd≈∫ warto≈õci
        int sum = 0;
        for (int number : numbers) {
            sum += number; // Krok po kroku przez debugger
            System.out.println("Current sum: " + sum); // Logging dla debugowania
        }
        
        // Asercje dla sprawdzenia za≈Ço≈ºe≈Ñ
        assert sum == 15 : "Sum should be 15, but was " + sum;
        
        System.out.println("Final sum: " + sum);
    }
    
    // Debugging z exception stack trace
    public static void demonstrateStackTrace() {
        try {
            methodA();
        } catch (Exception e) {
            System.err.println("Exception caught:");
            e.printStackTrace(); // Poka≈ºe pe≈Çny stack trace
            
            // Analiza stack trace programowo
            StackTraceElement[] stackTrace = e.getStackTrace();
            for (StackTraceElement element : stackTrace) {
                System.out.printf("  at %s.%s(%s:%d)%n",
                    element.getClassName(),
                    element.getMethodName(),
                    element.getFileName(),
                    element.getLineNumber());
            }
        }
    }
    
    private static void methodA() {
        methodB();
    }
    
    private static void methodB() {
        methodC();
    }
    
    private static void methodC() {
        throw new RuntimeException("Something went wrong in methodC");
    }
}
```

#### Podstawowe profilowanie

```java
public class BasicProfiling {
    public static void measureExecutionTime() {
        // Prosty pomiar czasu
        long startTime = System.nanoTime();
        
        // Operacja do zmierzenia
        performExpensiveOperation();
        
        long endTime = System.nanoTime();
        long duration = endTime - startTime;
        
        System.out.printf("Operation took: %.2f ms%n", duration / 1_000_000.0);
    }
    
    public static void measureMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        
        // Pomiar przed operacjƒÖ
        runtime.gc(); // Sugestia GC
        long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
        
        // Operacja zu≈ºywajƒÖca pamiƒôƒá
        List<String> data = new ArrayList<>();
        for (int i = 0; i < 100000; i++) {
            data.add("String " + i);
        }
        
        // Pomiar po operacji
        long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
        long memoryUsed = memoryAfter - memoryBefore;
        
        System.out.printf("Memory used: %d KB%n", memoryUsed / 1024);
    }
    
    private static void performExpensiveOperation() {
        // Symulacja kosztownej operacji
        for (int i = 0; i < 1_000_000; i++) {
            Math.sqrt(i);
        }
    }
}
```

#### üí° Wskaz√≥wki dla Juniorek
- U≈ºywaj debuggera zamiast System.out.println
- Analizuj stack trace od g√≥ry
- Mierz performance przed optymalizacjƒÖ
- U≈ºywaj assert do sprawdzania za≈Ço≈ºe≈Ñ

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### Zaawansowane profilowanie z JMX

```java
public class AdvancedProfiling {
    
    // Custom MBean dla monitoringu
    public interface ApplicationMetricsMBean {
        long getRequestCount();
        double getAverageResponseTime();
        long getErrorCount();
        void resetMetrics();
    }
    
    public static class ApplicationMetrics implements ApplicationMetricsMBean {
        private final AtomicLong requestCount = new AtomicLong(0);
        private final AtomicLong totalResponseTime = new AtomicLong(0);
        private final AtomicLong errorCount = new AtomicLong(0);
        
        public void recordRequest(long responseTime) {
            requestCount.incrementAndGet();
            totalResponseTime.addAndGet(responseTime);
        }
        
        public void recordError() {
            errorCount.incrementAndGet();
        }
        
        @Override
        public long getRequestCount() {
            return requestCount.get();
        }
        
        @Override
        public double getAverageResponseTime() {
            long requests = requestCount.get();
            return requests > 0 ? (double) totalResponseTime.get() / requests : 0;
        }
        
        @Override
        public long getErrorCount() {
            return errorCount.get();
        }
        
        @Override
        public void resetMetrics() {
            requestCount.set(0);
            totalResponseTime.set(0);
            errorCount.set(0);
        }
    }
    
    // Performance monitoring
    public static class PerformanceMonitor {
        private static final ApplicationMetrics metrics = new ApplicationMetrics();
        
        static {
            // Rejestracja MBean
            try {
                MBeanServer server = ManagementFactory.getPlatformMBeanServer();
                ObjectName name = new ObjectName("com.example:type=ApplicationMetrics");
                server.registerMBean(metrics, name);
            } catch (Exception e) {
                System.err.println("Failed to register MBean: " + e.getMessage());
            }
        }
        
        public static <T> T measureOperation(String operationName, Supplier<T> operation) {
            long startTime = System.nanoTime();
            
            try {
                T result = operation.get();
                long duration = System.nanoTime() - startTime;
                metrics.recordRequest(duration / 1_000_000); // Convert to ms
                
                System.out.printf("%s completed in %.2f ms%n", 
                    operationName, duration / 1_000_000.0);
                
                return result;
            } catch (Exception e) {
                metrics.recordError();
                System.err.printf("%s failed: %s%n", operationName, e.getMessage());
                throw e;
            }
        }
        
        public static void printSystemMetrics() {
            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
            MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
            
            ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
            
            System.out.println("=== System Metrics ===");
            System.out.printf("Heap: %d MB used / %d MB max%n",
                heapUsage.getUsed() / 1024 / 1024,
                heapUsage.getMax() / 1024 / 1024);
            System.out.printf("Threads: %d active, %d peak%n",
                threadBean.getThreadCount(),
                threadBean.getPeakThreadCount());
            System.out.printf("Application: %d requests, %.2f ms avg, %d errors%n",
                metrics.getRequestCount(),
                metrics.getAverageResponseTime(),
                metrics.getErrorCount());
        }
    }
    
    // Memory leak detection
    public static class MemoryLeakDetector {
        private static final Map<String, Long> memorySnapshots = new HashMap<>();
        
        public static void takeSnapshot(String name) {
            Runtime runtime = Runtime.getRuntime();
            runtime.gc(); // Force GC before measurement
            
            long usedMemory = runtime.totalMemory() - runtime.freeMemory();
            memorySnapshots.put(name, usedMemory);
            
            System.out.printf("Memory snapshot '%s': %d KB%n", name, usedMemory / 1024);
        }
        
        public static void compareSnapshots(String snapshot1, String snapshot2) {
            Long memory1 = memorySnapshots.get(snapshot1);
            Long memory2 = memorySnapshots.get(snapshot2);
            
            if (memory1 != null && memory2 != null) {
                long diff = memory2 - memory1;
                System.out.printf("Memory difference (%s -> %s): %+d KB%n",
                    snapshot1, snapshot2, diff / 1024);
                
                if (diff > 1024 * 1024) { // More than 1MB increase
                    System.out.println("‚ö†Ô∏è  Potential memory leak detected!");
                }
            }
        }
        
        public static void analyzeHeapDump() {
            // Simplified heap analysis
            Runtime runtime = Runtime.getRuntime();
            
            System.out.println("=== Heap Analysis ===");
            System.out.printf("Total memory: %d MB%n", runtime.totalMemory() / 1024 / 1024);
            System.out.printf("Free memory: %d MB%n", runtime.freeMemory() / 1024 / 1024);
            System.out.printf("Used memory: %d MB%n", 
                (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024);
            System.out.printf("Max memory: %d MB%n", runtime.maxMemory() / 1024 / 1024);
            
            // GC statistics
            List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
            for (GarbageCollectorMXBean gcBean : gcBeans) {
                System.out.printf("GC %s: %d collections, %d ms total%n",
                    gcBean.getName(),
                    gcBean.getCollectionCount(),
                    gcBean.getCollectionTime());
            }
        }
    }
    
    public static void main(String[] args) {
        // Demonstracja profilowania
        PerformanceMonitor.measureOperation("Database Query", () -> {
            try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
            return "Query result";
        });
        
        PerformanceMonitor.measureOperation("API Call", () -> {
            try { Thread.sleep(50); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
            return "API response";
        });
        
        PerformanceMonitor.printSystemMetrics();
        
        // Memory leak detection
        MemoryLeakDetector.takeSnapshot("start");
        
        // Symulacja potencjalnego memory leak
        List<byte[]> memoryHog = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            memoryHog.add(new byte[1024]); // 1KB each
        }
        
        MemoryLeakDetector.takeSnapshot("after_allocation");
        MemoryLeakDetector.compareSnapshots("start", "after_allocation");
        MemoryLeakDetector.analyzeHeapDump();
    }
}
```

---

## 39. Wzorce projektowe ‚Äî wprowadzenie

*Wzorce projektowe to jak przepisy kulinarne - sprawdzone rozwiƒÖzania na typowe problemy. Nie musisz wymy≈õlaƒá ko≈Ça na nowo!*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Podstawowe wzorce

```java
public class DesignPatternsBasics {
    
    // Singleton - jedna instancja w ca≈Çej aplikacji
    public static class DatabaseConnection {
        private static DatabaseConnection instance;
        private String connectionString;
        
        private DatabaseConnection() {
            connectionString = "jdbc:mysql://localhost:3306/mydb";
        }
        
        public static synchronized DatabaseConnection getInstance() {
            if (instance == null) {
                instance = new DatabaseConnection();
            }
            return instance;
        }
        
        public void connect() {
            System.out.println("Connecting to: " + connectionString);
        }
    }
    
    // Factory - tworzenie obiekt√≥w bez okre≈õlania konkretnej klasy
    public interface Animal {
        void makeSound();
    }
    
    public static class Dog implements Animal {
        @Override
        public void makeSound() {
            System.out.println("Woof!");
        }
    }
    
    public static class Cat implements Animal {
        @Override
        public void makeSound() {
            System.out.println("Meow!");
        }
    }
    
    public static class AnimalFactory {
        public static Animal createAnimal(String type) {
            switch (type.toLowerCase()) {
                case "dog": return new Dog();
                case "cat": return new Cat();
                default: throw new IllegalArgumentException("Unknown animal type: " + type);
            }
        }
    }
    
    // Observer - powiadamianie o zmianach
    public interface Observer {
        void update(String message);
    }
    
    public static class NewsAgency {
        private List<Observer> observers = new ArrayList<>();
        private String news;
        
        public void addObserver(Observer observer) {
            observers.add(observer);
        }
        
        public void removeObserver(Observer observer) {
            observers.remove(observer);
        }
        
        public void setNews(String news) {
            this.news = news;
            notifyObservers();
        }
        
        private void notifyObservers() {
            for (Observer observer : observers) {
                observer.update(news);
            }
        }
    }
    
    public static class NewsChannel implements Observer {
        private String name;
        
        public NewsChannel(String name) {
            this.name = name;
        }
        
        @Override
        public void update(String news) {
            System.out.println(name + " received news: " + news);
        }
    }
    
    public static void main(String[] args) {
        // Singleton demo
        DatabaseConnection db1 = DatabaseConnection.getInstance();
        DatabaseConnection db2 = DatabaseConnection.getInstance();
        System.out.println("Same instance: " + (db1 == db2));
        
        // Factory demo
        Animal dog = AnimalFactory.createAnimal("dog");
        Animal cat = AnimalFactory.createAnimal("cat");
        dog.makeSound();
        cat.makeSound();
        
        // Observer demo
        NewsAgency agency = new NewsAgency();
        NewsChannel cnn = new NewsChannel("CNN");
        NewsChannel bbc = new NewsChannel("BBC");
        
        agency.addObserver(cnn);
        agency.addObserver(bbc);
        agency.setNews("Breaking: Java 21 released!");
    }
}
```

#### üí° Wskaz√≥wki dla Juniorek
- Nie u≈ºywaj wzorc√≥w na si≈Çƒô
- Zrozum problem przed zastosowaniem wzorca
- Singleton czƒôsto mo≈ºna zastƒÖpiƒá dependency injection
- Observer pattern jest wbudowany w Java (Observable/Observer)

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### Zaawansowane wzorce

```java
public class AdvancedDesignPatterns {
    
    // Command Pattern z undo/redo
    public interface Command {
        void execute();
        void undo();
    }
    
    public static class TextEditor {
        private StringBuilder content = new StringBuilder();
        private Stack<Command> history = new Stack<>();
        private Stack<Command> redoStack = new Stack<>();
        
        public void executeCommand(Command command) {
            command.execute();
            history.push(command);
            redoStack.clear(); // Clear redo stack on new command
        }
        
        public void undo() {
            if (!history.isEmpty()) {
                Command command = history.pop();
                command.undo();
                redoStack.push(command);
            }
        }
        
        public void redo() {
            if (!redoStack.isEmpty()) {
                Command command = redoStack.pop();
                command.execute();
                history.push(command);
            }
        }
        
        public void insertText(int position, String text) {
            content.insert(position, text);
        }
        
        public void deleteText(int start, int end) {
            content.delete(start, end);
        }
        
        public String getContent() {
            return content.toString();
        }
    }
    
    public static class InsertCommand implements Command {
        private TextEditor editor;
        private int position;
        private String text;
        
        public InsertCommand(TextEditor editor, int position, String text) {
            this.editor = editor;
            this.position = position;
            this.text = text;
        }
        
        @Override
        public void execute() {
            editor.insertText(position, text);
        }
        
        @Override
        public void undo() {
            editor.deleteText(position, position + text.length());
        }
    }
    
    // Strategy Pattern with functional interfaces
    public static class PaymentProcessor {
        public interface PaymentStrategy {
            boolean processPayment(double amount);
        }
        
        private PaymentStrategy strategy;
        
        public PaymentProcessor(PaymentStrategy strategy) {
            this.strategy = strategy;
        }
        
        public void setStrategy(PaymentStrategy strategy) {
            this.strategy = strategy;
        }
        
        public boolean processPayment(double amount) {
            return strategy.processPayment(amount);
        }
    }
    
    // Builder Pattern with fluent interface
    public static class HttpRequest {
        private final String url;
        private final String method;
        private final Map<String, String> headers;
        private final String body;
        private final int timeout;
        
        private HttpRequest(Builder builder) {
            this.url = builder.url;
            this.method = builder.method;
            this.headers = new HashMap<>(builder.headers);
            this.body = builder.body;
            this.timeout = builder.timeout;
        }
        
        public static class Builder {
            private String url;
            private String method = "GET";
            private Map<String, String> headers = new HashMap<>();
            private String body;
            private int timeout = 30000;
            
            public Builder url(String url) {
                this.url = url;
                return this;
            }
            
            public Builder method(String method) {
                this.method = method;
                return this;
            }
            
            public Builder header(String name, String value) {
                this.headers.put(name, value);
                return this;
            }
            
            public Builder body(String body) {
                this.body = body;
                return this;
            }
            
            public Builder timeout(int timeout) {
                this.timeout = timeout;
                return this;
            }
            
            public HttpRequest build() {
                if (url == null) {
                    throw new IllegalStateException("URL is required");
                }
                return new HttpRequest(this);
            }
        }
        
        @Override
        public String toString() {
            return String.format("HttpRequest{url='%s', method='%s', headers=%s, timeout=%d}",
                url, method, headers, timeout);
        }
    }
    
    // Decorator Pattern
    public interface Coffee {
        double getCost();
        String getDescription();
    }
    
    public static class SimpleCoffee implements Coffee {
        @Override
        public double getCost() {
            return 2.0;
        }
        
        @Override
        public String getDescription() {
            return "Simple coffee";
        }
    }
    
    public abstract static class CoffeeDecorator implements Coffee {
        protected Coffee coffee;
        
        public CoffeeDecorator(Coffee coffee) {
            this.coffee = coffee;
        }
    }
    
    public static class MilkDecorator extends CoffeeDecorator {
        public MilkDecorator(Coffee coffee) {
            super(coffee);
        }
        
        @Override
        public double getCost() {
            return coffee.getCost() + 0.5;
        }
        
        @Override
        public String getDescription() {
            return coffee.getDescription() + ", milk";
        }
    }
    
    public static class SugarDecorator extends CoffeeDecorator {
        public SugarDecorator(Coffee coffee) {
            super(coffee);
        }
        
        @Override
        public double getCost() {
            return coffee.getCost() + 0.2;
        }
        
        @Override
        public String getDescription() {
            return coffee.getDescription() + ", sugar";
        }
    }
    
    public static void main(String[] args) {
        // Command pattern demo
        TextEditor editor = new TextEditor();
        editor.executeCommand(new InsertCommand(editor, 0, "Hello "));
        editor.executeCommand(new InsertCommand(editor, 6, "World!"));
        System.out.println("Content: " + editor.getContent());
        
        editor.undo();
        System.out.println("After undo: " + editor.getContent());
        
        editor.redo();
        System.out.println("After redo: " + editor.getContent());
        
        // Strategy pattern demo
        PaymentProcessor processor = new PaymentProcessor(amount -> {
            System.out.println("Processing credit card payment: $" + amount);
            return true;
        });
        
        processor.processPayment(100.0);
        
        processor.setStrategy(amount -> {
            System.out.println("Processing PayPal payment: $" + amount);
            return amount <= 1000; // PayPal limit
        });
        
        processor.processPayment(500.0);
        
        // Builder pattern demo
        HttpRequest request = new HttpRequest.Builder()
            .url("https://api.example.com/users")
            .method("POST")
            .header("Content-Type", "application/json")
            .header("Authorization", "Bearer token123")
            .body("{\"name\":\"John\",\"email\":\"john@example.com\"}")
            .timeout(5000)
            .build();
        
        System.out.println("Request: " + request);
        
        // Decorator pattern demo
        Coffee coffee = new SimpleCoffee();
        System.out.println(coffee.getDescription() + " - $" + coffee.getCost());
        
        coffee = new MilkDecorator(coffee);
        System.out.println(coffee.getDescription() + " - $" + coffee.getCost());
        
        coffee = new SugarDecorator(coffee);
        System.out.println(coffee.getDescription() + " - $" + coffee.getCost());
    }
}
```

---

## 40. Diagnostyka, profilowanie i optymalizacja JVM

*To ostatni rozdzia≈Ç naszej podr√≥≈ºy! Dzi≈õ nauczysz siƒô byƒá mechanikiem JVM - diagnozowaƒá problemy, optymalizowaƒá performance i wyciƒÖgaƒá z Javy maksimum mo≈ºliwo≈õci!*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Podstawowe narzƒôdzia JVM

```java
public class JVMDiagnosticsBasics {
    public static void demonstrateBasicDiagnostics() {
        // Informacje o JVM
        System.out.println("=== JVM Information ===");
        System.out.println("Java version: " + System.getProperty("java.version"));
        System.out.println("JVM vendor: " + System.getProperty("java.vendor"));
        System.out.println("JVM name: " + System.getProperty("java.vm.name"));
        System.out.println("OS: " + System.getProperty("os.name"));
        
        // Runtime informacje
        Runtime runtime = Runtime.getRuntime();
        System.out.println("\n=== Runtime Information ===");
        System.out.println("Available processors: " + runtime.availableProcessors());
        System.out.println("Total memory: " + runtime.totalMemory() / 1024 / 1024 + " MB");
        System.out.println("Free memory: " + runtime.freeMemory() / 1024 / 1024 + " MB");
        System.out.println("Max memory: " + runtime.maxMemory() / 1024 / 1024 + " MB");
        
        // Thread informacje
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        System.out.println("\n=== Thread Information ===");
        System.out.println("Current threads: " + threadBean.getThreadCount());
        System.out.println("Peak threads: " + threadBean.getPeakThreadCount());
        System.out.println("Total started threads: " + threadBean.getTotalStartedThreadCount());
        
        // GC informacje
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        System.out.println("\n=== Garbage Collection ===");
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            System.out.printf("%s: %d collections, %d ms total%n",
                gcBean.getName(),
                gcBean.getCollectionCount(),
                gcBean.getCollectionTime());
        }
    }
    
    // Prosty benchmark
    public static void simpleBenchmark() {
        System.out.println("\n=== Simple Benchmark ===");
        
        // Test 1: ArrayList vs LinkedList
        benchmarkListOperations();
        
        // Test 2: String concatenation
        benchmarkStringOperations();
        
        // Test 3: Loop optimizations
        benchmarkLoopOptimizations();
    }
    
    private static void benchmarkListOperations() {
        int size = 100000;
        
        // ArrayList benchmark
        long start = System.nanoTime();
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        long arrayListTime = System.nanoTime() - start;
        
        // LinkedList benchmark
        start = System.nanoTime();
        List<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < size; i++) {
            linkedList.add(i);
        }
        long linkedListTime = System.nanoTime() - start;
        
        System.out.printf("ArrayList add: %.2f ms%n", arrayListTime / 1_000_000.0);
        System.out.printf("LinkedList add: %.2f ms%n", linkedListTime / 1_000_000.0);
    }
    
    private static void benchmarkStringOperations() {
        int iterations = 10000;
        
        // String concatenation
        long start = System.nanoTime();
        String result = "";
        for (int i = 0; i < iterations; i++) {
            result += "a";
        }
        long stringTime = System.nanoTime() - start;
        
        // StringBuilder
        start = System.nanoTime();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < iterations; i++) {
            sb.append("a");
        }
        String sbResult = sb.toString();
        long sbTime = System.nanoTime() - start;
        
        System.out.printf("String concatenation: %.2f ms%n", stringTime / 1_000_000.0);
        System.out.printf("StringBuilder: %.2f ms%n", sbTime / 1_000_000.0);
    }
    
    private static void benchmarkLoopOptimizations() {
        int[] array = new int[1000000];
        for (int i = 0; i < array.length; i++) {
            array[i] = i;
        }
        
        // Enhanced for loop
        long start = System.nanoTime();
        long sum1 = 0;
        for (int value : array) {
            sum1 += value;
        }
        long enhancedForTime = System.nanoTime() - start;
        
        // Traditional for loop
        start = System.nanoTime();
        long sum2 = 0;
        for (int i = 0; i < array.length; i++) {
            sum2 += array[i];
        }
        long traditionalForTime = System.nanoTime() - start;
        
        System.out.printf("Enhanced for loop: %.2f ms%n", enhancedForTime / 1_000_000.0);
        System.out.printf("Traditional for loop: %.2f ms%n", traditionalForTime / 1_000_000.0);
    }
    
    public static void main(String[] args) {
        demonstrateBasicDiagnostics();
        simpleBenchmark();
    }
}
```

#### üí° Wskaz√≥wki dla Juniorek
- Monitoruj aplikacjƒô w ≈õrodowisku produkcyjnym
- U≈ºywaj narzƒôdzi jak VisualVM, JConsole
- Mierz przed optymalizacjƒÖ
- Nie optymalizuj przedwcze≈õnie

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### Zaawansowana diagnostyka i tuning

```java
public class AdvancedJVMTuning {
    
    // JVM flags analyzer
    public static class JVMFlagsAnalyzer {
        public static void analyzeCurrentFlags() {
            System.out.println("=== JVM Flags Analysis ===");
            
            RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
            List<String> jvmArgs = runtimeBean.getInputArguments();
            
            System.out.println("Current JVM arguments:");
            for (String arg : jvmArgs) {
                System.out.println("  " + arg);
                analyzeFlag(arg);
            }
        }
        
        private static void analyzeFlag(String flag) {
            if (flag.startsWith("-Xms")) {
                System.out.println("    ‚Üí Initial heap size");
            } else if (flag.startsWith("-Xmx")) {
                System.out.println("    ‚Üí Maximum heap size");
            } else if (flag.contains("GC")) {
                System.out.println("    ‚Üí Garbage Collector setting");
            } else if (flag.startsWith("-XX:")) {
                System.out.println("    ‚Üí Advanced JVM option");
            }
        }
        
        public static void recommendOptimizations() {
            System.out.println("\n=== Optimization Recommendations ===");
            
            Runtime runtime = Runtime.getRuntime();
            long maxMemory = runtime.maxMemory();
            long totalMemory = runtime.totalMemory();
            long freeMemory = runtime.freeMemory();
            long usedMemory = totalMemory - freeMemory;
            
            double memoryUtilization = (double) usedMemory / maxMemory * 100;
            
            System.out.printf("Memory utilization: %.1f%%%n", memoryUtilization);
            
            if (memoryUtilization > 80) {
                System.out.println("‚ö†Ô∏è  High memory usage - consider:");
                System.out.println("   - Increasing heap size (-Xmx)");
                System.out.println("   - Analyzing memory leaks");
                System.out.println("   - Optimizing data structures");
            } else if (memoryUtilization < 30) {
                System.out.println("üí° Low memory usage - consider:");
                System.out.println("   - Decreasing heap size (-Xmx)");
                System.out.println("   - Using smaller initial heap (-Xms)");
            }
            
            // GC analysis
            analyzeGCPerformance();
        }
        
        private static void analyzeGCPerformance() {
            List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
            
            for (GarbageCollectorMXBean gcBean : gcBeans) {
                long collections = gcBean.getCollectionCount();
                long time = gcBean.getCollectionTime();
                
                if (collections > 0) {
                    double avgTime = (double) time / collections;
                    System.out.printf("GC %s: avg %.1f ms per collection%n", 
                        gcBean.getName(), avgTime);
                    
                    if (avgTime > 100) {
                        System.out.println("‚ö†Ô∏è  Long GC pauses detected - consider:");
                        System.out.println("   - Using G1GC (-XX:+UseG1GC)");
                        System.out.println("   - Tuning GC parameters");
                        System.out.println("   - Reducing object allocation rate");
                    }
                }
            }
        }
    }
    
    // Performance profiler
    public static class PerformanceProfiler {
        private static final Map<String, List<Long>> measurements = new ConcurrentHashMap<>();
        
        public static void startProfiling(String operation) {
            measurements.computeIfAbsent(operation, k -> new ArrayList<>());
        }
        
        public static <T> T profile(String operation, Supplier<T> supplier) {
            long start = System.nanoTime();
            try {
                return supplier.get();
            } finally {
                long duration = System.nanoTime() - start;
                measurements.computeIfAbsent(operation, k -> new ArrayList<>()).add(duration);
            }
        }
        
        public static void runProfile(String operation, Runnable runnable) {
            profile(operation, () -> {
                runnable.run();
                return null;
            });
        }
        
        public static void printStatistics() {
            System.out.println("\n=== Performance Statistics ===");
            
            for (Map.Entry<String, List<Long>> entry : measurements.entrySet()) {
                String operation = entry.getKey();
                List<Long> times = entry.getValue();
                
                if (!times.isEmpty()) {
                    LongSummaryStatistics stats = times.stream()
                        .mapToLong(Long::longValue)
                        .summaryStatistics();
                    
                    System.out.printf("%s:%n", operation);
                    System.out.printf("  Count: %d%n", stats.getCount());
                    System.out.printf("  Average: %.2f ms%n", stats.getAverage() / 1_000_000.0);
                    System.out.printf("  Min: %.2f ms%n", stats.getMin() / 1_000_000.0);
                    System.out.printf("  Max: %.2f ms%n", stats.getMax() / 1_000_000.0);
                    System.out.printf("  Total: %.2f ms%n", stats.getSum() / 1_000_000.0);
                }
            }
        }
        
        public static void reset() {
            measurements.clear();
        }
    }
    
    // Memory analyzer
    public static class MemoryAnalyzer {
        public static void analyzeMemoryPools() {
            System.out.println("\n=== Memory Pool Analysis ===");
            
            List<MemoryPoolMXBean> memoryPools = ManagementFactory.getMemoryPoolMXBeans();
            
            for (MemoryPoolMXBean pool : memoryPools) {
                MemoryUsage usage = pool.getUsage();
                if (usage != null) {
                    System.out.printf("%s:%n", pool.getName());
                    System.out.printf("  Used: %d MB%n", usage.getUsed() / 1024 / 1024);
                    System.out.printf("  Committed: %d MB%n", usage.getCommitted() / 1024 / 1024);
                    
                    if (usage.getMax() > 0) {
                        System.out.printf("  Max: %d MB%n", usage.getMax() / 1024 / 1024);
                        double utilization = (double) usage.getUsed() / usage.getMax() * 100;
                        System.out.printf("  Utilization: %.1f%%%n", utilization);
                        
                        if (utilization > 90) {
                            System.out.println("  ‚ö†Ô∏è  High utilization!");
                        }
                    }
                    System.out.println();
                }
            }
        }
        
        public static void detectMemoryLeaks() {
            System.out.println("=== Memory Leak Detection ===");
            
            // Force GC and measure
            Runtime runtime = Runtime.getRuntime();
            
            long beforeGC = runtime.totalMemory() - runtime.freeMemory();
            System.gc();
            System.gc(); // Double GC for better cleanup
            
            try {
                Thread.sleep(100); // Give GC time to work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            long afterGC = runtime.totalMemory() - runtime.freeMemory();
            long freed = beforeGC - afterGC;
            
            System.out.printf("Memory before GC: %d MB%n", beforeGC / 1024 / 1024);
            System.out.printf("Memory after GC: %d MB%n", afterGC / 1024 / 1024);
            System.out.printf("Memory freed: %d MB%n", freed / 1024 / 1024);
            
            if (freed < beforeGC * 0.1) { // Less than 10% freed
                System.out.println("‚ö†Ô∏è  Potential memory leak - very little memory freed by GC");
            }
        }
    }
    
    // JIT compilation analyzer
    public static class JITAnalyzer {
        public static void analyzeCompilation() {
            System.out.println("\n=== JIT Compilation Analysis ===");
            
            CompilationMXBean compilationBean = ManagementFactory.getCompilationMXBean();
            
            if (compilationBean != null) {
                System.out.println("JIT Compiler: " + compilationBean.getName());
                
                if (compilationBean.isCompilationTimeMonitoringSupported()) {
                    System.out.printf("Total compilation time: %d ms%n", 
                        compilationBean.getTotalCompilationTime());
                }
            }
            
            // Simulate hot method to trigger JIT
            System.out.println("Warming up JIT compiler...");
            for (int i = 0; i < 100000; i++) {
                hotMethod(i);
            }
            
            if (compilationBean != null && compilationBean.isCompilationTimeMonitoringSupported()) {
                System.out.printf("Compilation time after warmup: %d ms%n", 
                    compilationBean.getTotalCompilationTime());
            }
        }
        
        private static long hotMethod(int n) {
            // This method will be compiled by JIT after many invocations
            long result = 0;
            for (int i = 0; i < n; i++) {
                result += i * i;
            }
            return result;
        }
    }
    
    public static void main(String[] args) {
        // Comprehensive JVM analysis
        JVMFlagsAnalyzer.analyzeCurrentFlags();
        JVMFlagsAnalyzer.recommendOptimizations();
        
        // Performance profiling demo
        PerformanceProfiler.runProfile("String operations", () -> {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 10000; i++) {
                sb.append("test").append(i);
            }
        });
        
        PerformanceProfiler.runProfile("Math operations", () -> {
            double result = 0;
            for (int i = 0; i < 100000; i++) {
                result += Math.sqrt(i);
            }
        });
        
        PerformanceProfiler.printStatistics();
        
        // Memory analysis
        MemoryAnalyzer.analyzeMemoryPools();
        MemoryAnalyzer.detectMemoryLeaks();
        
        // JIT analysis
        JITAnalyzer.analyzeCompilation();
    }
}
```

---

### üéâ Podsumowanie czƒô≈õci V

*Gratulacje! Uko≈Ñczy≈Ça≈õ kompletny przewodnik Java! Przesz≈Ça≈õ drogƒô od podstaw do zaawansowanych technik. Teraz masz narzƒôdzia do tworzenia profesjonalnych, wydajnych i bezpiecznych aplikacji.*

#### Co osiƒÖgnƒô≈Ça≈õ:
- **Exception Handling** - umiesz projektowaƒá odporne aplikacje
- **Serialization** - potrafisz przechowywaƒá i przesy≈Çaƒá obiekty
- **Adnotacje** - znasz moc metadanych
- **Java IO** - ≈ÇƒÖczysz aplikacje ze ≈õwiatem
- **Logowanie** - zapisujesz historiƒô aplikacji
- **JavaDoc** - dokumentujesz kod profesjonalnie
- **Modu≈Çy** - organizujesz kod w logiczne jednostki
- **Security** - chronisz aplikacje przed zagro≈ºeniami
- **DDD** - piszesz kod zrozumia≈Çy dla biznesu
- **Reactive Programming** - reagujesz na wydarzenia w czasie rzeczywistym
- **Profilowanie** - diagnozujesz i optymalizujesz
- **Wzorce projektowe** - u≈ºywasz sprawdzonych rozwiƒÖza≈Ñ
- **JVM Tuning** - wyciƒÖgasz maksimum z platformy

#### Nastƒôpne kroki:
1. **Praktykuj** - buduj prawdziwe projekty
2. **Eksperymentuj** - testuj nowe biblioteki i frameworki
3. **Ucz siƒô dalej** - Spring, Hibernate, Microservices
4. **Dziel siƒô wiedzƒÖ** - pomagaj innym programistkom
5. **BƒÖd≈∫ na bie≈ºƒÖco** - Java ciƒÖgle siƒô rozwija

*Pamiƒôtaj: Programowanie to rzemios≈Ço, kt√≥re doskonali siƒô przez ca≈Çe ≈ºycie. Ka≈ºdy projekt to nowa lekcja, ka≈ºdy b≈ÇƒÖd to okazja do nauki. Powodzenia w Twojej przygodzie z JavƒÖ! ‚òïÔ∏è*

---

*üí° Ostatnia rada: Kod piszesz raz, ale czytasz setki razy. Pisz tak, jakby osoba, kt√≥ra bƒôdzie go utrzymywaƒá, by≈Ça psychopatkƒÖ znajƒÖcƒÖ Tw√≥j adres!*

