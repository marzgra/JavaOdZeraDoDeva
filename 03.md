# III. Obiektowo≈õƒá i zaawansowane typy

## 14. OOP po ludzku ‚Äî dziedziczenie, polimorfizm i enkapsulacja

*Cze≈õƒá! Dzi≈õ zag≈Çƒôbimy siƒô w serce Javy - programowanie obiektowe. Je≈õli my≈õlisz, ≈ºe OOP to tylko klasy i obiekty, to czeka Ciƒô mi≈Ça niespodzianka. To spos√≥b my≈õlenia o kodzie, kt√≥ry pozwala modelowaƒá rzeczywisty ≈õwiat w programie. Dziedziczenie, polimorfizm, enkapsulacja - brzmi skomplikowanie? Spokojnie, wyja≈õniƒô Ci to wszystko prostymi s≈Çowami, jak podczas rozmowy przy kawie!*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Co to w≈Ça≈õciwie jest?

Programowanie obiektowe (OOP) to spos√≥b organizowania kodu wok√≥≈Ç obiekt√≥w - rzeczy, kt√≥re majƒÖ w≈Ça≈õciwo≈õci (pola) i zachowania (metody). To jak my≈õlenie o programie jako o zbiorze wsp√≥≈ÇpracujƒÖcych ze sobƒÖ obiekt√≥w, podobnie jak w rzeczywistym ≈õwiecie.

```java
// My≈õl o obiekcie jak o rzeczywistej rzeczy
public class Samochod {
    // W≈Ça≈õciwo≈õci (co ma)
    private String marka;
    private String model;
    private int rokProdukcji;
    private boolean wlaczony;
    
    // Zachowania (co mo≈ºe robiƒá)
    public void wlacz() {
        wlaczony = true;
        System.out.println("Samoch√≥d zosta≈Ç w≈ÇƒÖczony");
    }
    
    public void wylacz() {
        wlaczony = false;
        System.out.println("Samoch√≥d zosta≈Ç wy≈ÇƒÖczony");
    }
    
    public void jedz() {
        if (wlaczony) {
            System.out.println("Samoch√≥d jedzie");
        } else {
            System.out.println("Najpierw w≈ÇƒÖcz samoch√≥d!");
        }
    }
}
```

#### Dlaczego to wa≈ºne?

OOP pozwala tworzyƒá kod, kt√≥ry jest:
- **Zrozumia≈Çy** - modeluje rzeczywisty ≈õwiat
- **Wielokrotnego u≈ºytku** - raz napisane klasy mo≈ºna u≈ºywaƒá w wielu miejscach
- **≈Åatwy w utrzymaniu** - zmiany w jednym miejscu nie psujƒÖ reszty
- **Skalowalny** - ≈Çatwo dodawaƒá nowe funkcjonalno≈õci

#### Enkapsulacja - ukrywanie szczeg√≥≈Ç√≥w

Enkapsulacja to ukrywanie wewnƒôtrznych szczeg√≥≈Ç√≥w obiektu i udostƒôpnianie tylko tego, co potrzebne na zewnƒÖtrz.

```java
public class KontoBankowe {
    // Prywatne pola - nikt z zewnƒÖtrz nie mo≈ºe ich bezpo≈õrednio zmieniaƒá
    private String numerKonta;
    private double saldo;
    private String wlasciciel;
    
    public KontoBankowe(String numerKonta, String wlasciciel) {
        this.numerKonta = numerKonta;
        this.wlasciciel = wlasciciel;
        this.saldo = 0.0;
    }
    
    // Publiczne metody - kontrolowany dostƒôp do danych
    public void wplac(double kwota) {
        if (kwota > 0) {
            saldo += kwota;
            System.out.println("Wp≈Çacono: " + kwota + " z≈Ç");
        } else {
            System.out.println("Kwota musi byƒá wiƒôksza od zera");
        }
    }
    
    public boolean wyplac(double kwota) {
        if (kwota > 0 && kwota <= saldo) {
            saldo -= kwota;
            System.out.println("Wyp≈Çacono: " + kwota + " z≈Ç");
            return true;
        } else {
            System.out.println("NiewystarczajƒÖce ≈õrodki lub nieprawid≈Çowa kwota");
            return false;
        }
    }
    
    // Getter - kontrolowany dostƒôp do odczytu
    public double getSaldo() {
        return saldo;
    }
    
    public String getWlasciciel() {
        return wlasciciel;
    }
    
    // Nie ma settera dla saldo - mo≈ºna je zmieniaƒá tylko przez wp≈Çaty/wyp≈Çaty!
}

// U≈ºycie
public class TestKonta {
    public static void main(String[] args) {
        KontoBankowe konto = new KontoBankowe("123456789", "Anna Kowalska");
        
        konto.wplac(1000);
        System.out.println("Saldo: " + konto.getSaldo());
        
        konto.wyplac(300);
        System.out.println("Saldo: " + konto.getSaldo());
        
        // To nie zadzia≈Ça - pole jest prywatne!
        // konto.saldo = 1000000;  // B≈ÇƒÖd kompilacji!
    }
}
```

#### Dziedziczenie - budowanie na istniejƒÖcych klasach

Dziedziczenie pozwala tworzyƒá nowe klasy na podstawie istniejƒÖcych, dziedziczƒÖc ich w≈Ça≈õciwo≈õci i zachowania.

```java
// Klasa bazowa (nadklasa)
public class Zwierze {
    protected String imie;
    protected int wiek;
    
    public Zwierze(String imie, int wiek) {
        this.imie = imie;
        this.wiek = wiek;
    }
    
    public void jedz() {
        System.out.println(imie + " je");
    }
    
    public void spij() {
        System.out.println(imie + " ≈õpi");
    }
    
    public void wydajDzwiek() {
        System.out.println(imie + " wydaje d≈∫wiƒôk");
    }
    
    // Gettery
    public String getImie() { return imie; }
    public int getWiek() { return wiek; }
}

// Klasa pochodna (podklasa)
public class Pies extends Zwierze {
    private String rasa;
    
    public Pies(String imie, int wiek, String rasa) {
        super(imie, wiek);  // Wywo≈Çanie konstruktora nadklasy
        this.rasa = rasa;
    }
    
    // Przes≈Çanianie metody (override)
    @Override
    public void wydajDzwiek() {
        System.out.println(imie + " szczeka: Hau hau!");
    }
    
    // Nowa metoda specyficzna dla psa
    public void aportuj() {
        System.out.println(imie + " aportuje pi≈Çkƒô");
    }
    
    public String getRasa() { return rasa; }
}

public class Kot extends Zwierze {
    private boolean domowy;
    
    public Kot(String imie, int wiek, boolean domowy) {
        super(imie, wiek);
        this.domowy = domowy;
    }
    
    @Override
    public void wydajDzwiek() {
        System.out.println(imie + " miauczy: Miau miau!");
    }
    
    public void mruczenie() {
        System.out.println(imie + " mruczy");
    }
    
    public boolean isDomowy() { return domowy; }
}

// U≈ºycie
public class TestZwierzat {
    public static void main(String[] args) {
        Pies pies = new Pies("Burek", 3, "Labrador");
        Kot kot = new Kot("Mruczek", 2, true);
        
        // Metody dziedziczone z Zwierze
        pies.jedz();
        kot.spij();
        
        // Przes≈Çoniƒôte metody
        pies.wydajDzwiek();  // Szczeka
        kot.wydajDzwiek();   // Miauczy
        
        // Metody specyficzne dla podklas
        pies.aportuj();
        kot.mruczenie();
        
        System.out.println("Pies " + pies.getImie() + " to " + pies.getRasa());
        System.out.println("Kot " + kot.getImie() + " jest " + 
                          (kot.isDomowy() ? "domowy" : "dziki"));
    }
}
```

#### Polimorfizm - jedna forma, wiele zachowa≈Ñ

Polimorfizm pozwala traktowaƒá obiekty r√≥≈ºnych klas w jednolity spos√≥b, je≈õli dziedziczƒÖ z tej samej nadklasy.

```java
public class TestPolimorfizmu {
    public static void main(String[] args) {
        // Polimorfizm - referencja nadklasy mo≈ºe wskazywaƒá na obiekty podklas
        Zwierze[] zwierzeta = {
            new Pies("Burek", 3, "Labrador"),
            new Kot("Mruczek", 2, true),
            new Pies("Azor", 5, "Owczarek"),
            new Kot("Filemon", 1, false)
        };
        
        // Jedna pƒôtla obs≈Çuguje wszystkie typy zwierzƒÖt!
        for (Zwierze zwierze : zwierzeta) {
            System.out.println("--- " + zwierze.getImie() + " ---");
            zwierze.jedz();
            zwierze.wydajDzwiek();  // Ka≈ºde zwierzƒô wydaje sw√≥j d≈∫wiƒôk!
            
            // Sprawdzanie typu i rzutowanie
            if (zwierze instanceof Pies) {
                Pies pies = (Pies) zwierze;
                pies.aportuj();
            } else if (zwierze instanceof Kot) {
                Kot kot = (Kot) zwierze;
                kot.mruczenie();
            }
        }
    }
    
    // Metoda przyjmujƒÖca dowolne zwierzƒô
    public static void opiekujSie(Zwierze zwierze) {
        System.out.println("Opiekujƒô siƒô " + zwierze.getImie());
        zwierze.jedz();
        zwierze.spij();
        zwierze.wydajDzwiek();
    }
}
```

#### Abstrakcyjne klasy i metody

Czasami chcemy zdefiniowaƒá klasƒô, kt√≥ra nie mo≈ºe byƒá bezpo≈õrednio instancjonowana, ale s≈Çu≈ºy jako szablon dla podklas.

```java
// Abstrakcyjna klasa
public abstract class Ksztalt {
    protected String kolor;
    
    public Ksztalt(String kolor) {
        this.kolor = kolor;
    }
    
    // Zwyk≈Ça metoda
    public String getKolor() {
        return kolor;
    }
    
    // Abstrakcyjna metoda - musi byƒá zaimplementowana w podklasach
    public abstract double obliczPole();
    public abstract double obliczObwod();
    
    // Metoda u≈ºywajƒÖca abstrakcyjnych metod
    public void wyswietlInfo() {
        System.out.println("Kszta≈Çt w kolorze " + kolor);
        System.out.println("Pole: " + obliczPole());
        System.out.println("Obw√≥d: " + obliczObwod());
    }
}

public class Prostokat extends Ksztalt {
    private double szerokosc;
    private double wysokosc;
    
    public Prostokat(String kolor, double szerokosc, double wysokosc) {
        super(kolor);
        this.szerokosc = szerokosc;
        this.wysokosc = wysokosc;
    }
    
    @Override
    public double obliczPole() {
        return szerokosc * wysokosc;
    }
    
    @Override
    public double obliczObwod() {
        return 2 * (szerokosc + wysokosc);
    }
}

public class Kolo extends Ksztalt {
    private double promien;
    
    public Kolo(String kolor, double promien) {
        super(kolor);
        this.promien = promien;
    }
    
    @Override
    public double obliczPole() {
        return Math.PI * promien * promien;
    }
    
    @Override
    public double obliczObwod() {
        return 2 * Math.PI * promien;
    }
}

// U≈ºycie
public class TestKsztaltow {
    public static void main(String[] args) {
        // Nie mo≈ºna utworzyƒá obiektu abstrakcyjnej klasy
        // Ksztalt ksztalt = new Ksztalt("czerwony");  // B≈ÇƒÖd!
        
        Ksztalt[] ksztalty = {
            new Prostokat("niebieski", 5, 3),
            new Kolo("czerwony", 4),
            new Prostokat("zielony", 2, 2)
        };
        
        for (Ksztalt ksztalt : ksztalty) {
            ksztalt.wyswietlInfo();
            System.out.println();
        }
    }
}
```

#### Kompozycja vs dziedziczenie

Nie zawsze dziedziczenie jest najlepszym rozwiƒÖzaniem. Czasami lepiej u≈ºyƒá kompozycji.

```java
// Kompozycja - "ma" zamiast "jest"
public class Silnik {
    private int moc;
    private String typ;
    
    public Silnik(int moc, String typ) {
        this.moc = moc;
        this.typ = typ;
    }
    
    public void uruchom() {
        System.out.println("Silnik " + typ + " (" + moc + " KM) zosta≈Ç uruchomiony");
    }
    
    public void zatrzymaj() {
        System.out.println("Silnik zosta≈Ç zatrzymany");
    }
    
    public int getMoc() { return moc; }
    public String getTyp() { return typ; }
}

public class Samochod {
    private String marka;
    private String model;
    private Silnik silnik;  // Kompozycja - samoch√≥d "ma" silnik
    
    public Samochod(String marka, String model, Silnik silnik) {
        this.marka = marka;
        this.model = model;
        this.silnik = silnik;
    }
    
    public void uruchom() {
        System.out.println("Uruchamiam " + marka + " " + model);
        silnik.uruchom();
    }
    
    public void zatrzymaj() {
        System.out.println("Zatrzymujƒô " + marka + " " + model);
        silnik.zatrzymaj();
    }
    
    public void wyswietlInfo() {
        System.out.println(marka + " " + model + " z silnikiem " + 
                          silnik.getTyp() + " (" + silnik.getMoc() + " KM)");
    }
}

// U≈ºycie
public class TestKompozycji {
    public static void main(String[] args) {
        Silnik silnikBenzyna = new Silnik(150, "benzyna");
        Silnik silnikDiesel = new Silnik(120, "diesel");
        
        Samochod toyota = new Samochod("Toyota", "Corolla", silnikBenzyna);
        Samochod volkswagen = new Samochod("Volkswagen", "Golf", silnikDiesel);
        
        toyota.wyswietlInfo();
        toyota.uruchom();
        toyota.zatrzymaj();
        
        System.out.println();
        
        volkswagen.wyswietlInfo();
        volkswagen.uruchom();
        volkswagen.zatrzymaj();
    }
}
```

#### Pu≈Çapki, na kt√≥re warto uwa≈ºaƒá

**Pu≈Çapka 1: Nadu≈ºywanie dziedziczenia**

```java
// ≈πLE - dziedziczenie dla wsp√≥≈Çdzielenia kodu
public class Osoba {
    protected String imie;
    protected String adres;
    
    public void wyswietlInfo() {
        System.out.println(imie + ", " + adres);
    }
}

public class Samochod extends Osoba {  // To nie ma sensu!
    private String marka;
    // Samoch√≥d nie "jest" osobƒÖ!
}

// DOBRZE - kompozycja lub wsp√≥lny interfejs
public interface Wyswietlalny {
    void wyswietlInfo();
}

public class Osoba implements Wyswietlalny {
    private String imie;
    private String adres;
    
    @Override
    public void wyswietlInfo() {
        System.out.println(imie + ", " + adres);
    }
}

public class Samochod implements Wyswietlalny {
    private String marka;
    private String model;
    
    @Override
    public void wyswietlInfo() {
        System.out.println(marka + " " + model);
    }
}
```

**Pu≈Çapka 2: ≈Åamanie enkapsulacji przez protected**

```java
public class Bazowa {
    protected int wartosc;  // Dostƒôpne dla podklas
}

public class Pochodna extends Bazowa {
    public void zepsujEnkapsulacje() {
        wartosc = -999;  // Podklasa mo≈ºe zepsuƒá stan nadklasy!
    }
}

// Lepiej: prywatne pola + protected metody
public class LepszaBazowa {
    private int wartosc;
    
    protected int getWartosc() { return wartosc; }
    protected void setWartosc(int wartosc) {
        if (wartosc >= 0) {  // Walidacja
            this.wartosc = wartosc;
        }
    }
}
```

#### üí° Wskaz√≥wki dla Juniorek

- **Enkapsulacja** - ukrywaj szczeg√≥≈Çy implementacji
- **Dziedziczenie** - u≈ºywaj gdy jest relacja "jest" (is-a)
- **Kompozycja** - u≈ºywaj gdy jest relacja "ma" (has-a)
- **Polimorfizm** - jedna metoda, r√≥≈ºne zachowania
- **Abstrakcyjne klasy** - gdy chcesz wymusiƒá implementacjƒô metod

#### üéØ Zadania dla Juniorek

**Zadanie 1:** Stw√≥rz hierarchiƒô klas dla r√≥≈ºnych typ√≥w pracownik√≥w (Manager, Developer, Designer) z polimorficznƒÖ metodƒÖ obliczania wynagrodzenia.

**Zadanie 2:** Zaprojektuj system biblioteki z klasami Book, Author, Library u≈ºywajƒÖc kompozycji.

**Zadanie 3:** Zaimplementuj abstrakcyjnƒÖ klasƒô Vehicle z konkretnymi implementacjami Car, Bike, Truck.

#### ‚ùì Pytania Kontrolne - Poziom Junior

1. Jaka jest r√≥≈ºnica miƒôdzy dziedziczeniem a kompozycjƒÖ?
2. Kiedy u≈ºywaƒá abstrakcyjnych klas?
3. Co to jest polimorfizm i jak dzia≈Ça?

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### G≈Çƒôbsza analiza tematu

OOP w Javie to nie tylko sk≈Çadnia - to zestaw wzorc√≥w projektowych i zasad, kt√≥re pozwalajƒÖ budowaƒá skalowalne, maintainable systemy. Przyjrzyjmy siƒô zaawansowanym aspektom i best practices.

##### SOLID Principles w praktyce

```java
// Single Responsibility Principle (SRP)
// ≈πLE - klasa robi za du≈ºo
public class User {
    private String name;
    private String email;
    
    public void save() {
        // Logika zapisu do bazy danych
        System.out.println("Saving user to database");
    }
    
    public void sendEmail() {
        // Logika wysy≈Çania emaili
        System.out.println("Sending email to " + email);
    }
    
    public String generateReport() {
        // Logika generowania raport√≥w
        return "User report for " + name;
    }
}

// DOBRZE - ka≈ºda klasa ma jednƒÖ odpowiedzialno≈õƒá
public class User {
    private String name;
    private String email;
    
    // Tylko dane u≈ºytkownika
    public String getName() { return name; }
    public String getEmail() { return email; }
}

public class UserRepository {
    public void save(User user) {
        System.out.println("Saving user to database");
    }
    
    public User findById(String id) {
        // Logika wyszukiwania
        return new User();
    }
}

public class EmailService {
    public void sendEmail(User user, String message) {
        System.out.println("Sending email to " + user.getEmail());
    }
}

public class ReportGenerator {
    public String generateUserReport(User user) {
        return "User report for " + user.getName();
    }
}

// Open/Closed Principle (OCP)
// Klasy otwarte na rozszerzenia, zamkniƒôte na modyfikacje
public abstract class Shape {
    public abstract double calculateArea();
}

public class Rectangle extends Shape {
    private double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

public class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

// Mo≈ºna dodaƒá nowe kszta≈Çty bez modyfikacji istniejƒÖcego kodu
public class Triangle extends Shape {
    private double base, height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

// Liskov Substitution Principle (LSP)
// Obiekty podklas muszƒÖ byƒá zastƒôpowalne obiektami nadklasy
public class Bird {
    public void fly() {
        System.out.println("Bird is flying");
    }
}

// ≈πLE - ≈Çamie LSP
public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

// DOBRZE - lepszy design
public abstract class Bird {
    public abstract void move();
}

public class FlyingBird extends Bird {
    @Override
    public void move() {
        fly();
    }
    
    protected void fly() {
        System.out.println("Flying");
    }
}

public class SwimmingBird extends Bird {
    @Override
    public void move() {
        swim();
    }
    
    protected void swim() {
        System.out.println("Swimming");
    }
}

public class Eagle extends FlyingBird {}
public class Penguin extends SwimmingBird {}

// Interface Segregation Principle (ISP)
// Klienci nie powinni zale≈ºeƒá od interfejs√≥w, kt√≥rych nie u≈ºywajƒÖ

// ≈πLE - fat interface
public interface Worker {
    void work();
    void eat();
    void sleep();
}

// DOBRZE - segregated interfaces
public interface Workable {
    void work();
}

public interface Eater {
    void eat();
}

public interface Sleeper {
    void sleep();
}

public class Human implements Workable, Eater, Sleeper {
    @Override
    public void work() { System.out.println("Human working"); }
    
    @Override
    public void eat() { System.out.println("Human eating"); }
    
    @Override
    public void sleep() { System.out.println("Human sleeping"); }
}

public class Robot implements Workable {
    @Override
    public void work() { System.out.println("Robot working"); }
    // Robot nie musi implementowaƒá eat() i sleep()
}

// Dependency Inversion Principle (DIP)
// Zale≈ºno≈õci powinny byƒá od abstrakcji, nie od konkretnych implementacji

// ≈πLE - zale≈ºno≈õƒá od konkretnej klasy
public class OrderService {
    private EmailService emailService = new EmailService();  // Tight coupling
    
    public void processOrder(Order order) {
        // Process order
        emailService.sendEmail(order.getCustomer(), "Order processed");
    }
}

// DOBRZE - zale≈ºno≈õƒá od abstrakcji
public interface NotificationService {
    void sendNotification(String recipient, String message);
}

public class EmailNotificationService implements NotificationService {
    @Override
    public void sendNotification(String recipient, String message) {
        System.out.println("Sending email to " + recipient + ": " + message);
    }
}

public class SMSNotificationService implements NotificationService {
    @Override
    public void sendNotification(String recipient, String message) {
        System.out.println("Sending SMS to " + recipient + ": " + message);
    }
}

public class OrderService {
    private final NotificationService notificationService;
    
    // Dependency injection
    public OrderService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
    
    public void processOrder(Order order) {
        // Process order
        notificationService.sendNotification(
            order.getCustomer().getEmail(), 
            "Order processed"
        );
    }
}
```

##### Zaawansowane wzorce dziedziczenia

```java
// Template Method Pattern
public abstract class DataProcessor {
    // Template method - definiuje algorytm
    public final void processData() {
        loadData();
        validateData();
        transformData();
        saveData();
        cleanup();
    }
    
    // Kroki do zaimplementowania przez podklasy
    protected abstract void loadData();
    protected abstract void validateData();
    protected abstract void transformData();
    protected abstract void saveData();
    
    // Hook method - opcjonalne do przes≈Çoniƒôcia
    protected void cleanup() {
        System.out.println("Default cleanup");
    }
}

public class CSVDataProcessor extends DataProcessor {
    @Override
    protected void loadData() {
        System.out.println("Loading CSV data");
    }
    
    @Override
    protected void validateData() {
        System.out.println("Validating CSV format");
    }
    
    @Override
    protected void transformData() {
        System.out.println("Transforming CSV data");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving to database");
    }
    
    @Override
    protected void cleanup() {
        System.out.println("Closing CSV file");
    }
}

public class XMLDataProcessor extends DataProcessor {
    @Override
    protected void loadData() {
        System.out.println("Loading XML data");
    }
    
    @Override
    protected void validateData() {
        System.out.println("Validating XML schema");
    }
    
    @Override
    protected void transformData() {
        System.out.println("Transforming XML data");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving to database");
    }
}

// Strategy Pattern z dziedziczeniem
public abstract class SortingStrategy {
    public abstract <T extends Comparable<T>> void sort(T[] array);
    
    // Template method dla benchmarking
    public final <T extends Comparable<T>> long sortWithTiming(T[] array) {
        long start = System.nanoTime();
        sort(array);
        long end = System.nanoTime();
        return end - start;
    }
}

public class QuickSort extends SortingStrategy {
    @Override
    public <T extends Comparable<T>> void sort(T[] array) {
        quickSort(array, 0, array.length - 1);
    }
    
    private <T extends Comparable<T>> void quickSort(T[] array, int low, int high) {
        if (low < high) {
            int pi = partition(array, low, high);
            quickSort(array, low, pi - 1);
            quickSort(array, pi + 1, high);
        }
    }
    
    private <T extends Comparable<T>> int partition(T[] array, int low, int high) {
        T pivot = array[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (array[j].compareTo(pivot) <= 0) {
                i++;
                T temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
        
        T temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;
        
        return i + 1;
    }
}

public class MergeSort extends SortingStrategy {
    @Override
    public <T extends Comparable<T>> void sort(T[] array) {
        mergeSort(array, 0, array.length - 1);
    }
    
    private <T extends Comparable<T>> void mergeSort(T[] array, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(array, left, mid);
            mergeSort(array, mid + 1, right);
            merge(array, left, mid, right);
        }
    }
    
    @SuppressWarnings("unchecked")
    private <T extends Comparable<T>> void merge(T[] array, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        T[] leftArray = (T[]) new Comparable[n1];
        T[] rightArray = (T[]) new Comparable[n2];
        
        System.arraycopy(array, left, leftArray, 0, n1);
        System.arraycopy(array, mid + 1, rightArray, 0, n2);
        
        int i = 0, j = 0, k = left;
        
        while (i < n1 && j < n2) {
            if (leftArray[i].compareTo(rightArray[j]) <= 0) {
                array[k] = leftArray[i];
                i++;
            } else {
                array[k] = rightArray[j];
                j++;
            }
            k++;
        }
        
        while (i < n1) {
            array[k] = leftArray[i];
            i++;
            k++;
        }
        
        while (j < n2) {
            array[k] = rightArray[j];
            j++;
            k++;
        }
    }
}
```

##### Composition over inheritance patterns

```java
// Decorator Pattern z kompozycjƒÖ
public interface Coffee {
    String getDescription();
    double getCost();
}

public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple coffee";
    }
    
    @Override
    public double getCost() {
        return 2.0;
    }
}

public abstract class CoffeeDecorator implements Coffee {
    protected final Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription();
    }
    
    @Override
    public double getCost() {
        return coffee.getCost();
    }
}

public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", milk";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", sugar";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.2;
    }
}

// U≈ºycie
Coffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " costs $" + coffee.getCost());

// Bridge Pattern
public interface DrawingAPI {
    void drawCircle(double x, double y, double radius);
}

public class DrawingAPI1 implements DrawingAPI {
    @Override
    public void drawCircle(double x, double y, double radius) {
        System.out.printf("API1.circle at %f:%f radius %f%n", x, y, radius);
    }
}

public class DrawingAPI2 implements DrawingAPI {
    @Override
    public void drawCircle(double x, double y, double radius) {
        System.out.printf("API2.circle at %f:%f radius %f%n", x, y, radius);
    }
}

public abstract class Shape {
    protected DrawingAPI drawingAPI;
    
    protected Shape(DrawingAPI drawingAPI) {
        this.drawingAPI = drawingAPI;
    }
    
    public abstract void draw();
    public abstract void resizeByPercentage(double pct);
}

public class CircleShape extends Shape {
    private double x, y, radius;
    
    public CircleShape(double x, double y, double radius, DrawingAPI drawingAPI) {
        super(drawingAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        drawingAPI.drawCircle(x, y, radius);
    }
    
    @Override
    public void resizeByPercentage(double pct) {
        radius *= (1.0 + pct / 100.0);
    }
}
```

#### üîß Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj system plugin'√≥w u≈ºywajƒÖc abstract factory pattern z dziedziczeniem i kompozycjƒÖ.

**Zadanie Zaawansowane 2:** Stw√≥rz framework do obs≈Çugi event√≥w z hierarchiƒÖ klas event'√≥w i polimorficznym dispatchingiem.

**Zadanie Zaawansowane 3:** Zaprojektuj system permission management z multiple inheritance simulation przez interfaces i composition.

#### ‚ùì Pytania Kontrolne - Poziom Senior

1. Jak SOLID principles wp≈ÇywajƒÖ na design klas i hierarchii dziedziczenia?
2. Kiedy preferowaƒá composition over inheritance i dlaczego?
3. Jak template method pattern r√≥≈ºni siƒô od strategy pattern w kontek≈õcie dziedziczenia?

---

### üîë Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public abstract class Pracownik {
    protected String imie;
    protected String nazwisko;
    protected double podstawa;
    
    public Pracownik(String imie, String nazwisko, double podstawa) {
        this.imie = imie;
        this.nazwisko = nazwisko;
        this.podstawa = podstawa;
    }
    
    public abstract double obliczWynagrodzenie();
    
    public String getPelneImie() {
        return imie + " " + nazwisko;
    }
    
    public void wyswietlInfo() {
        System.out.println(getPelneImie() + " - wynagrodzenie: " + obliczWynagrodzenie());
    }
}

public class Manager extends Pracownik {
    private double bonus;
    
    public Manager(String imie, String nazwisko, double podstawa, double bonus) {
        super(imie, nazwisko, podstawa);
        this.bonus = bonus;
    }
    
    @Override
    public double obliczWynagrodzenie() {
        return podstawa + bonus;
    }
}

public class Developer extends Pracownik {
    private int przepracowaneGodziny;
    private double stawkaGodzinowa;
    
    public Developer(String imie, String nazwisko, double podstawa, int godziny, double stawka) {
        super(imie, nazwisko, podstawa);
        this.przepracowaneGodziny = godziny;
        this.stawkaGodzinowa = stawka;
    }
    
    @Override
    public double obliczWynagrodzenie() {
        return podstawa + (przepracowaneGodziny * stawkaGodzinowa);
    }
}

public class Designer extends Pracownik {
    private int liczbaProjektow;
    private double stawkaZaProjekt;
    
    public Designer(String imie, String nazwisko, double podstawa, int projekty, double stawka) {
        super(imie, nazwisko, podstawa);
        this.liczbaProjektow = projekty;
        this.stawkaZaProjekt = stawka;
    }
    
    @Override
    public double obliczWynagrodzenie() {
        return podstawa + (liczbaProjektow * stawkaZaProjekt);
    }
}
```

**Zadanie 2:**
```java
public class Author {
    private String imie;
    private String nazwisko;
    private String narodowosc;
    
    public Author(String imie, String nazwisko, String narodowosc) {
        this.imie = imie;
        this.nazwisko = nazwisko;
        this.narodowosc = narodowosc;
    }
    
    public String getPelneImie() {
        return imie + " " + nazwisko;
    }
    
    // gettery...
}

public class Book {
    private String tytul;
    private Author autor;
    private String isbn;
    private int rokWydania;
    private boolean dostepna;
    
    public Book(String tytul, Author autor, String isbn, int rokWydania) {
        this.tytul = tytul;
        this.autor = autor;
        this.isbn = isbn;
        this.rokWydania = rokWydania;
        this.dostepna = true;
    }
    
    public void wypozycz() {
        if (dostepna) {
            dostepna = false;
            System.out.println("KsiƒÖ≈ºka '" + tytul + "' zosta≈Ça wypo≈ºyczona");
        } else {
            System.out.println("KsiƒÖ≈ºka '" + tytul + "' jest ju≈º wypo≈ºyczona");
        }
    }
    
    public void zwroc() {
        dostepna = true;
        System.out.println("KsiƒÖ≈ºka '" + tytul + "' zosta≈Ça zwr√≥cona");
    }
    
    // gettery...
}

public class Library {
    private List<Book> ksiazki;
    private String nazwa;
    
    public Library(String nazwa) {
        this.nazwa = nazwa;
        this.ksiazki = new ArrayList<>();
    }
    
    public void dodajKsiazke(Book ksiazka) {
        ksiazki.add(ksiazka);
    }
    
    public List<Book> znajdzKsiazki(String tytul) {
        return ksiazki.stream()
                     .filter(book -> book.getTytul().toLowerCase().contains(tytul.toLowerCase()))
                     .collect(Collectors.toList());
    }
    
    public List<Book> znajdzKsiazkiAutora(String autor) {
        return ksiazki.stream()
                     .filter(book -> book.getAutor().getPelneImie().toLowerCase().contains(autor.toLowerCase()))
                     .collect(Collectors.toList());
    }
    
    public void wyswietlDostepneKsiazki() {
        ksiazki.stream()
               .filter(Book::isDostepna)
               .forEach(book -> System.out.println(book.getTytul() + " - " + book.getAutor().getPelneImie()));
    }
}
```

**Zadanie 3:**
```java
public abstract class Vehicle {
    protected String marka;
    protected String model;
    protected int rokProdukcji;
    protected double predkosc;
    
    public Vehicle(String marka, String model, int rokProdukcji) {
        this.marka = marka;
        this.model = model;
        this.rokProdukcji = rokProdukcji;
        this.predkosc = 0;
    }
    
    public abstract void uruchom();
    public abstract void zatrzymaj();
    public abstract double obliczZuzyciePaliwa(double dystans);
    
    public void przyspiesz(double deltaPredkosc) {
        predkosc += deltaPredkosc;
        System.out.println(marka + " " + model + " przyspiesza do " + predkosc + " km/h");
    }
    
    public void zwolnij(double deltaPredkosc) {
        predkosc = Math.max(0, predkosc - deltaPredkosc);
        System.out.println(marka + " " + model + " zwalnia do " + predkosc + " km/h");
    }
    
    public void wyswietlInfo() {
        System.out.println(marka + " " + model + " (" + rokProdukcji + ") - prƒôdko≈õƒá: " + predkosc + " km/h");
    }
}

public class Car extends Vehicle {
    private int liczbaDrzwi;
    
    public Car(String marka, String model, int rokProdukcji, int liczbaDrzwi) {
        super(marka, model, rokProdukcji);
        this.liczbaDrzwi = liczbaDrzwi;
    }
    
    @Override
    public void uruchom() {
        System.out.println("Samoch√≥d " + marka + " " + model + " zosta≈Ç uruchomiony");
    }
    
    @Override
    public void zatrzymaj() {
        predkosc = 0;
        System.out.println("Samoch√≥d " + marka + " " + model + " zosta≈Ç zatrzymany");
    }
    
    @Override
    public double obliczZuzyciePaliwa(double dystans) {
        return dystans * 0.08; // 8l/100km
    }
}

public class Bike extends Vehicle {
    private boolean elektryczny;
    
    public Bike(String marka, String model, int rokProdukcji, boolean elektryczny) {
        super(marka, model, rokProdukcji);
        this.elektryczny = elektryczny;
    }
    
    @Override
    public void uruchom() {
        System.out.println("Rower " + marka + " " + model + " jest gotowy do jazdy");
    }
    
    @Override
    public void zatrzymaj() {
        predkosc = 0;
        System.out.println("Rower " + marka + " " + model + " zosta≈Ç zatrzymany");
    }
    
    @Override
    public double obliczZuzyciePaliwa(double dystans) {
        return elektryczny ? dystans * 0.01 : 0; // Elektryczny zu≈ºywa energiƒô
    }
}

public class Truck extends Vehicle {
    private double ladownosc;
    
    public Truck(String marka, String model, int rokProdukcji, double ladownosc) {
        super(marka, model, rokProdukcji);
        this.ladownosc = ladownosc;
    }
    
    @Override
    public void uruchom() {
        System.out.println("Ciƒô≈ºar√≥wka " + marka + " " + model + " zosta≈Ça uruchomiona");
    }
    
    @Override
    public void zatrzymaj() {
        predkosc = 0;
        System.out.println("Ciƒô≈ºar√≥wka " + marka + " " + model + " zosta≈Ça zatrzymana");
    }
    
    @Override
    public double obliczZuzyciePaliwa(double dystans) {
        return dystans * 0.25; // 25l/100km
    }
}
```

**Pytania kontrolne:**
1. Dziedziczenie to relacja "jest" (is-a), kompozycja to relacja "ma" (has-a). Kompozycja jest bardziej elastyczna i ≈Çatwiejsza w testowaniu.
2. Abstrakcyjne klasy gdy chcesz udostƒôpniƒá wsp√≥lnƒÖ implementacjƒô i wymusiƒá implementacjƒô niekt√≥rych metod w podklasach.
3. Polimorfizm pozwala traktowaƒá obiekty r√≥≈ºnych klas w jednolity spos√≥b przez wsp√≥lny interfejs lub nadklasƒô.

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. SOLID principles promujƒÖ loose coupling, high cohesion i extensibility. SRP zapobiega god classes, OCP pozwala na rozszerzenia bez modyfikacji, LSP gwarantuje poprawno≈õƒá polimorfizmu.
2. Composition gdy nie ma prawdziwej relacji "is-a", gdy potrzebujesz multiple inheritance, gdy chcesz runtime flexibility, gdy testability jest wa≈ºna.
3. Template method definiuje szkielet algorytmu w nadklasie, strategy pozwala na wymianƒô ca≈Çego algorytmu. Template method u≈ºywa dziedziczenia, strategy kompozycji.

---

### üìö Co dalej?

*Fantastycznie! Teraz masz solidne podstawy programowania obiektowego w Javie. Rozumiesz enkapsulacjƒô, dziedziczenie, polimorfizm i znasz SOLID principles. To fundament, na kt√≥rym bƒôdziesz budowaƒá wszystkie swoje aplikacje. W nastƒôpnym rozdziale porozmawiamy o sealed classes - czyli jak kontrolowaƒá hierarchie dziedziczenia w nowoczesnej Javie!*

---

*üí° Pamiƒôtaj: OOP to nie tylko sk≈Çadnia, to spos√≥b my≈õlenia o kodzie. Modeluj rzeczywisty ≈õwiat, ukrywaj szczeg√≥≈Çy, u≈ºywaj polimorfizmu mƒÖdrze!*


## 15. Sealed classes ‚Äî kontrolowana hierarchia dziedziczenia

*Cze≈õƒá! Dzi≈õ porozmawiamy o sealed classes - jednej z najciekawszych nowo≈õci w Javie 17. Je≈õli kiedykolwiek chcia≈Ça≈õ mieƒá kontrolƒô nad tym, kto mo≈ºe dziedziczyƒá z Twojej klasy, to sealed classes to odpowied≈∫ na Twoje modlitwy. To jak VIP lista dla dziedziczenia - tylko wybrane klasy mogƒÖ wej≈õƒá do klubu! Przygotuj siƒô na odkrycie, jak tworzyƒá bezpieczne i przewidywalne hierarchie klas.*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Co to w≈Ça≈õciwie jest?

Sealed class to klasa, kt√≥ra mo≈ºe byƒá dziedziczona tylko przez okre≈õlone, z g√≥ry zdefiniowane klasy. To jak zamkniƒôta lista - wiesz dok≈Çadnie, kto mo≈ºe byƒá Twoim dzieckiem w hierarchii dziedziczenia.

```java
// Przed sealed classes - ka≈ºdy m√≥g≈Ç dziedziczyƒá
public abstract class Ksztalt {
    public abstract double obliczPole();
}

// Kto≈õ m√≥g≈Ç stworzyƒá nieprzewidzianƒÖ implementacjƒô
public class DziwnyKsztalt extends Ksztalt {
    @Override
    public double obliczPole() {
        return -1; // Nieprawid≈Çowa implementacja!
    }
}

// Z sealed classes - kontrolujesz hierarchiƒô
public sealed class KsztaltSealed 
    permits Prostokat, Kolo, Trojkat {
    
    public abstract double obliczPole();
}

// Tylko te klasy mogƒÖ dziedziczyƒá
public final class Prostokat extends KsztaltSealed {
    private final double szerokosc, wysokosc;
    
    public Prostokat(double szerokosc, double wysokosc) {
        this.szerokosc = szerokosc;
        this.wysokosc = wysokosc;
    }
    
    @Override
    public double obliczPole() {
        return szerokosc * wysokosc;
    }
}

public final class Kolo extends KsztaltSealed {
    private final double promien;
    
    public Kolo(double promien) {
        this.promien = promien;
    }
    
    @Override
    public double obliczPole() {
        return Math.PI * promien * promien;
    }
}

public final class Trojkat extends KsztaltSealed {
    private final double podstawa, wysokosc;
    
    public Trojkat(double podstawa, double wysokosc) {
        this.podstawa = podstawa;
        this.wysokosc = wysokosc;
    }
    
    @Override
    public double obliczPole() {
        return 0.5 * podstawa * wysokosc;
    }
}

// Pr√≥ba stworzenia nowej klasy dziedziczƒÖcej zako≈Ñczy siƒô b≈Çƒôdem kompilacji!
// public class NowyKsztalt extends KsztaltSealed {} // B≈ÇƒÖd!
```

#### Dlaczego to wa≈ºne?

Sealed classes dajƒÖ Ci:
- **Kontrolƒô** nad hierarchiƒÖ dziedziczenia
- **Bezpiecze≈Ñstwo** - wiesz wszystkie mo≈ºliwe implementacje
- **Exhaustive pattern matching** - kompilator wie o wszystkich przypadkach
- **Lepsze API design** - jasne granice tego, co mo≈ºna rozszerzyƒá

#### Jak to dzia≈Ça w praktyce?

**Podstawowa sk≈Çadnia:**

```java
public class PodstawoweSealed {
    // Sealed class z permits
    public sealed class Pojazd permits Samochod, Rower, Motocykl {
        protected String marka;
        
        public Pojazd(String marka) {
            this.marka = marka;
        }
        
        public String getMarka() { return marka; }
        public abstract void jedz();
    }
    
    // Permitted classes muszƒÖ byƒá final, sealed lub non-sealed
    public final class Samochod extends Pojazd {
        private int liczbaDrzwi;
        
        public Samochod(String marka, int liczbaDrzwi) {
            super(marka);
            this.liczbaDrzwi = liczbaDrzwi;
        }
        
        @Override
        public void jedz() {
            System.out.println("Samoch√≥d " + marka + " jedzie po drodze");
        }
        
        public int getLiczbaDrzwi() { return liczbaDrzwi; }
    }
    
    public final class Rower extends Pojazd {
        private boolean elektryczny;
        
        public Rower(String marka, boolean elektryczny) {
            super(marka);
            this.elektryczny = elektryczny;
        }
        
        @Override
        public void jedz() {
            System.out.println("Rower " + marka + " jedzie po ≈õcie≈ºce rowerowej");
        }
        
        public boolean isElektryczny() { return elektryczny; }
    }
    
    // Non-sealed pozwala na dalsze dziedziczenie
    public non-sealed class Motocykl extends Pojazd {
        private int pojemnoscSilnika;
        
        public Motocykl(String marka, int pojemnoscSilnika) {
            super(marka);
            this.pojemnoscSilnika = pojemnoscSilnika;
        }
        
        @Override
        public void jedz() {
            System.out.println("Motocykl " + marka + " jedzie po drodze");
        }
        
        public int getPojemnoscSilnika() { return pojemnoscSilnika; }
    }
    
    // Teraz mo≈ºna dziedziczyƒá z Motocykl
    public class Skuter extends Motocykl {
        public Skuter(String marka) {
            super(marka, 125);
        }
        
        @Override
        public void jedz() {
            System.out.println("Skuter " + marka + " jedzie powoli");
        }
    }
    
    public static void main(String[] args) {
        Pojazd[] pojazdy = {
            new Samochod("Toyota", 4),
            new Rower("Giant", true),
            new Motocykl("Honda", 600),
            new Skuter("Yamaha")
        };
        
        for (Pojazd pojazd : pojazdy) {
            System.out.println("--- " + pojazd.getMarka() + " ---");
            pojazd.jedz();
        }
    }
}
```

**Sealed interfaces:**

```java
public class SealedInterfaces {
    // Sealed interface
    public sealed interface Platnosc permits KartaKredytowa, Gotowka, PrzelewBankowy {
        double getKwota();
        boolean przetworzPlatnosc();
    }
    
    public final class KartaKredytowa implements Platnosc {
        private final double kwota;
        private final String numerKarty;
        
        public KartaKredytowa(double kwota, String numerKarty) {
            this.kwota = kwota;
            this.numerKarty = numerKarty;
        }
        
        @Override
        public double getKwota() { return kwota; }
        
        @Override
        public boolean przetworzPlatnosc() {
            System.out.println("Przetwarzanie p≈Çatno≈õci kartƒÖ: " + kwota + " z≈Ç");
            // Logika p≈Çatno≈õci kartƒÖ
            return true;
        }
        
        public String getNumerKarty() { return numerKarty; }
    }
    
    public final class Gotowka implements Platnosc {
        private final double kwota;
        
        public Gotowka(double kwota) {
            this.kwota = kwota;
        }
        
        @Override
        public double getKwota() { return kwota; }
        
        @Override
        public boolean przetworzPlatnosc() {
            System.out.println("P≈Çatno≈õƒá got√≥wkƒÖ: " + kwota + " z≈Ç");
            return true;
        }
    }
    
    public final class PrzelewBankowy implements Platnosc {
        private final double kwota;
        private final String numerKonta;
        
        public PrzelewBankowy(double kwota, String numerKonta) {
            this.kwota = kwota;
            this.numerKonta = numerKonta;
        }
        
        @Override
        public double getKwota() { return kwota; }
        
        @Override
        public boolean przetworzPlatnosc() {
            System.out.println("Przelew bankowy: " + kwota + " z≈Ç na konto " + numerKonta);
            return true;
        }
        
        public String getNumerKonta() { return numerKonta; }
    }
    
    // Metoda wykorzystujƒÖca sealed interface
    public static void przetworzPlatnosci(List<Platnosc> platnosci) {
        for (Platnosc platnosc : platnosci) {
            System.out.println("Przetwarzanie p≈Çatno≈õci na kwotƒô: " + platnosc.getKwota());
            
            // Pattern matching (Java 17+)
            switch (platnosc) {
                case KartaKredytowa karta -> {
                    System.out.println("Karta ko≈Ñc√≥wka: " + 
                        karta.getNumerKarty().substring(karta.getNumerKarty().length() - 4));
                    karta.przetworzPlatnosc();
                }
                case Gotowka gotowka -> {
                    System.out.println("P≈Çatno≈õƒá got√≥wkƒÖ");
                    gotowka.przetworzPlatnosc();
                }
                case PrzelewBankowy przelew -> {
                    System.out.println("Przelew na konto: " + przelew.getNumerKonta());
                    przelew.przetworzPlatnosc();
                }
                // Nie potrzeba default - kompilator wie o wszystkich przypadkach!
            }
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        List<Platnosc> platnosci = List.of(
            new KartaKredytowa(100.0, "1234567890123456"),
            new Gotowka(50.0),
            new PrzelewBankowy(200.0, "PL12345678901234567890123456")
        );
        
        przetworzPlatnosci(platnosci);
    }
}
```

**Sealed classes z records:**

```java
public class SealedRecords {
    // Sealed interface dla event√≥w
    public sealed interface Event permits UserEvent, OrderEvent, SystemEvent {}
    
    // Sealed interface dla user events
    public sealed interface UserEvent extends Event 
        permits UserRegistered, UserLoggedIn, UserLoggedOut {}
    
    // Records implementujƒÖce sealed interfaces
    public record UserRegistered(String userId, String email, long timestamp) implements UserEvent {}
    public record UserLoggedIn(String userId, String ipAddress, long timestamp) implements UserEvent {}
    public record UserLoggedOut(String userId, long sessionDuration, long timestamp) implements UserEvent {}
    
    public sealed interface OrderEvent extends Event 
        permits OrderCreated, OrderPaid, OrderShipped, OrderDelivered {}
    
    public record OrderCreated(String orderId, String userId, double amount, long timestamp) implements OrderEvent {}
    public record OrderPaid(String orderId, String paymentMethod, long timestamp) implements OrderEvent {}
    public record OrderShipped(String orderId, String trackingNumber, long timestamp) implements OrderEvent {}
    public record OrderDelivered(String orderId, long timestamp) implements OrderEvent {}
    
    public sealed interface SystemEvent extends Event 
        permits SystemStarted, SystemStopped, SystemError {}
    
    public record SystemStarted(String version, long timestamp) implements SystemEvent {}
    public record SystemStopped(String reason, long timestamp) implements SystemEvent {}
    public record SystemError(String errorMessage, String stackTrace, long timestamp) implements SystemEvent {}
    
    // Event processor z exhaustive pattern matching
    public static class EventProcessor {
        public void processEvent(Event event) {
            switch (event) {
                // User events
                case UserRegistered(var userId, var email, var timestamp) -> 
                    System.out.println("Nowy u≈ºytkownik: " + email);
                case UserLoggedIn(var userId, var ipAddress, var timestamp) -> 
                    System.out.println("U≈ºytkownik " + userId + " zalogowa≈Ç siƒô z " + ipAddress);
                case UserLoggedOut(var userId, var sessionDuration, var timestamp) -> 
                    System.out.println("U≈ºytkownik " + userId + " wylogowa≈Ç siƒô po " + sessionDuration + "ms");
                
                // Order events
                case OrderCreated(var orderId, var userId, var amount, var timestamp) -> 
                    System.out.println("Nowe zam√≥wienie " + orderId + " na kwotƒô " + amount);
                case OrderPaid(var orderId, var paymentMethod, var timestamp) -> 
                    System.out.println("Zam√≥wienie " + orderId + " op≈Çacone przez " + paymentMethod);
                case OrderShipped(var orderId, var trackingNumber, var timestamp) -> 
                    System.out.println("Zam√≥wienie " + orderId + " wys≈Çane, tracking: " + trackingNumber);
                case OrderDelivered(var orderId, var timestamp) -> 
                    System.out.println("Zam√≥wienie " + orderId + " dostarczone");
                
                // System events
                case SystemStarted(var version, var timestamp) -> 
                    System.out.println("System uruchomiony, wersja: " + version);
                case SystemStopped(var reason, var timestamp) -> 
                    System.out.println("System zatrzymany: " + reason);
                case SystemError(var errorMessage, var stackTrace, var timestamp) -> 
                    System.out.println("B≈ÇƒÖd systemu: " + errorMessage);
                
                // Kompilator gwarantuje exhaustiveness - nie potrzeba default!
            }
        }
        
        public void processUserEvents(List<UserEvent> userEvents) {
            for (UserEvent event : userEvents) {
                switch (event) {
                    case UserRegistered(var userId, var email, var timestamp) -> {
                        System.out.println("Wysy≈Çanie email powitalnego do: " + email);
                        // Logika wysy≈Çania emaila
                    }
                    case UserLoggedIn(var userId, var ipAddress, var timestamp) -> {
                        System.out.println("Aktualizacja ostatniego logowania dla: " + userId);
                        // Logika aktualizacji
                    }
                    case UserLoggedOut(var userId, var sessionDuration, var timestamp) -> {
                        System.out.println("Zapisywanie statystyk sesji dla: " + userId);
                        // Logika zapisywania statystyk
                    }
                }
            }
        }
    }
    
    public static void main(String[] args) {
        EventProcessor processor = new EventProcessor();
        
        List<Event> events = List.of(
            new UserRegistered("user123", "anna@example.com", System.currentTimeMillis()),
            new OrderCreated("order456", "user123", 99.99, System.currentTimeMillis()),
            new SystemStarted("1.0.0", System.currentTimeMillis()),
            new UserLoggedIn("user123", "192.168.1.1", System.currentTimeMillis()),
            new OrderPaid("order456", "karta kredytowa", System.currentTimeMillis())
        );
        
        System.out.println("=== Przetwarzanie wszystkich event√≥w ===");
        for (Event event : events) {
            processor.processEvent(event);
        }
        
        System.out.println("\n=== Przetwarzanie tylko user event√≥w ===");
        List<UserEvent> userEvents = events.stream()
            .filter(event -> event instanceof UserEvent)
            .map(event -> (UserEvent) event)
            .collect(Collectors.toList());
        
        processor.processUserEvents(userEvents);
    }
}
```

**Praktyczne zastosowania:**

```java
public class PraktyczneSealedClasses {
    // State machine z sealed classes
    public sealed interface ConnectionState 
        permits Disconnected, Connecting, Connected, Error {
        
        default String getDisplayName() {
            return switch (this) {
                case Disconnected() -> "Roz≈ÇƒÖczony";
                case Connecting() -> "≈ÅƒÖczenie...";
                case Connected(var serverName) -> "Po≈ÇƒÖczony z " + serverName;
                case Error(var message) -> "B≈ÇƒÖd: " + message;
            };
        }
    }
    
    public record Disconnected() implements ConnectionState {}
    public record Connecting() implements ConnectionState {}
    public record Connected(String serverName) implements ConnectionState {}
    public record Error(String message) implements ConnectionState {}
    
    public static class ConnectionManager {
        private ConnectionState currentState = new Disconnected();
        
        public void connect(String serverName) {
            currentState = switch (currentState) {
                case Disconnected() -> {
                    System.out.println("Rozpoczynam ≈ÇƒÖczenie z " + serverName);
                    yield new Connecting();
                }
                case Connecting() -> {
                    System.out.println("Ju≈º trwa ≈ÇƒÖczenie");
                    yield currentState;
                }
                case Connected(var current) -> {
                    System.out.println("Ju≈º po≈ÇƒÖczony z " + current);
                    yield currentState;
                }
                case Error(var message) -> {
                    System.out.println("Pr√≥ba ponownego ≈ÇƒÖczenia po b≈Çƒôdzie: " + message);
                    yield new Connecting();
                }
            };
        }
        
        public void finishConnection(String serverName) {
            currentState = switch (currentState) {
                case Connecting() -> {
                    System.out.println("Po≈ÇƒÖczenie z " + serverName + " zako≈Ñczone sukcesem");
                    yield new Connected(serverName);
                }
                case Disconnected(), Connected(var current), Error(var message) -> {
                    System.out.println("Nie mo≈ºna zako≈Ñczyƒá po≈ÇƒÖczenia w stanie: " + currentState.getDisplayName());
                    yield currentState;
                }
            };
        }
        
        public void disconnect() {
            currentState = switch (currentState) {
                case Connected(var serverName) -> {
                    System.out.println("Roz≈ÇƒÖczanie z " + serverName);
                    yield new Disconnected();
                }
                case Connecting() -> {
                    System.out.println("Anulowanie ≈ÇƒÖczenia");
                    yield new Disconnected();
                }
                case Disconnected() -> {
                    System.out.println("Ju≈º roz≈ÇƒÖczony");
                    yield currentState;
                }
                case Error(var message) -> {
                    System.out.println("Roz≈ÇƒÖczanie po b≈Çƒôdzie");
                    yield new Disconnected();
                }
            };
        }
        
        public void error(String message) {
            currentState = new Error(message);
            System.out.println("WystƒÖpi≈Ç b≈ÇƒÖd: " + message);
        }
        
        public ConnectionState getCurrentState() {
            return currentState;
        }
        
        public void printStatus() {
            System.out.println("Status po≈ÇƒÖczenia: " + currentState.getDisplayName());
        }
    }
    
    // Result type z sealed classes
    public sealed interface Result<T> permits Success, Failure {
        static <T> Result<T> success(T value) {
            return new Success<>(value);
        }
        
        static <T> Result<T> failure(String error) {
            return new Failure<>(error);
        }
        
        default boolean isSuccess() {
            return this instanceof Success;
        }
        
        default boolean isFailure() {
            return this instanceof Failure;
        }
        
        default T getValue() {
            return switch (this) {
                case Success<T>(var value) -> value;
                case Failure<T>(var error) -> throw new RuntimeException("Result is failure: " + error);
            };
        }
        
        default String getError() {
            return switch (this) {
                case Success<T>(var value) -> throw new RuntimeException("Result is success");
                case Failure<T>(var error) -> error;
            };
        }
        
        default <U> Result<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Success<T>(var value) -> Result.success(mapper.apply(value));
                case Failure<T>(var error) -> Result.failure(error);
            };
        }
        
        default <U> Result<U> flatMap(Function<T, Result<U>> mapper) {
            return switch (this) {
                case Success<T>(var value) -> mapper.apply(value);
                case Failure<T>(var error) -> Result.failure(error);
            };
        }
    }
    
    public record Success<T>(T value) implements Result<T> {}
    public record Failure<T>(String error) implements Result<T> {}
    
    // Service u≈ºywajƒÖcy Result
    public static class UserService {
        private final Map<String, String> users = Map.of(
            "1", "Anna",
            "2", "Kasia",
            "3", "Ola"
        );
        
        public Result<String> findUser(String id) {
            if (id == null || id.trim().isEmpty()) {
                return Result.failure("ID u≈ºytkownika nie mo≈ºe byƒá puste");
            }
            
            String user = users.get(id);
            if (user != null) {
                return Result.success(user);
            } else {
                return Result.failure("U≈ºytkownik o ID " + id + " nie istnieje");
            }
        }
        
        public Result<String> getUserDisplayName(String id) {
            return findUser(id)
                .map(name -> "U≈ºytkownik: " + name)
                .flatMap(displayName -> {
                    if (displayName.length() > 50) {
                        return Result.failure("Nazwa wy≈õwietlana jest za d≈Çuga");
                    }
                    return Result.success(displayName);
                });
        }
    }
    
    public static void main(String[] args) {
        // Test connection manager
        System.out.println("=== Test Connection Manager ===");
        ConnectionManager manager = new ConnectionManager();
        
        manager.printStatus();
        manager.connect("server1.example.com");
        manager.printStatus();
        manager.finishConnection("server1.example.com");
        manager.printStatus();
        manager.error("Utrata po≈ÇƒÖczenia");
        manager.printStatus();
        manager.disconnect();
        manager.printStatus();
        
        System.out.println("\n=== Test Result Type ===");
        UserService userService = new UserService();
        
        String[] userIds = {"1", "2", "999", "", null};
        
        for (String id : userIds) {
            Result<String> result = userService.getUserDisplayName(id);
            
            switch (result) {
                case Success<String>(var displayName) -> 
                    System.out.println("Sukces: " + displayName);
                case Failure<String>(var error) -> 
                    System.out.println("B≈ÇƒÖd: " + error);
            }
        }
    }
}
```

#### Pu≈Çapki, na kt√≥re warto uwa≈ºaƒá

**Pu≈Çapka 1: Zapomnienie o permits**

```java
// ≈πLE - brak permits
public sealed class BadSealed {
    // Kompilator nie wie, kt√≥re klasy mogƒÖ dziedziczyƒá
}

// DOBRZE - z permits
public sealed class GoodSealed permits Child1, Child2 {
    // Jasno okre≈õlone permitted classes
}

public final class Child1 extends GoodSealed {}
public final class Child2 extends GoodSealed {}
```

**Pu≈Çapka 2: Nieprawid≈Çowe modyfikatory w permitted classes**

```java
public sealed class Parent permits Child {}

// ≈πLE - permitted class musi byƒá final, sealed lub non-sealed
public class Child extends Parent {}  // B≈ÇƒÖd kompilacji!

// DOBRZE - jedna z trzech opcji
public final class Child extends Parent {}
// LUB
public sealed class Child extends Parent permits GrandChild {}
// LUB
public non-sealed class Child extends Parent {}
```

**Pu≈Çapka 3: Sealed classes w r√≥≈ºnych pakietach**

```java
// Sealed class i jej permitted classes muszƒÖ byƒá w tym samym module
// lub w tym samym pakiecie (je≈õli nie u≈ºywasz modu≈Ç√≥w)

package com.example.shapes;

public sealed class Shape permits Circle, Rectangle {
    // Circle i Rectangle muszƒÖ byƒá w pakiecie com.example.shapes
}
```

#### üí° Wskaz√≥wki dla Juniorek

- **U≈ºywaj sealed classes** gdy chcesz kontrolowaƒá hierarchiƒô
- **Pattern matching** z sealed classes jest exhaustive
- **Records + sealed interfaces** = potƒô≈ºna kombinacja
- **Permitted classes** muszƒÖ byƒá final, sealed lub non-sealed
- **Wszystkie w tym samym pakiecie** (lub module)

#### üéØ Zadania dla Juniorek

**Zadanie 1:** Stw√≥rz sealed interface dla r√≥≈ºnych typ√≥w notyfikacji (Email, SMS, Push) z pattern matching.

**Zadanie 2:** Zaprojektuj system stan√≥w zam√≥wienia u≈ºywajƒÖc sealed classes i state machine.

**Zadanie 3:** Zaimplementuj calculator z sealed interface dla operacji matematycznych.

#### ‚ùì Pytania Kontrolne - Poziom Junior

1. Jakie sƒÖ trzy mo≈ºliwe modyfikatory dla permitted classes?
2. Dlaczego sealed classes sƒÖ przydatne w pattern matching?
3. Gdzie muszƒÖ znajdowaƒá siƒô permitted classes wzglƒôdem sealed class?

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### G≈Çƒôbsza analiza tematu

Sealed classes to nie tylko ograniczenie dziedziczenia - to narzƒôdzie do tworzenia type-safe domain models, algebraic data types i zaawansowanych wzorc√≥w funkcyjnych w Javie. Przyjrzyjmy siƒô zaawansowanym zastosowaniom i wzorcom.

##### Algebraic Data Types w Javie

```java
// Sum types (tagged unions) z sealed classes
public class AlgebraicDataTypes {
    // Option type - alternatywa dla Optional
    public sealed interface Option<T> permits Some, None {
        static <T> Option<T> some(T value) {
            return new Some<>(value);
        }
        
        static <T> Option<T> none() {
            return new None<>();
        }
        
        default boolean isSome() {
            return this instanceof Some;
        }
        
        default boolean isNone() {
            return this instanceof None;
        }
        
        default T get() {
            return switch (this) {
                case Some<T>(var value) -> value;
                case None<T>() -> throw new NoSuchElementException("Option is None");
            };
        }
        
        default T getOrElse(T defaultValue) {
            return switch (this) {
                case Some<T>(var value) -> value;
                case None<T>() -> defaultValue;
            };
        }
        
        default <U> Option<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Some<T>(var value) -> Option.some(mapper.apply(value));
                case None<T>() -> Option.none();
            };
        }
        
        default <U> Option<U> flatMap(Function<T, Option<U>> mapper) {
            return switch (this) {
                case Some<T>(var value) -> mapper.apply(value);
                case None<T>() -> Option.none();
            };
        }
        
        default Option<T> filter(Predicate<T> predicate) {
            return switch (this) {
                case Some<T>(var value) when predicate.test(value) -> this;
                case Some<T>(var value) -> Option.none();
                case None<T>() -> this;
            };
        }
        
        default void ifSome(Consumer<T> action) {
            switch (this) {
                case Some<T>(var value) -> action.accept(value);
                case None<T>() -> {}
            }
        }
        
        default void ifSomeOrElse(Consumer<T> action, Runnable emptyAction) {
            switch (this) {
                case Some<T>(var value) -> action.accept(value);
                case None<T>() -> emptyAction.run();
            }
        }
    }
    
    public record Some<T>(T value) implements Option<T> {}
    public record None<T>() implements Option<T> {}
    
    // Either type - dla error handling
    public sealed interface Either<L, R> permits Left, Right {
        static <L, R> Either<L, R> left(L value) {
            return new Left<>(value);
        }
        
        static <L, R> Either<L, R> right(R value) {
            return new Right<>(value);
        }
        
        default boolean isLeft() {
            return this instanceof Left;
        }
        
        default boolean isRight() {
            return this instanceof Right;
        }
        
        default L getLeft() {
            return switch (this) {
                case Left<L, R>(var value) -> value;
                case Right<L, R>(var value) -> throw new NoSuchElementException("Either is Right");
            };
        }
        
        default R getRight() {
            return switch (this) {
                case Left<L, R>(var value) -> throw new NoSuchElementException("Either is Left");
                case Right<L, R>(var value) -> value;
            };
        }
        
        default <U> Either<L, U> map(Function<R, U> mapper) {
            return switch (this) {
                case Left<L, R>(var value) -> Either.left(value);
                case Right<L, R>(var value) -> Either.right(mapper.apply(value));
            };
        }
        
        default <U> Either<U, R> mapLeft(Function<L, U> mapper) {
            return switch (this) {
                case Left<L, R>(var value) -> Either.left(mapper.apply(value));
                case Right<L, R>(var value) -> Either.right(value);
            };
        }
        
        default <U> Either<L, U> flatMap(Function<R, Either<L, U>> mapper) {
            return switch (this) {
                case Left<L, R>(var value) -> Either.left(value);
                case Right<L, R>(var value) -> mapper.apply(value);
            };
        }
        
        default R getOrElse(R defaultValue) {
            return switch (this) {
                case Left<L, R>(var value) -> defaultValue;
                case Right<L, R>(var value) -> value;
            };
        }
        
        default R getOrElse(Function<L, R> defaultMapper) {
            return switch (this) {
                case Left<L, R>(var value) -> defaultMapper.apply(value);
                case Right<L, R>(var value) -> value;
            };
        }
    }
    
    public record Left<L, R>(L value) implements Either<L, R> {}
    public record Right<L, R>(R value) implements Either<L, R> {}
    
    // List type - immutable linked list
    public sealed interface ImmutableList<T> permits Nil, Cons {
        static <T> ImmutableList<T> nil() {
            return new Nil<>();
        }
        
        static <T> ImmutableList<T> cons(T head, ImmutableList<T> tail) {
            return new Cons<>(head, tail);
        }
        
        static <T> ImmutableList<T> of(T... elements) {
            ImmutableList<T> result = nil();
            for (int i = elements.length - 1; i >= 0; i--) {
                result = cons(elements[i], result);
            }
            return result;
        }
        
        default boolean isEmpty() {
            return this instanceof Nil;
        }
        
        default boolean nonEmpty() {
            return this instanceof Cons;
        }
        
        default T head() {
            return switch (this) {
                case Nil<T>() -> throw new NoSuchElementException("Empty list");
                case Cons<T>(var head, var tail) -> head;
            };
        }
        
        default ImmutableList<T> tail() {
            return switch (this) {
                case Nil<T>() -> throw new NoSuchElementException("Empty list");
                case Cons<T>(var head, var tail) -> tail;
            };
        }
        
        default int size() {
            return switch (this) {
                case Nil<T>() -> 0;
                case Cons<T>(var head, var tail) -> 1 + tail.size();
            };
        }
        
        default <U> ImmutableList<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Nil<T>() -> nil();
                case Cons<T>(var head, var tail) -> cons(mapper.apply(head), tail.map(mapper));
            };
        }
        
        default ImmutableList<T> filter(Predicate<T> predicate) {
            return switch (this) {
                case Nil<T>() -> nil();
                case Cons<T>(var head, var tail) when predicate.test(head) -> 
                    cons(head, tail.filter(predicate));
                case Cons<T>(var head, var tail) -> tail.filter(predicate);
            };
        }
        
        default <U> U foldLeft(U initial, BiFunction<U, T, U> folder) {
            return switch (this) {
                case Nil<T>() -> initial;
                case Cons<T>(var head, var tail) -> tail.foldLeft(folder.apply(initial, head), folder);
            };
        }
        
        default <U> U foldRight(U initial, BiFunction<T, U, U> folder) {
            return switch (this) {
                case Nil<T>() -> initial;
                case Cons<T>(var head, var tail) -> folder.apply(head, tail.foldRight(initial, folder));
            };
        }
        
        default ImmutableList<T> reverse() {
            return foldLeft(nil(), (acc, elem) -> cons(elem, acc));
        }
        
        default ImmutableList<T> append(ImmutableList<T> other) {
            return switch (this) {
                case Nil<T>() -> other;
                case Cons<T>(var head, var tail) -> cons(head, tail.append(other));
            };
        }
        
        default java.util.List<T> toJavaList() {
            return foldRight(new ArrayList<>(), (elem, acc) -> {
                acc.add(0, elem);
                return acc;
            });
        }
    }
    
    public record Nil<T>() implements ImmutableList<T> {}
    public record Cons<T>(T head, ImmutableList<T> tail) implements ImmutableList<T> {}
    
    // Tree type
    public sealed interface Tree<T> permits Leaf, Branch {
        static <T> Tree<T> leaf(T value) {
            return new Leaf<>(value);
        }
        
        static <T> Tree<T> branch(Tree<T> left, Tree<T> right) {
            return new Branch<>(left, right);
        }
        
        default int size() {
            return switch (this) {
                case Leaf<T>(var value) -> 1;
                case Branch<T>(var left, var right) -> left.size() + right.size();
            };
        }
        
        default int depth() {
            return switch (this) {
                case Leaf<T>(var value) -> 1;
                case Branch<T>(var left, var right) -> 1 + Math.max(left.depth(), right.depth());
            };
        }
        
        default <U> Tree<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Leaf<T>(var value) -> Tree.leaf(mapper.apply(value));
                case Branch<T>(var left, var right) -> Tree.branch(left.map(mapper), right.map(mapper));
            };
        }
        
        default ImmutableList<T> toList() {
            return switch (this) {
                case Leaf<T>(var value) -> ImmutableList.of(value);
                case Branch<T>(var left, var right) -> left.toList().append(right.toList());
            };
        }
        
        default <U> U fold(Function<T, U> leafFolder, BiFunction<U, U, U> branchFolder) {
            return switch (this) {
                case Leaf<T>(var value) -> leafFolder.apply(value);
                case Branch<T>(var left, var right) -> 
                    branchFolder.apply(left.fold(leafFolder, branchFolder), 
                                     right.fold(leafFolder, branchFolder));
            };
        }
    }
    
    public record Leaf<T>(T value) implements Tree<T> {}
    public record Branch<T>(Tree<T> left, Tree<T> right) implements Tree<T> {}
}
```

##### Domain Modeling z sealed classes

```java
public class DomainModeling {
    // E-commerce domain model
    public sealed interface OrderStatus permits Pending, Confirmed, Shipped, Delivered, Cancelled {
        default boolean canTransitionTo(OrderStatus newStatus) {
            return switch (this) {
                case Pending() -> newStatus instanceof Confirmed || newStatus instanceof Cancelled;
                case Confirmed() -> newStatus instanceof Shipped || newStatus instanceof Cancelled;
                case Shipped() -> newStatus instanceof Delivered;
                case Delivered(), Cancelled() -> false;
            };
        }
        
        default String getDisplayName() {
            return switch (this) {
                case Pending() -> "OczekujƒÖce";
                case Confirmed() -> "Potwierdzone";
                case Shipped() -> "Wys≈Çane";
                case Delivered() -> "Dostarczone";
                case Cancelled(var reason) -> "Anulowane: " + reason;
            };
        }
    }
    
    public record Pending() implements OrderStatus {}
    public record Confirmed() implements OrderStatus {}
    public record Shipped() implements OrderStatus {}
    public record Delivered() implements OrderStatus {}
    public record Cancelled(String reason) implements OrderStatus {}
    
    // Payment domain model
    public sealed interface PaymentMethod permits CreditCard, DebitCard, PayPal, BankTransfer, Cash {
        double calculateFee(double amount);
        boolean requiresVerification();
        
        default String getDisplayName() {
            return switch (this) {
                case CreditCard(var number, var expiryDate) -> "Karta kredytowa ****" + number.substring(number.length() - 4);
                case DebitCard(var number, var expiryDate) -> "Karta debetowa ****" + number.substring(number.length() - 4);
                case PayPal(var email) -> "PayPal (" + email + ")";
                case BankTransfer(var accountNumber) -> "Przelew bankowy (" + accountNumber + ")";
                case Cash() -> "Got√≥wka";
            };
        }
    }
    
    public record CreditCard(String number, String expiryDate) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return amount * 0.029; // 2.9% fee
        }
        
        @Override
        public boolean requiresVerification() {
            return true;
        }
    }
    
    public record DebitCard(String number, String expiryDate) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return amount * 0.015; // 1.5% fee
        }
        
        @Override
        public boolean requiresVerification() {
            return true;
        }
    }
    
    public record PayPal(String email) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return amount * 0.034 + 0.35; // 3.4% + $0.35
        }
        
        @Override
        public boolean requiresVerification() {
            return false;
        }
    }
    
    public record BankTransfer(String accountNumber) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return 2.50; // Flat fee
        }
        
        @Override
        public boolean requiresVerification() {
            return true;
        }
    }
    
    public record Cash() implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return 0.0; // No fee
        }
        
        @Override
        public boolean requiresVerification() {
            return false;
        }
    }
    
    // Order aggregate
    public static class Order {
        private final String id;
        private final String customerId;
        private final List<OrderItem> items;
        private final PaymentMethod paymentMethod;
        private OrderStatus status;
        private final LocalDateTime createdAt;
        
        public Order(String id, String customerId, List<OrderItem> items, PaymentMethod paymentMethod) {
            this.id = id;
            this.customerId = customerId;
            this.items = List.copyOf(items);
            this.paymentMethod = paymentMethod;
            this.status = new Pending();
            this.createdAt = LocalDateTime.now();
        }
        
        public void changeStatus(OrderStatus newStatus) {
            if (status.canTransitionTo(newStatus)) {
                OrderStatus oldStatus = status;
                status = newStatus;
                System.out.println("Order " + id + " status changed from " + 
                                 oldStatus.getDisplayName() + " to " + newStatus.getDisplayName());
            } else {
                throw new IllegalStateException("Cannot transition from " + 
                                              status.getDisplayName() + " to " + newStatus.getDisplayName());
            }
        }
        
        public double calculateTotal() {
            double subtotal = items.stream()
                                  .mapToDouble(item -> item.price() * item.quantity())
                                  .sum();
            double paymentFee = paymentMethod.calculateFee(subtotal);
            return subtotal + paymentFee;
        }
        
        public boolean requiresPaymentVerification() {
            return paymentMethod.requiresVerification();
        }
        
        public void processPayment() {
            switch (status) {
                case Pending() -> {
                    if (requiresPaymentVerification()) {
                        System.out.println("Payment verification required for " + paymentMethod.getDisplayName());
                    }
                    System.out.println("Processing payment of $" + calculateTotal() + 
                                     " via " + paymentMethod.getDisplayName());
                    changeStatus(new Confirmed());
                }
                default -> throw new IllegalStateException("Cannot process payment in status: " + status.getDisplayName());
            }
        }
        
        public void ship(String trackingNumber) {
            switch (status) {
                case Confirmed() -> {
                    System.out.println("Shipping order " + id + " with tracking: " + trackingNumber);
                    changeStatus(new Shipped());
                }
                default -> throw new IllegalStateException("Cannot ship order in status: " + status.getDisplayName());
            }
        }
        
        public void deliver() {
            switch (status) {
                case Shipped() -> {
                    System.out.println("Order " + id + " has been delivered");
                    changeStatus(new Delivered());
                }
                default -> throw new IllegalStateException("Cannot deliver order in status: " + status.getDisplayName());
            }
        }
        
        public void cancel(String reason) {
            switch (status) {
                case Pending(), Confirmed() -> {
                    System.out.println("Cancelling order " + id + ": " + reason);
                    changeStatus(new Cancelled(reason));
                }
                default -> throw new IllegalStateException("Cannot cancel order in status: " + status.getDisplayName());
            }
        }
        
        // Getters
        public String getId() { return id; }
        public String getCustomerId() { return customerId; }
        public List<OrderItem> getItems() { return items; }
        public PaymentMethod getPaymentMethod() { return paymentMethod; }
        public OrderStatus getStatus() { return status; }
        public LocalDateTime getCreatedAt() { return createdAt; }
    }
    
    public record OrderItem(String productId, String name, double price, int quantity) {}
}
```

##### Advanced Pattern Matching

```java
public class AdvancedPatternMatching {
    // Nested pattern matching z sealed classes
    public sealed interface Expression permits Literal, Variable, BinaryOp, UnaryOp {}
    
    public record Literal(double value) implements Expression {}
    public record Variable(String name) implements Expression {}
    public record BinaryOp(Expression left, String operator, Expression right) implements Expression {}
    public record UnaryOp(String operator, Expression operand) implements Expression {}
    
    public static class ExpressionEvaluator {
        private final Map<String, Double> variables;
        
        public ExpressionEvaluator(Map<String, Double> variables) {
            this.variables = variables;
        }
        
        public double evaluate(Expression expr) {
            return switch (expr) {
                case Literal(var value) -> value;
                case Variable(var name) -> variables.getOrDefault(name, 0.0);
                case BinaryOp(var left, var op, var right) -> switch (op) {
                    case "+" -> evaluate(left) + evaluate(right);
                    case "-" -> evaluate(left) - evaluate(right);
                    case "*" -> evaluate(left) * evaluate(right);
                    case "/" -> evaluate(left) / evaluate(right);
                    case "^" -> Math.pow(evaluate(left), evaluate(right));
                    default -> throw new IllegalArgumentException("Unknown binary operator: " + op);
                };
                case UnaryOp(var op, var operand) -> switch (op) {
                    case "-" -> -evaluate(operand);
                    case "sin" -> Math.sin(evaluate(operand));
                    case "cos" -> Math.cos(evaluate(operand));
                    case "sqrt" -> Math.sqrt(evaluate(operand));
                    default -> throw new IllegalArgumentException("Unknown unary operator: " + op);
                };
            };
        }
        
        public Expression simplify(Expression expr) {
            return switch (expr) {
                case Literal(var value) -> expr;
                case Variable(var name) -> expr;
                case BinaryOp(var left, "+", var right) -> switch (simplify(left), simplify(right)) {
                    case (Literal(var l), Literal(var r)) -> new Literal(l + r);
                    case (Literal(0.0), var r) -> r;
                    case (var l, Literal(0.0)) -> l;
                    case (var l, var r) -> new BinaryOp(l, "+", r);
                };
                case BinaryOp(var left, "*", var right) -> switch (simplify(left), simplify(right)) {
                    case (Literal(var l), Literal(var r)) -> new Literal(l * r);
                    case (Literal(0.0), var r) -> new Literal(0.0);
                    case (var l, Literal(0.0)) -> new Literal(0.0);
                    case (Literal(1.0), var r) -> r;
                    case (var l, Literal(1.0)) -> l;
                    case (var l, var r) -> new BinaryOp(l, "*", r);
                };
                case BinaryOp(var left, var op, var right) -> 
                    new BinaryOp(simplify(left), op, simplify(right));
                case UnaryOp(var op, var operand) -> switch (simplify(operand)) {
                    case Literal(var value) when op.equals("-") -> new Literal(-value);
                    case var simplified -> new UnaryOp(op, simplified);
                };
            };
        }
        
        public String toString(Expression expr) {
            return switch (expr) {
                case Literal(var value) -> String.valueOf(value);
                case Variable(var name) -> name;
                case BinaryOp(var left, var op, var right) -> 
                    "(" + toString(left) + " " + op + " " + toString(right) + ")";
                case UnaryOp(var op, var operand) -> op + "(" + toString(operand) + ")";
            };
        }
    }
    
    // Pattern matching z guards
    public sealed interface Shape permits Circle, Rectangle, Triangle {}
    
    public record Circle(double radius) implements Shape {}
    public record Rectangle(double width, double height) implements Shape {}
    public record Triangle(double a, double b, double c) implements Shape {}
    
    public static class ShapeAnalyzer {
        public double area(Shape shape) {
            return switch (shape) {
                case Circle(var r) -> Math.PI * r * r;
                case Rectangle(var w, var h) -> w * h;
                case Triangle(var a, var b, var c) -> {
                    double s = (a + b + c) / 2;
                    yield Math.sqrt(s * (s - a) * (s - b) * (s - c));
                }
            };
        }
        
        public String classify(Shape shape) {
            return switch (shape) {
                case Circle(var r) when r < 1 -> "Small circle";
                case Circle(var r) when r < 5 -> "Medium circle";
                case Circle(var r) -> "Large circle";
                case Rectangle(var w, var h) when w == h -> "Square";
                case Rectangle(var w, var h) when w > h -> "Wide rectangle";
                case Rectangle(var w, var h) -> "Tall rectangle";
                case Triangle(var a, var b, var c) when a == b && b == c -> "Equilateral triangle";
                case Triangle(var a, var b, var c) when a == b || b == c || a == c -> "Isosceles triangle";
                case Triangle(var a, var b, var c) -> "Scalene triangle";
            };
        }
        
        public boolean isValid(Shape shape) {
            return switch (shape) {
                case Circle(var r) -> r > 0;
                case Rectangle(var w, var h) -> w > 0 && h > 0;
                case Triangle(var a, var b, var c) -> 
                    a > 0 && b > 0 && c > 0 && 
                    a + b > c && b + c > a && a + c > b;
            };
        }
    }
}
```

#### üîß Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj type-safe SQL query builder u≈ºywajƒÖc sealed classes dla r√≥≈ºnych typ√≥w klauzul.

**Zadanie Zaawansowane 2:** Stw√≥rz system workflow engine z sealed classes dla stan√≥w i przej≈õƒá z validation rules.

**Zadanie Zaawansowane 3:** Zaprojektuj functional programming library z algebraic data types (Option, Either, Try) u≈ºywajƒÖc sealed classes.

#### ‚ùì Pytania Kontrolne - Poziom Senior

1. Jak sealed classes wp≈ÇywajƒÖ na exhaustiveness checking w pattern matching?
2. Jakie sƒÖ zalety u≈ºywania sealed classes w domain modeling?
3. Jak sealed classes pomagajƒÖ w implementacji algebraic data types?

---

### üîë Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public sealed interface Notification permits EmailNotification, SMSNotification, PushNotification {
    String getRecipient();
    String getMessage();
    boolean send();
    
    default String getType() {
        return switch (this) {
            case EmailNotification(var email, var subject, var body) -> "Email";
            case SMSNotification(var phoneNumber, var message) -> "SMS";
            case PushNotification(var deviceId, var title, var message) -> "Push";
        };
    }
}

public record EmailNotification(String email, String subject, String body) implements Notification {
    @Override
    public String getRecipient() { return email; }
    
    @Override
    public String getMessage() { return subject + ": " + body; }
    
    @Override
    public boolean send() {
        System.out.println("Sending email to " + email + ": " + subject);
        return true;
    }
}

public record SMSNotification(String phoneNumber, String message) implements Notification {
    @Override
    public String getRecipient() { return phoneNumber; }
    
    @Override
    public String getMessage() { return message; }
    
    @Override
    public boolean send() {
        System.out.println("Sending SMS to " + phoneNumber + ": " + message);
        return true;
    }
}

public record PushNotification(String deviceId, String title, String message) implements Notification {
    @Override
    public String getRecipient() { return deviceId; }
    
    @Override
    public String getMessage() { return title + ": " + message; }
    
    @Override
    public boolean send() {
        System.out.println("Sending push to " + deviceId + ": " + title);
        return true;
    }
}

public class NotificationService {
    public void sendNotification(Notification notification) {
        switch (notification) {
            case EmailNotification(var email, var subject, var body) -> {
                System.out.println("Preparing email infrastructure");
                notification.send();
            }
            case SMSNotification(var phone, var message) -> {
                System.out.println("Connecting to SMS gateway");
                notification.send();
            }
            case PushNotification(var deviceId, var title, var message) -> {
                System.out.println("Connecting to push service");
                notification.send();
            }
        }
    }
}
```

**Zadanie 2:**
```java
public sealed interface OrderState permits Created, PaymentPending, Paid, Shipped, Delivered, Cancelled {
    default boolean canTransitionTo(OrderState newState) {
        return switch (this) {
            case Created() -> newState instanceof PaymentPending || newState instanceof Cancelled;
            case PaymentPending() -> newState instanceof Paid || newState instanceof Cancelled;
            case Paid() -> newState instanceof Shipped || newState instanceof Cancelled;
            case Shipped() -> newState instanceof Delivered;
            case Delivered(), Cancelled(var reason) -> false;
        };
    }
}

public record Created() implements OrderState {}
public record PaymentPending() implements OrderState {}
public record Paid() implements OrderState {}
public record Shipped() implements OrderState {}
public record Delivered() implements OrderState {}
public record Cancelled(String reason) implements OrderState {}

public class OrderStateMachine {
    private final String orderId;
    private OrderState currentState;
    
    public OrderStateMachine(String orderId) {
        this.orderId = orderId;
        this.currentState = new Created();
    }
    
    public void transition(OrderState newState) {
        if (currentState.canTransitionTo(newState)) {
            OrderState oldState = currentState;
            currentState = newState;
            System.out.println("Order " + orderId + " transitioned from " + 
                             oldState.getClass().getSimpleName() + " to " + 
                             newState.getClass().getSimpleName());
        } else {
            throw new IllegalStateException("Invalid transition from " + 
                                          currentState.getClass().getSimpleName() + " to " + 
                                          newState.getClass().getSimpleName());
        }
    }
    
    public OrderState getCurrentState() {
        return currentState;
    }
}
```

**Zadanie 3:**
```java
public sealed interface Operation permits Addition, Subtraction, Multiplication, Division, Power, SquareRoot {
    double calculate(double... operands);
    int getRequiredOperands();
    
    default String getSymbol() {
        return switch (this) {
            case Addition() -> "+";
            case Subtraction() -> "-";
            case Multiplication() -> "*";
            case Division() -> "/";
            case Power() -> "^";
            case SquareRoot() -> "‚àö";
        };
    }
}

public record Addition() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Addition requires 2 operands");
        return operands[0] + operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Subtraction() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Subtraction requires 2 operands");
        return operands[0] - operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Multiplication() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Multiplication requires 2 operands");
        return operands[0] * operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Division() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Division requires 2 operands");
        if (operands[1] == 0) throw new ArithmeticException("Division by zero");
        return operands[0] / operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Power() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Power requires 2 operands");
        return Math.pow(operands[0], operands[1]);
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record SquareRoot() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 1) throw new IllegalArgumentException("Square root requires 1 operand");
        if (operands[0] < 0) throw new ArithmeticException("Square root of negative number");
        return Math.sqrt(operands[0]);
    }
    
    @Override
    public int getRequiredOperands() { return 1; }
}

public class Calculator {
    public double calculate(Operation operation, double... operands) {
        if (operands.length != operation.getRequiredOperands()) {
            throw new IllegalArgumentException("Operation " + operation.getSymbol() + 
                                             " requires " + operation.getRequiredOperands() + " operands");
        }
        
        return switch (operation) {
            case Addition() -> operation.calculate(operands);
            case Subtraction() -> operation.calculate(operands);
            case Multiplication() -> operation.calculate(operands);
            case Division() -> operation.calculate(operands);
            case Power() -> operation.calculate(operands);
            case SquareRoot() -> operation.calculate(operands);
        };
    }
}
```

**Pytania kontrolne:**
1. final (nie mo≈ºna dalej dziedziczyƒá), sealed (mo≈ºna dalej kontrolowaƒá dziedziczenie), non-sealed (otwiera dziedziczenie).
2. Kompilator wie o wszystkich mo≈ºliwych implementacjach, wiƒôc mo≈ºe sprawdziƒá czy wszystkie przypadki sƒÖ obs≈Çu≈ºone.
3. W tym samym pakiecie (lub module je≈õli u≈ºywasz modu≈Ç√≥w).

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Kompilator mo≈ºe sprawdziƒá czy wszystkie mo≈ºliwe przypadki sƒÖ obs≈Çu≈ºone w switch expressions, eliminujƒÖc potrzebƒô default case.
2. Sealed classes pozwalajƒÖ na precyzyjne modelowanie domeny z kontrolowanƒÖ hierarchiƒÖ, type safety i exhaustive pattern matching.
3. Sealed classes pozwalajƒÖ na implementacjƒô sum types (tagged unions), kt√≥re sƒÖ podstawƒÖ algebraic data types jak Option, Either, List.

---

### üìö Co dalej?

*≈öwietnie! Teraz rozumiesz pe≈ÇnƒÖ moc sealed classes - od podstawowej kontroli dziedziczenia po zaawansowane algebraic data types. Sealed classes to narzƒôdzie, kt√≥re pozwala tworzyƒá bezpieczne i przewidywalne hierarchie klas w nowoczesnej Javie. W nastƒôpnym rozdziale porozmawiamy o interfejsach - czyli jak definiowaƒá kontrakty i tworzyƒá elastyczne architektury!*

---

*üí° Pamiƒôtaj: Sealed classes to nie tylko ograniczenie - to narzƒôdzie do tworzenia bezpiecznych i przewidywalnych hierarchii. U≈ºywaj ich mƒÖdrze do modelowania domeny!*


## 16. Interfejsy ‚Äî kontrakty i elastyczno≈õƒá

*Cze≈õƒá! Dzi≈õ porozmawiamy o interfejsach - jednym z najwa≈ºniejszych narzƒôdzi w Javie. Je≈õli klasy to aktorzy, to interfejsy to scenariusze - definiujƒÖ co ma byƒá zrobione, ale nie jak. To klucz do tworzenia elastycznego, testowalnego i maintainable kodu. Od prostych kontrakt√≥w po zaawansowane functional interfaces - poka≈ºƒô Ci, jak interfejsy mogƒÖ zmieniƒá spos√≥b, w jaki my≈õlisz o programowaniu!*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Co to w≈Ça≈õciwie jest?

Interfejs to kontrakt - zestaw metod, kt√≥re klasa musi zaimplementowaƒá. To jak umowa: "je≈õli chcesz byƒá X, musisz umieƒá robiƒá Y i Z". Interfejsy pozwalajƒÖ na polimorfizm bez dziedziczenia i sƒÖ podstawƒÖ wielu wzorc√≥w projektowych.

```java
// Interfejs definiuje "co" ale nie "jak"
public interface Drawable {
    void draw();
    void move(int x, int y);
    double getArea();
}

// R√≥≈ºne klasy mogƒÖ implementowaƒá ten sam interfejs na sw√≥j spos√≥b
public class Circle implements Drawable {
    private int x, y;
    private double radius;
    
    public Circle(int x, int y, double radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Rysowanie ko≈Ça na pozycji (" + x + ", " + y + ") o promieniu " + radius);
    }
    
    @Override
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
        System.out.println("Ko≈Ço przesuniƒôte na pozycjƒô (" + x + ", " + y + ")");
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle implements Drawable {
    private int x, y;
    private double width, height;
    
    public Rectangle(int x, int y, double width, double height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        System.out.println("Rysowanie prostokƒÖta na pozycji (" + x + ", " + y + 
                          ") o wymiarach " + width + "x" + height);
    }
    
    @Override
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
        System.out.println("ProstokƒÖt przesuniƒôty na pozycjƒô (" + x + ", " + y + ")");
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
}

// U≈ºycie - polimorfizm przez interfejsy
public class DrawingApp {
    public static void main(String[] args) {
        List<Drawable> shapes = List.of(
            new Circle(10, 20, 5),
            new Rectangle(30, 40, 10, 15),
            new Circle(50, 60, 8)
        );
        
        // Jedna pƒôtla obs≈Çuguje wszystkie kszta≈Çty!
        for (Drawable shape : shapes) {
            shape.draw();
            System.out.println("Pole: " + shape.getArea());
            shape.move(100, 100);
            System.out.println();
        }
    }
}
```

#### Dlaczego to wa≈ºne?

Interfejsy dajƒÖ Ci:
- **Polimorfizm** - r√≥≈ºne implementacje tego samego kontraktu
- **Loose coupling** - kod zale≈ºy od abstrakcji, nie od konkretnych klas
- **Testowalno≈õƒá** - ≈Çatwo tworzyƒá mock objects
- **Elastyczno≈õƒá** - ≈Çatwo dodawaƒá nowe implementacje
- **Multiple inheritance** - klasa mo≈ºe implementowaƒá wiele interfejs√≥w

#### Jak to dzia≈Ça w praktyce?

**Podstawowe interfejsy:**

```java
public class PodstawoweInterfejsy {
    // Interfejs dla operacji na plikach
    public interface FileProcessor {
        boolean processFile(String filename);
        String getFileType();
        long getMaxFileSize();
    }
    
    // Implementacja dla plik√≥w tekstowych
    public static class TextFileProcessor implements FileProcessor {
        @Override
        public boolean processFile(String filename) {
            System.out.println("Przetwarzanie pliku tekstowego: " + filename);
            // Logika przetwarzania plik√≥w .txt
            return true;
        }
        
        @Override
        public String getFileType() {
            return "text/plain";
        }
        
        @Override
        public long getMaxFileSize() {
            return 10 * 1024 * 1024; // 10 MB
        }
    }
    
    // Implementacja dla plik√≥w obraz√≥w
    public static class ImageFileProcessor implements FileProcessor {
        @Override
        public boolean processFile(String filename) {
            System.out.println("Przetwarzanie pliku obrazu: " + filename);
            // Logika przetwarzania plik√≥w .jpg, .png
            return true;
        }
        
        @Override
        public String getFileType() {
            return "image/*";
        }
        
        @Override
        public long getMaxFileSize() {
            return 50 * 1024 * 1024; // 50 MB
        }
    }
    
    // Serwis u≈ºywajƒÖcy interfejsu
    public static class FileService {
        private final List<FileProcessor> processors;
        
        public FileService(List<FileProcessor> processors) {
            this.processors = processors;
        }
        
        public boolean processFile(String filename, String fileType) {
            for (FileProcessor processor : processors) {
                if (processor.getFileType().equals(fileType) || 
                    processor.getFileType().endsWith("/*")) {
                    return processor.processFile(filename);
                }
            }
            System.out.println("Brak procesora dla typu: " + fileType);
            return false;
        }
        
        public void showSupportedTypes() {
            System.out.println("Obs≈Çugiwane typy plik√≥w:");
            for (FileProcessor processor : processors) {
                System.out.println("- " + processor.getFileType() + 
                                 " (max " + processor.getMaxFileSize() / (1024 * 1024) + " MB)");
            }
        }
    }
    
    public static void main(String[] args) {
        List<FileProcessor> processors = List.of(
            new TextFileProcessor(),
            new ImageFileProcessor()
        );
        
        FileService fileService = new FileService(processors);
        fileService.showSupportedTypes();
        
        fileService.processFile("document.txt", "text/plain");
        fileService.processFile("photo.jpg", "image/jpeg");
        fileService.processFile("video.mp4", "video/mp4");
    }
}
```

**Multiple inheritance przez interfejsy:**

```java
public class MultipleInheritance {
    // R√≥≈ºne interfejsy dla r√≥≈ºnych aspekt√≥w
    public interface Flyable {
        void fly();
        double getMaxAltitude();
    }
    
    public interface Swimmable {
        void swim();
        double getMaxDepth();
    }
    
    public interface Walkable {
        void walk();
        double getMaxSpeed();
    }
    
    // Klasa mo≈ºe implementowaƒá wiele interfejs√≥w
    public static class Duck implements Flyable, Swimmable, Walkable {
        private String name;
        
        public Duck(String name) {
            this.name = name;
        }
        
        @Override
        public void fly() {
            System.out.println(name + " leci nad wodƒÖ");
        }
        
        @Override
        public double getMaxAltitude() {
            return 1000; // metry
        }
        
        @Override
        public void swim() {
            System.out.println(name + " p≈Çywa po wodzie");
        }
        
        @Override
        public double getMaxDepth() {
            return 2; // metry
        }
        
        @Override
        public void walk() {
            System.out.println(name + " chodzi po ziemi");
        }
        
        @Override
        public double getMaxSpeed() {
            return 5; // km/h
        }
        
        public void showCapabilities() {
            System.out.println(name + " potrafi:");
            System.out.println("- Lataƒá do wysoko≈õci " + getMaxAltitude() + "m");
            System.out.println("- P≈Çywaƒá do g≈Çƒôboko≈õci " + getMaxDepth() + "m");
            System.out.println("- Chodziƒá z prƒôdko≈õciƒÖ " + getMaxSpeed() + " km/h");
        }
    }
    
    public static class Fish implements Swimmable {
        private String species;
        
        public Fish(String species) {
            this.species = species;
        }
        
        @Override
        public void swim() {
            System.out.println(species + " p≈Çywa w wodzie");
        }
        
        @Override
        public double getMaxDepth() {
            return 100; // metry
        }
    }
    
    public static class Bird implements Flyable, Walkable {
        private String species;
        
        public Bird(String species) {
            this.species = species;
        }
        
        @Override
        public void fly() {
            System.out.println(species + " leci w powietrzu");
        }
        
        @Override
        public double getMaxAltitude() {
            return 5000; // metry
        }
        
        @Override
        public void walk() {
            System.out.println(species + " skacze po ziemi");
        }
        
        @Override
        public double getMaxSpeed() {
            return 10; // km/h
        }
    }
    
    // Metody u≈ºywajƒÖce interfejs√≥w
    public static void makeItFly(Flyable flyable) {
        flyable.fly();
        System.out.println("Maksymalna wysoko≈õƒá: " + flyable.getMaxAltitude() + "m");
    }
    
    public static void makeItSwim(Swimmable swimmable) {
        swimmable.swim();
        System.out.println("Maksymalna g≈Çƒôboko≈õƒá: " + swimmable.getMaxDepth() + "m");
    }
    
    public static void makeItWalk(Walkable walkable) {
        walkable.walk();
        System.out.println("Maksymalna prƒôdko≈õƒá: " + walkable.getMaxSpeed() + " km/h");
    }
    
    public static void main(String[] args) {
        Duck duck = new Duck("Kaczka");
        Fish fish = new Fish("≈Åoso≈õ");
        Bird bird = new Bird("Orze≈Ç");
        
        duck.showCapabilities();
        System.out.println();
        
        // Polimorfizm przez interfejsy
        makeItFly(duck);
        makeItFly(bird);
        System.out.println();
        
        makeItSwim(duck);
        makeItSwim(fish);
        System.out.println();
        
        makeItWalk(duck);
        makeItWalk(bird);
    }
}
```

**Default methods w interfejsach (Java 8+):**

```java
public class DefaultMethods {
    // Interfejs z default methods
    public interface Logger {
        // Abstrakcyjna metoda - musi byƒá zaimplementowana
        void log(String message);
        
        // Default method - ma domy≈õlnƒÖ implementacjƒô
        default void logInfo(String message) {
            log("[INFO] " + message);
        }
        
        default void logWarning(String message) {
            log("[WARNING] " + message);
        }
        
        default void logError(String message) {
            log("[ERROR] " + message);
        }
        
        default void logDebug(String message) {
            if (isDebugEnabled()) {
                log("[DEBUG] " + message);
            }
        }
        
        // Default method mo≈ºe wywo≈Çywaƒá inne metody
        default boolean isDebugEnabled() {
            return false; // Domy≈õlnie debug wy≈ÇƒÖczony
        }
        
        // Static method w interfejsie
        static Logger createConsoleLogger() {
            return new ConsoleLogger();
        }
        
        static Logger createFileLogger(String filename) {
            return new FileLogger(filename);
        }
    }
    
    // Prosta implementacja
    public static class ConsoleLogger implements Logger {
        @Override
        public void log(String message) {
            System.out.println(message);
        }
    }
    
    // Implementacja z przes≈Çoniƒôtymi default methods
    public static class FileLogger implements Logger {
        private final String filename;
        
        public FileLogger(String filename) {
            this.filename = filename;
        }
        
        @Override
        public void log(String message) {
            System.out.println("Zapisywanie do " + filename + ": " + message);
        }
        
        // Przes≈Çaniamy default method
        @Override
        public boolean isDebugEnabled() {
            return true; // W file logger debug jest w≈ÇƒÖczony
        }
    }
    
    // Implementacja z w≈ÇasnƒÖ logikƒÖ
    public static class DatabaseLogger implements Logger {
        private final String tableName;
        
        public DatabaseLogger(String tableName) {
            this.tableName = tableName;
        }
        
        @Override
        public void log(String message) {
            System.out.println("INSERT INTO " + tableName + " (message) VALUES ('" + message + "')");
        }
        
        // Przes≈Çaniamy default method z w≈ÇasnƒÖ implementacjƒÖ
        @Override
        public void logError(String message) {
            log("[CRITICAL ERROR] " + message);
            // Dodatkowa logika dla b≈Çƒôd√≥w
            System.out.println("Wysy≈Çanie alertu do administratora");
        }
    }
    
    public static void main(String[] args) {
        // U≈ºywanie static factory methods
        Logger consoleLogger = Logger.createConsoleLogger();
        Logger fileLogger = Logger.createFileLogger("app.log");
        Logger dbLogger = new DatabaseLogger("logs");
        
        List<Logger> loggers = List.of(consoleLogger, fileLogger, dbLogger);
        
        for (Logger logger : loggers) {
            System.out.println("=== " + logger.getClass().getSimpleName() + " ===");
            logger.logInfo("Aplikacja uruchomiona");
            logger.logWarning("Niski poziom pamiƒôci");
            logger.logError("B≈ÇƒÖd po≈ÇƒÖczenia z bazƒÖ danych");
            logger.logDebug("Szczeg√≥≈Çy debugowania");
            System.out.println();
        }
    }
}
```

**Functional interfaces:**

```java
public class FunctionalInterfaces {
    // W≈Çasny functional interface
    @FunctionalInterface
    public interface Calculator {
        double calculate(double a, double b);
        
        // Default methods sƒÖ dozwolone
        default double calculateAndRound(double a, double b) {
            return Math.round(calculate(a, b) * 100.0) / 100.0;
        }
        
        // Static methods te≈º sƒÖ dozwolone
        static Calculator add() {
            return (a, b) -> a + b;
        }
        
        static Calculator subtract() {
            return (a, b) -> a - b;
        }
        
        static Calculator multiply() {
            return (a, b) -> a * b;
        }
        
        static Calculator divide() {
            return (a, b) -> {
                if (b == 0) {
                    throw new ArithmeticException("Division by zero");
                }
                return a / b;
            };
        }
    }
    
    // Functional interface dla walidacji
    @FunctionalInterface
    public interface Validator<T> {
        boolean isValid(T value);
        
        // Kombinowanie walidator√≥w
        default Validator<T> and(Validator<T> other) {
            return value -> this.isValid(value) && other.isValid(value);
        }
        
        default Validator<T> or(Validator<T> other) {
            return value -> this.isValid(value) || other.isValid(value);
        }
        
        default Validator<T> negate() {
            return value -> !this.isValid(value);
        }
        
        // Static factory methods
        static <T> Validator<T> notNull() {
            return value -> value != null;
        }
        
        static Validator<String> notEmpty() {
            return value -> value != null && !value.trim().isEmpty();
        }
        
        static Validator<String> minLength(int minLength) {
            return value -> value != null && value.length() >= minLength;
        }
        
        static Validator<String> maxLength(int maxLength) {
            return value -> value != null && value.length() <= maxLength;
        }
        
        static Validator<Integer> inRange(int min, int max) {
            return value -> value != null && value >= min && value <= max;
        }
    }
    
    // Klasa u≈ºywajƒÖca functional interfaces
    public static class MathService {
        public double performCalculation(double a, double b, Calculator calculator) {
            return calculator.calculate(a, b);
        }
        
        public List<Double> performBatchCalculation(List<Double> numbers1, 
                                                   List<Double> numbers2, 
                                                   Calculator calculator) {
            List<Double> results = new ArrayList<>();
            for (int i = 0; i < Math.min(numbers1.size(), numbers2.size()); i++) {
                results.add(calculator.calculate(numbers1.get(i), numbers2.get(i)));
            }
            return results;
        }
    }
    
    public static class ValidationService {
        public <T> boolean validate(T value, Validator<T> validator) {
            return validator.isValid(value);
        }
        
        public <T> List<T> filterValid(List<T> values, Validator<T> validator) {
            return values.stream()
                        .filter(validator::isValid)
                        .collect(Collectors.toList());
        }
        
        public List<String> validateUserInput(String name, String email, Integer age) {
            List<String> errors = new ArrayList<>();
            
            // Walidacja imienia
            Validator<String> nameValidator = Validator.<String>notNull()
                .and(Validator.notEmpty())
                .and(Validator.minLength(2))
                .and(Validator.maxLength(50));
            
            if (!nameValidator.isValid(name)) {
                errors.add("Imiƒô musi mieƒá 2-50 znak√≥w");
            }
            
            // Walidacja emaila
            Validator<String> emailValidator = Validator.<String>notNull()
                .and(Validator.notEmpty())
                .and(email -> email.contains("@"))
                .and(email -> email.contains("."));
            
            if (!emailValidator.isValid(email)) {
                errors.add("Email musi byƒá prawid≈Çowy");
            }
            
            // Walidacja wieku
            Validator<Integer> ageValidator = Validator.<Integer>notNull()
                .and(Validator.inRange(0, 150));
            
            if (!ageValidator.isValid(age)) {
                errors.add("Wiek musi byƒá w zakresie 0-150");
            }
            
            return errors;
        }
    }
    
    public static void main(String[] args) {
        MathService mathService = new MathService();
        
        // U≈ºywanie lambda expressions z functional interfaces
        System.out.println("=== Calculator Examples ===");
        System.out.println("10 + 5 = " + mathService.performCalculation(10, 5, Calculator.add()));
        System.out.println("10 - 5 = " + mathService.performCalculation(10, 5, Calculator.subtract()));
        System.out.println("10 * 5 = " + mathService.performCalculation(10, 5, Calculator.multiply()));
        System.out.println("10 / 5 = " + mathService.performCalculation(10, 5, Calculator.divide()));
        
        // W≈Çasne lambda
        Calculator power = (a, b) -> Math.pow(a, b);
        System.out.println("10 ^ 2 = " + mathService.performCalculation(10, 2, power));
        
        // Batch calculations
        List<Double> numbers1 = List.of(1.0, 2.0, 3.0, 4.0);
        List<Double> numbers2 = List.of(5.0, 6.0, 7.0, 8.0);
        List<Double> sums = mathService.performBatchCalculation(numbers1, numbers2, Calculator.add());
        System.out.println("Batch addition: " + sums);
        
        // Validation examples
        System.out.println("\n=== Validation Examples ===");
        ValidationService validationService = new ValidationService();
        
        String[] names = {"Anna", "A", "", null, "VeryLongNameThatExceedsTheMaximumLengthAllowed"};
        for (String name : names) {
            List<String> errors = validationService.validateUserInput(name, "test@example.com", 25);
            System.out.println("Name '" + name + "': " + (errors.isEmpty() ? "Valid" : errors));
        }
        
        // Filtering with validators
        List<String> emails = List.of("valid@example.com", "invalid", "", null, "another@test.org");
        Validator<String> emailValidator = Validator.<String>notNull()
            .and(Validator.notEmpty())
            .and(email -> email.contains("@"));
        
        List<String> validEmails = validationService.filterValid(emails, emailValidator);
        System.out.println("Valid emails: " + validEmails);
    }
}
```

**Interfejsy w wzorcach projektowych:**

```java
public class InterfacePatterns {
    // Strategy Pattern
    public interface PaymentStrategy {
        boolean processPayment(double amount);
        String getPaymentMethod();
        double calculateFee(double amount);
    }
    
    public static class CreditCardPayment implements PaymentStrategy {
        private String cardNumber;
        
        public CreditCardPayment(String cardNumber) {
            this.cardNumber = cardNumber;
        }
        
        @Override
        public boolean processPayment(double amount) {
            System.out.println("Przetwarzanie p≈Çatno≈õci kartƒÖ kredytowƒÖ: $" + amount);
            return true;
        }
        
        @Override
        public String getPaymentMethod() {
            return "Credit Card ****" + cardNumber.substring(cardNumber.length() - 4);
        }
        
        @Override
        public double calculateFee(double amount) {
            return amount * 0.029; // 2.9% fee
        }
    }
    
    public static class PayPalPayment implements PaymentStrategy {
        private String email;
        
        public PayPalPayment(String email) {
            this.email = email;
        }
        
        @Override
        public boolean processPayment(double amount) {
            System.out.println("Przetwarzanie p≈Çatno≈õci PayPal: $" + amount);
            return true;
        }
        
        @Override
        public String getPaymentMethod() {
            return "PayPal (" + email + ")";
        }
        
        @Override
        public double calculateFee(double amount) {
            return amount * 0.034 + 0.35; // 3.4% + $0.35
        }
    }
    
    // Observer Pattern
    public interface Observer {
        void update(String event, Object data);
    }
    
    public interface Subject {
        void addObserver(Observer observer);
        void removeObserver(Observer observer);
        void notifyObservers(String event, Object data);
    }
    
    public static class NewsAgency implements Subject {
        private List<Observer> observers = new ArrayList<>();
        private String latestNews;
        
        @Override
        public void addObserver(Observer observer) {
            observers.add(observer);
        }
        
        @Override
        public void removeObserver(Observer observer) {
            observers.remove(observer);
        }
        
        @Override
        public void notifyObservers(String event, Object data) {
            for (Observer observer : observers) {
                observer.update(event, data);
            }
        }
        
        public void publishNews(String news) {
            this.latestNews = news;
            notifyObservers("NEWS_PUBLISHED", news);
        }
    }
    
    public static class NewsChannel implements Observer {
        private String channelName;
        
        public NewsChannel(String channelName) {
            this.channelName = channelName;
        }
        
        @Override
        public void update(String event, Object data) {
            if ("NEWS_PUBLISHED".equals(event)) {
                System.out.println(channelName + " otrzyma≈Ç wiadomo≈õƒá: " + data);
            }
        }
    }
    
    // Command Pattern
    public interface Command {
        void execute();
        void undo();
        String getDescription();
    }
    
    public static class Light {
        private boolean isOn = false;
        
        public void turnOn() {
            isOn = true;
            System.out.println("≈öwiat≈Ço w≈ÇƒÖczone");
        }
        
        public void turnOff() {
            isOn = false;
            System.out.println("≈öwiat≈Ço wy≈ÇƒÖczone");
        }
        
        public boolean isOn() {
            return isOn;
        }
    }
    
    public static class LightOnCommand implements Command {
        private Light light;
        
        public LightOnCommand(Light light) {
            this.light = light;
        }
        
        @Override
        public void execute() {
            light.turnOn();
        }
        
        @Override
        public void undo() {
            light.turnOff();
        }
        
        @Override
        public String getDescription() {
            return "W≈ÇƒÖcz ≈õwiat≈Ço";
        }
    }
    
    public static class LightOffCommand implements Command {
        private Light light;
        
        public LightOffCommand(Light light) {
            this.light = light;
        }
        
        @Override
        public void execute() {
            light.turnOff();
        }
        
        @Override
        public void undo() {
            light.turnOn();
        }
        
        @Override
        public String getDescription() {
            return "Wy≈ÇƒÖcz ≈õwiat≈Ço";
        }
    }
    
    public static class RemoteControl {
        private Command[] commands = new Command[7];
        private Command lastCommand;
        
        public void setCommand(int slot, Command command) {
            commands[slot] = command;
        }
        
        public void pressButton(int slot) {
            if (commands[slot] != null) {
                commands[slot].execute();
                lastCommand = commands[slot];
            }
        }
        
        public void pressUndo() {
            if (lastCommand != null) {
                lastCommand.undo();
            }
        }
        
        public void showCommands() {
            for (int i = 0; i < commands.length; i++) {
                if (commands[i] != null) {
                    System.out.println("Slot " + i + ": " + commands[i].getDescription());
                }
            }
        }
    }
    
    public static void main(String[] args) {
        // Strategy Pattern Example
        System.out.println("=== Strategy Pattern ===");
        PaymentStrategy creditCard = new CreditCardPayment("1234567890123456");
        PaymentStrategy paypal = new PayPalPayment("user@example.com");
        
        double amount = 100.0;
        System.out.println("P≈Çatno≈õƒá: " + creditCard.getPaymentMethod());
        System.out.println("Op≈Çata: $" + creditCard.calculateFee(amount));
        creditCard.processPayment(amount);
        
        System.out.println("\nP≈Çatno≈õƒá: " + paypal.getPaymentMethod());
        System.out.println("Op≈Çata: $" + paypal.calculateFee(amount));
        paypal.processPayment(amount);
        
        // Observer Pattern Example
        System.out.println("\n=== Observer Pattern ===");
        NewsAgency agency = new NewsAgency();
        NewsChannel cnn = new NewsChannel("CNN");
        NewsChannel bbc = new NewsChannel("BBC");
        
        agency.addObserver(cnn);
        agency.addObserver(bbc);
        
        agency.publishNews("Wa≈ºne wydarzenie w ≈õwiecie technologii!");
        
        // Command Pattern Example
        System.out.println("\n=== Command Pattern ===");
        Light livingRoomLight = new Light();
        Command lightOn = new LightOnCommand(livingRoomLight);
        Command lightOff = new LightOffCommand(livingRoomLight);
        
        RemoteControl remote = new RemoteControl();
        remote.setCommand(0, lightOn);
        remote.setCommand(1, lightOff);
        
        remote.showCommands();
        remote.pressButton(0); // W≈ÇƒÖcz
        remote.pressButton(1); // Wy≈ÇƒÖcz
        remote.pressUndo();    // Cofnij (w≈ÇƒÖcz)
    }
}
```

#### Pu≈Çapki, na kt√≥re warto uwa≈ºaƒá

**Pu≈Çapka 1: Diamond problem z default methods**

```java
public interface A {
    default void method() {
        System.out.println("A");
    }
}

public interface B {
    default void method() {
        System.out.println("B");
    }
}

// ≈πLE - niejednoznaczno≈õƒá
public class C implements A, B {
    // B≈ÇƒÖd kompilacji! Kt√≥ra implementacja method()?
}

// DOBRZE - jawne rozwiƒÖzanie konfliktu
public class C implements A, B {
    @Override
    public void method() {
        A.super.method(); // Wybieramy implementacjƒô z A
        // LUB
        // B.super.method(); // Wybieramy implementacjƒô z B
        // LUB
        // System.out.println("C"); // W≈Çasna implementacja
    }
}
```

**Pu≈Çapka 2: Nadu≈ºywanie interfejs√≥w**

```java
// ≈πLE - interfejs z jednƒÖ metodƒÖ bez sensu
public interface Getter {
    String get();
}

// ≈πLE - interfejs jako marker bez metod (lepiej u≈ºyƒá adnotacji)
public interface Serializable {}

// DOBRZE - interfejs z logicznym zestawem metod
public interface Repository<T> {
    void save(T entity);
    T findById(String id);
    List<T> findAll();
    void delete(String id);
}
```

#### üí° Wskaz√≥wki dla Juniorek

- **Interfejsy definiujƒÖ kontrakt**, nie implementacjƒô
- **U≈ºywaj default methods** do ewolucji interfejs√≥w
- **Functional interfaces** + lambda = potƒôga
- **Composition over inheritance** - interfejsy pomagajƒÖ
- **Testuj przez interfejsy** - ≈Çatwiej mockowaƒá

#### üéØ Zadania dla Juniorek

**Zadanie 1:** Stw√≥rz interfejs `Sortable` z r√≥≈ºnymi strategiami sortowania (bubble, quick, merge).

**Zadanie 2:** Zaprojektuj system notyfikacji z interfejsem `NotificationSender` i r√≥≈ºnymi implementacjami.

**Zadanie 3:** Zaimplementuj prosty event bus u≈ºywajƒÖc interfejs√≥w `EventListener` i `EventPublisher`.

#### ‚ùì Pytania Kontrolne - Poziom Junior

1. Jaka jest r√≥≈ºnica miƒôdzy interfejsem a klasƒÖ abstrakcyjnƒÖ?
2. Co to sƒÖ default methods i kiedy ich u≈ºywaƒá?
3. Czym jest functional interface?

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### G≈Çƒôbsza analiza tematu

Interfejsy w Javie to nie tylko kontrakty - to fundament zaawansowanych wzorc√≥w architektonicznych, dependency injection, i functional programming. Przyjrzyjmy siƒô zaawansowanym technikom i best practices.

##### Advanced Interface Design Patterns

```java
public class AdvancedInterfacePatterns {
    // Fluent Interface Pattern
    public interface QueryBuilder {
        QueryBuilder select(String... columns);
        QueryBuilder from(String table);
        QueryBuilder where(String condition);
        QueryBuilder and(String condition);
        QueryBuilder or(String condition);
        QueryBuilder orderBy(String column);
        QueryBuilder limit(int count);
        String build();
        
        // Factory method
        static QueryBuilder create() {
            return new SQLQueryBuilder();
        }
    }
    
    public static class SQLQueryBuilder implements QueryBuilder {
        private StringBuilder query = new StringBuilder();
        private boolean hasWhere = false;
        
        @Override
        public QueryBuilder select(String... columns) {
            query.append("SELECT ").append(String.join(", ", columns));
            return this;
        }
        
        @Override
        public QueryBuilder from(String table) {
            query.append(" FROM ").append(table);
            return this;
        }
        
        @Override
        public QueryBuilder where(String condition) {
            query.append(" WHERE ").append(condition);
            hasWhere = true;
            return this;
        }
        
        @Override
        public QueryBuilder and(String condition) {
            if (!hasWhere) {
                throw new IllegalStateException("Cannot use AND without WHERE");
            }
            query.append(" AND ").append(condition);
            return this;
        }
        
        @Override
        public QueryBuilder or(String condition) {
            if (!hasWhere) {
                throw new IllegalStateException("Cannot use OR without WHERE");
            }
            query.append(" OR ").append(condition);
            return this;
        }
        
        @Override
        public QueryBuilder orderBy(String column) {
            query.append(" ORDER BY ").append(column);
            return this;
        }
        
        @Override
        public QueryBuilder limit(int count) {
            query.append(" LIMIT ").append(count);
            return this;
        }
        
        @Override
        public String build() {
            return query.toString();
        }
    }
    
    // Type-safe Builder Pattern z interfejsami
    public interface UserBuilder {
        UserBuilderWithName name(String name);
    }
    
    public interface UserBuilderWithName {
        UserBuilderWithEmail email(String email);
    }
    
    public interface UserBuilderWithEmail {
        UserBuilderComplete age(int age);
        UserBuilderComplete city(String city);
        User build();
    }
    
    public interface UserBuilderComplete {
        UserBuilderComplete age(int age);
        UserBuilderComplete city(String city);
        User build();
    }
    
    public static class User {
        private final String name;
        private final String email;
        private final int age;
        private final String city;
        
        private User(String name, String email, int age, String city) {
            this.name = name;
            this.email = email;
            this.age = age;
            this.city = city;
        }
        
        public static UserBuilder builder() {
            return new UserBuilderImpl();
        }
        
        // Getters
        public String getName() { return name; }
        public String getEmail() { return email; }
        public int getAge() { return age; }
        public String getCity() { return city; }
        
        @Override
        public String toString() {
            return "User{name='" + name + "', email='" + email + 
                   "', age=" + age + ", city='" + city + "'}";
        }
        
        private static class UserBuilderImpl implements UserBuilder, UserBuilderWithName, 
                                                       UserBuilderWithEmail, UserBuilderComplete {
            private String name;
            private String email;
            private int age = 0;
            private String city = "";
            
            @Override
            public UserBuilderWithName name(String name) {
                this.name = name;
                return this;
            }
            
            @Override
            public UserBuilderWithEmail email(String email) {
                this.email = email;
                return this;
            }
            
            @Override
            public UserBuilderComplete age(int age) {
                this.age = age;
                return this;
            }
            
            @Override
            public UserBuilderComplete city(String city) {
                this.city = city;
                return this;
            }
            
            @Override
            public User build() {
                return new User(name, email, age, city);
            }
        }
    }
    
    // Visitor Pattern z interfejsami
    public interface Visitor<T> {
        T visitNumber(NumberExpression expr);
        T visitAddition(AdditionExpression expr);
        T visitMultiplication(MultiplicationExpression expr);
    }
    
    public interface Expression {
        <T> T accept(Visitor<T> visitor);
    }
    
    public static class NumberExpression implements Expression {
        private final double value;
        
        public NumberExpression(double value) {
            this.value = value;
        }
        
        public double getValue() { return value; }
        
        @Override
        public <T> T accept(Visitor<T> visitor) {
            return visitor.visitNumber(this);
        }
    }
    
    public static class AdditionExpression implements Expression {
        private final Expression left, right;
        
        public AdditionExpression(Expression left, Expression right) {
            this.left = left;
            this.right = right;
        }
        
        public Expression getLeft() { return left; }
        public Expression getRight() { return right; }
        
        @Override
        public <T> T accept(Visitor<T> visitor) {
            return visitor.visitAddition(this);
        }
    }
    
    public static class MultiplicationExpression implements Expression {
        private final Expression left, right;
        
        public MultiplicationExpression(Expression left, Expression right) {
            this.left = left;
            this.right = right;
        }
        
        public Expression getLeft() { return left; }
        public Expression getRight() { return right; }
        
        @Override
        public <T> T accept(Visitor<T> visitor) {
            return visitor.visitMultiplication(this);
        }
    }
    
    public static class EvaluationVisitor implements Visitor<Double> {
        @Override
        public Double visitNumber(NumberExpression expr) {
            return expr.getValue();
        }
        
        @Override
        public Double visitAddition(AdditionExpression expr) {
            return expr.getLeft().accept(this) + expr.getRight().accept(this);
        }
        
        @Override
        public Double visitMultiplication(MultiplicationExpression expr) {
            return expr.getLeft().accept(this) * expr.getRight().accept(this);
        }
    }
    
    public static class PrintVisitor implements Visitor<String> {
        @Override
        public String visitNumber(NumberExpression expr) {
            return String.valueOf(expr.getValue());
        }
        
        @Override
        public String visitAddition(AdditionExpression expr) {
            return "(" + expr.getLeft().accept(this) + " + " + expr.getRight().accept(this) + ")";
        }
        
        @Override
        public String visitMultiplication(MultiplicationExpression expr) {
            return "(" + expr.getLeft().accept(this) + " * " + expr.getRight().accept(this) + ")";
        }
    }
}
```

##### Dependency Injection z interfejsami

```java
public class DependencyInjectionPatterns {
    // Service interfaces
    public interface UserRepository {
        User findById(String id);
        void save(User user);
        List<User> findAll();
        void delete(String id);
    }
    
    public interface EmailService {
        void sendEmail(String to, String subject, String body);
        void sendWelcomeEmail(User user);
    }
    
    public interface Logger {
        void info(String message);
        void error(String message, Throwable throwable);
        void debug(String message);
    }
    
    // Implementations
    public static class DatabaseUserRepository implements UserRepository {
        private final Logger logger;
        private final Map<String, User> database = new HashMap<>();
        
        public DatabaseUserRepository(Logger logger) {
            this.logger = logger;
        }
        
        @Override
        public User findById(String id) {
            logger.debug("Finding user by id: " + id);
            return database.get(id);
        }
        
        @Override
        public void save(User user) {
            logger.info("Saving user: " + user.getName());
            database.put(user.getId(), user);
        }
        
        @Override
        public List<User> findAll() {
            logger.debug("Finding all users");
            return new ArrayList<>(database.values());
        }
        
        @Override
        public void delete(String id) {
            logger.info("Deleting user: " + id);
            database.remove(id);
        }
    }
    
    public static class SMTPEmailService implements EmailService {
        private final Logger logger;
        
        public SMTPEmailService(Logger logger) {
            this.logger = logger;
        }
        
        @Override
        public void sendEmail(String to, String subject, String body) {
            logger.info("Sending email to: " + to);
            System.out.println("SMTP: Sending email to " + to);
            System.out.println("Subject: " + subject);
            System.out.println("Body: " + body);
        }
        
        @Override
        public void sendWelcomeEmail(User user) {
            sendEmail(user.getEmail(), "Welcome!", "Welcome to our platform, " + user.getName() + "!");
        }
    }
    
    public static class ConsoleLogger implements Logger {
        @Override
        public void info(String message) {
            System.out.println("[INFO] " + message);
        }
        
        @Override
        public void error(String message, Throwable throwable) {
            System.out.println("[ERROR] " + message);
            if (throwable != null) {
                throwable.printStackTrace();
            }
        }
        
        @Override
        public void debug(String message) {
            System.out.println("[DEBUG] " + message);
        }
    }
    
    // Service layer
    public static class UserService {
        private final UserRepository userRepository;
        private final EmailService emailService;
        private final Logger logger;
        
        // Constructor injection
        public UserService(UserRepository userRepository, EmailService emailService, Logger logger) {
            this.userRepository = userRepository;
            this.emailService = emailService;
            this.logger = logger;
        }
        
        public User createUser(String name, String email) {
            try {
                logger.info("Creating new user: " + name);
                
                User user = new User(generateId(), name, email);
                userRepository.save(user);
                emailService.sendWelcomeEmail(user);
                
                logger.info("User created successfully: " + user.getId());
                return user;
            } catch (Exception e) {
                logger.error("Failed to create user: " + name, e);
                throw e;
            }
        }
        
        public User getUser(String id) {
            logger.debug("Getting user: " + id);
            User user = userRepository.findById(id);
            if (user == null) {
                logger.error("User not found: " + id, null);
                throw new RuntimeException("User not found: " + id);
            }
            return user;
        }
        
        public List<User> getAllUsers() {
            logger.debug("Getting all users");
            return userRepository.findAll();
        }
        
        public void deleteUser(String id) {
            logger.info("Deleting user: " + id);
            User user = getUser(id); // Sprawdza czy istnieje
            userRepository.delete(id);
            logger.info("User deleted: " + id);
        }
        
        private String generateId() {
            return "user_" + System.currentTimeMillis();
        }
    }
    
    // Simple DI Container
    public static class DIContainer {
        private final Map<Class<?>, Object> services = new HashMap<>();
        private final Map<Class<?>, Supplier<?>> factories = new HashMap<>();
        
        public <T> void registerSingleton(Class<T> serviceClass, T instance) {
            services.put(serviceClass, instance);
        }
        
        public <T> void registerFactory(Class<T> serviceClass, Supplier<T> factory) {
            factories.put(serviceClass, factory);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T get(Class<T> serviceClass) {
            // Check for singleton
            T service = (T) services.get(serviceClass);
            if (service != null) {
                return service;
            }
            
            // Check for factory
            Supplier<T> factory = (Supplier<T>) factories.get(serviceClass);
            if (factory != null) {
                return factory.get();
            }
            
            throw new RuntimeException("Service not registered: " + serviceClass.getName());
        }
        
        public void configure() {
            // Register singletons
            Logger logger = new ConsoleLogger();
            registerSingleton(Logger.class, logger);
            
            // Register factories
            registerFactory(UserRepository.class, () -> new DatabaseUserRepository(get(Logger.class)));
            registerFactory(EmailService.class, () -> new SMTPEmailService(get(Logger.class)));
            registerFactory(UserService.class, () -> new UserService(
                get(UserRepository.class),
                get(EmailService.class),
                get(Logger.class)
            ));
        }
    }
    
    // User entity
    public static class User {
        private final String id;
        private final String name;
        private final String email;
        
        public User(String id, String name, String email) {
            this.id = id;
            this.name = name;
            this.email = email;
        }
        
        public String getId() { return id; }
        public String getName() { return name; }
        public String getEmail() { return email; }
        
        @Override
        public String toString() {
            return "User{id='" + id + "', name='" + name + "', email='" + email + "'}";
        }
    }
}
```

##### Advanced Functional Interfaces

```java
public class AdvancedFunctionalInterfaces {
    // Custom functional interfaces for specific domains
    @FunctionalInterface
    public interface Transformer<T, R> {
        R transform(T input) throws Exception;
        
        default <V> Transformer<T, V> andThen(Transformer<R, V> after) {
            return input -> after.transform(this.transform(input));
        }
        
        default <V> Transformer<V, R> compose(Transformer<V, T> before) {
            return input -> this.transform(before.transform(input));
        }
        
        static <T> Transformer<T, T> identity() {
            return input -> input;
        }
        
        static <T, R> Transformer<T, R> constant(R value) {
            return input -> value;
        }
    }
    
    @FunctionalInterface
    public interface ThrowingFunction<T, R> {
        R apply(T input) throws Exception;
        
        default Function<T, Optional<R>> toOptional() {
            return input -> {
                try {
                    return Optional.of(apply(input));
                } catch (Exception e) {
                    return Optional.empty();
                }
            };
        }
        
        default Function<T, R> withDefault(R defaultValue) {
            return input -> {
                try {
                    return apply(input);
                } catch (Exception e) {
                    return defaultValue;
                }
            };
        }
        
        default Function<T, R> withExceptionHandler(Function<Exception, R> handler) {
            return input -> {
                try {
                    return apply(input);
                } catch (Exception e) {
                    return handler.apply(e);
                }
            };
        }
    }
    
    @FunctionalInterface
    public interface Retry<T> {
        T execute() throws Exception;
        
        static <T> T withRetry(Retry<T> operation, int maxAttempts, long delayMs) {
            Exception lastException = null;
            
            for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    return operation.execute();
                } catch (Exception e) {
                    lastException = e;
                    if (attempt < maxAttempts) {
                        try {
                            Thread.sleep(delayMs);
                        } catch (InterruptedException ie) {
                            Thread.currentThread().interrupt();
                            throw new RuntimeException("Interrupted during retry", ie);
                        }
                    }
                }
            }
            
            throw new RuntimeException("Operation failed after " + maxAttempts + " attempts", lastException);
        }
    }
    
    // Pipeline pattern z functional interfaces
    public static class Pipeline<T> {
        private final List<Function<T, T>> transformations = new ArrayList<>();
        
        public Pipeline<T> add(Function<T, T> transformation) {
            transformations.add(transformation);
            return this;
        }
        
        public Pipeline<T> addIf(boolean condition, Function<T, T> transformation) {
            if (condition) {
                transformations.add(transformation);
            }
            return this;
        }
        
        public Pipeline<T> filter(Predicate<T> predicate, Function<T, T> transformation) {
            transformations.add(input -> predicate.test(input) ? transformation.apply(input) : input);
            return this;
        }
        
        public T execute(T input) {
            T result = input;
            for (Function<T, T> transformation : transformations) {
                result = transformation.apply(result);
            }
            return result;
        }
        
        public List<T> execute(List<T> inputs) {
            return inputs.stream()
                        .map(this::execute)
                        .collect(Collectors.toList());
        }
        
        public static <T> Pipeline<T> create() {
            return new Pipeline<>();
        }
    }
    
    // Event-driven architecture z functional interfaces
    public static class EventBus {
        private final Map<Class<?>, List<Consumer<?>>> listeners = new HashMap<>();
        
        @SuppressWarnings("unchecked")
        public <T> void subscribe(Class<T> eventType, Consumer<T> listener) {
            listeners.computeIfAbsent(eventType, k -> new ArrayList<>()).add((Consumer<Object>) listener);
        }
        
        public <T> void unsubscribe(Class<T> eventType, Consumer<T> listener) {
            List<Consumer<?>> eventListeners = listeners.get(eventType);
            if (eventListeners != null) {
                eventListeners.remove(listener);
            }
        }
        
        @SuppressWarnings("unchecked")
        public <T> void publish(T event) {
            List<Consumer<?>> eventListeners = listeners.get(event.getClass());
            if (eventListeners != null) {
                for (Consumer<?> listener : eventListeners) {
                    try {
                        ((Consumer<Object>) listener).accept(event);
                    } catch (Exception e) {
                        System.err.println("Error in event listener: " + e.getMessage());
                    }
                }
            }
        }
        
        public <T> void publishAsync(T event) {
            CompletableFuture.runAsync(() -> publish(event));
        }
    }
    
    // Events
    public static class UserRegisteredEvent {
        private final String userId;
        private final String email;
        private final long timestamp;
        
        public UserRegisteredEvent(String userId, String email) {
            this.userId = userId;
            this.email = email;
            this.timestamp = System.currentTimeMillis();
        }
        
        public String getUserId() { return userId; }
        public String getEmail() { return email; }
        public long getTimestamp() { return timestamp; }
    }
    
    public static class OrderPlacedEvent {
        private final String orderId;
        private final String userId;
        private final double amount;
        
        public OrderPlacedEvent(String orderId, String userId, double amount) {
            this.orderId = orderId;
            this.userId = userId;
            this.amount = amount;
        }
        
        public String getOrderId() { return orderId; }
        public String getUserId() { return userId; }
        public double getAmount() { return amount; }
    }
}
```

#### üîß Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj type-safe configuration system u≈ºywajƒÖc interfejs√≥w z default methods i validation.

**Zadanie Zaawansowane 2:** Stw√≥rz reactive streams implementation z functional interfaces i backpressure handling.

**Zadanie Zaawansowane 3:** Zaprojektuj plugin architecture z dynamic interface loading i lifecycle management.

#### ‚ùì Pytania Kontrolne - Poziom Senior

1. Jak interfejsy wp≈ÇywajƒÖ na testability i maintainability kodu?
2. Jakie sƒÖ trade-offs miƒôdzy default methods a abstract classes?
3. Jak functional interfaces zmieni≈Çy spos√≥b programowania w Javie?

---

### üîë Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public interface Sortable<T extends Comparable<T>> {
    void sort(T[] array);
    String getAlgorithmName();
    
    static <T extends Comparable<T>> Sortable<T> bubbleSort() {
        return new BubbleSort<>();
    }
    
    static <T extends Comparable<T>> Sortable<T> quickSort() {
        return new QuickSort<>();
    }
    
    static <T extends Comparable<T>> Sortable<T> mergeSort() {
        return new MergeSort<>();
    }
}

public class BubbleSort<T extends Comparable<T>> implements Sortable<T> {
    @Override
    public void sort(T[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j].compareTo(array[j + 1]) > 0) {
                    T temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    
    @Override
    public String getAlgorithmName() {
        return "Bubble Sort";
    }
}

public class SortingService {
    public <T extends Comparable<T>> void sortAndPrint(T[] array, Sortable<T> sorter) {
        System.out.println("Sorting with: " + sorter.getAlgorithmName());
        System.out.println("Before: " + Arrays.toString(array));
        sorter.sort(array);
        System.out.println("After: " + Arrays.toString(array));
    }
}
```

**Zadanie 2:**
```java
public interface NotificationSender {
    boolean send(String recipient, String message);
    String getType();
    boolean isAvailable();
    
    default void sendWithRetry(String recipient, String message, int maxRetries) {
        for (int i = 0; i < maxRetries; i++) {
            if (send(recipient, message)) {
                return;
            }
            System.out.println("Retry " + (i + 1) + " failed for " + getType());
        }
        throw new RuntimeException("Failed to send notification after " + maxRetries + " retries");
    }
}

public class EmailNotificationSender implements NotificationSender {
    @Override
    public boolean send(String recipient, String message) {
        System.out.println("Sending email to: " + recipient);
        System.out.println("Message: " + message);
        return true;
    }
    
    @Override
    public String getType() {
        return "Email";
    }
    
    @Override
    public boolean isAvailable() {
        return true; // Sprawd≈∫ po≈ÇƒÖczenie SMTP
    }
}

public class NotificationService {
    private final List<NotificationSender> senders;
    
    public NotificationService(List<NotificationSender> senders) {
        this.senders = senders;
    }
    
    public void sendNotification(String recipient, String message, String preferredType) {
        NotificationSender sender = senders.stream()
            .filter(s -> s.getType().equals(preferredType) && s.isAvailable())
            .findFirst()
            .orElse(senders.stream().filter(NotificationSender::isAvailable).findFirst().orElse(null));
        
        if (sender != null) {
            sender.send(recipient, message);
        } else {
            throw new RuntimeException("No available notification senders");
        }
    }
}
```

**Zadanie 3:**
```java
public interface EventListener<T> {
    void onEvent(T event);
    Class<T> getEventType();
    
    default boolean canHandle(Object event) {
        return getEventType().isInstance(event);
    }
}

public interface EventPublisher {
    <T> void subscribe(EventListener<T> listener);
    <T> void unsubscribe(EventListener<T> listener);
    void publish(Object event);
    
    default void publishAsync(Object event) {
        CompletableFuture.runAsync(() -> publish(event));
    }
}

public class SimpleEventBus implements EventPublisher {
    private final List<EventListener<?>> listeners = new ArrayList<>();
    
    @Override
    public <T> void subscribe(EventListener<T> listener) {
        listeners.add(listener);
    }
    
    @Override
    public <T> void unsubscribe(EventListener<T> listener) {
        listeners.remove(listener);
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public void publish(Object event) {
        for (EventListener<?> listener : listeners) {
            if (listener.canHandle(event)) {
                ((EventListener<Object>) listener).onEvent(event);
            }
        }
    }
}
```

**Pytania kontrolne:**
1. Interfejs mo≈ºe mieƒá tylko abstrakcyjne metody (+ default/static), klasa abstrakcyjna mo≈ºe mieƒá pola i konkretne metody. Klasa mo≈ºe implementowaƒá wiele interfejs√≥w, ale dziedziczyƒá tylko z jednej klasy.
2. Default methods pozwalajƒÖ na ewolucjƒô interfejs√≥w bez ≈Çamania backward compatibility. U≈ºywaj gdy chcesz dodaƒá nowƒÖ funkcjonalno≈õƒá do istniejƒÖcego interfejsu.
3. Functional interface ma dok≈Çadnie jednƒÖ abstrakcyjnƒÖ metodƒô i mo≈ºe byƒá u≈ºywany z lambda expressions.

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Interfejsy pozwalajƒÖ na dependency injection, ≈Çatwe mockowanie w testach, loose coupling miƒôdzy komponentami. Kod zale≈ºy od abstrakcji, nie od konkretnych implementacji.
2. Default methods pozwalajƒÖ na ewolucjƒô interfejs√≥w, ale nie mogƒÖ mieƒá stanu. Abstract classes mogƒÖ mieƒá pola i konstruktory, ale ograniczajƒÖ dziedziczenie.
3. Functional interfaces umo≈ºliwi≈Çy lambda expressions, method references, streams API. Zmieni≈Çy Javƒô z imperatywnej na bardziej funkcyjnƒÖ.

---

### üìö Co dalej?

*Fantastycznie! Teraz rozumiesz pe≈ÇnƒÖ moc interfejs√≥w - od prostych kontrakt√≥w po zaawansowane wzorce architektoniczne. Interfejsy to fundament elastycznego, testowalnego kodu w Javie. W nastƒôpnym rozdziale porozmawiamy o generykach - czyli jak tworzyƒá type-safe kod, kt√≥ry dzia≈Ça z r√≥≈ºnymi typami!*

---

*üí° Pamiƒôtaj: Interfejsy to nie tylko sk≈Çadnia - to spos√≥b my≈õlenia o architekturze. Program to abstrakcji, nie do konkretnych implementacji!*

## 17. Lambda: funkcje w wersji mini

*Cze≈õƒá! Dzi≈õ porozmawiamy o lambdach - jednej z najwa≈ºniejszych nowo≈õci, kt√≥re zrewolucjonizowa≈Çy Javƒô. Je≈õli kiedykolwiek my≈õla≈Ça≈õ "dlaczego muszƒô pisaƒá tyle kodu, ≈ºeby zrobiƒá co≈õ tak prostego?", to lambdy sƒÖ odpowiedziƒÖ na Twoje modlitwy. To jak przej≈õcie od pisania d≈Çugich list√≥w do wysy≈Çania SMS-√≥w - ten sam przekaz, ale w znacznie kr√≥tszej formie!*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Co to w≈Ça≈õciwie jest lambda?

Lambda to spos√≥b na napisanie kr√≥tkiej, anonimowej funkcji bez ca≈Çej ceremonii tworzenia klasy. To jak przepis na kawƒô: zamiast pisaƒá ca≈ÇƒÖ ksiƒÖ≈ºkƒô kucharskƒÖ, po prostu m√≥wisz "we≈∫ kawƒô, dodaj mleko, wymieszaj".

Przed lambdami, ≈ºeby posortowaƒá listƒô, musia≈Ça≈õ pisaƒá co≈õ takiego:

```java
// Stary spos√≥b - du≈ºo kodu dla prostej rzeczy
List<String> imiona = Arrays.asList("Anna", "Zofia", "Beata", "Ewa");

Collections.sort(imiona, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareTo(b);
    }
});
```

Z lambdami to samo robisz tak:

```java
// Nowy spos√≥b - kr√≥tko i na temat
List<String> imiona = Arrays.asList("Anna", "Zofia", "Beata", "Ewa");
Collections.sort(imiona, (a, b) -> a.compareTo(b));

// Albo jeszcze kr√≥cej
imiona.sort(String::compareTo);
```

#### Sk≈Çadnia lambda - krok po kroku

Lambda ma prostƒÖ strukturƒô: `(parametry) -> { cia≈Ço funkcji }`

```java
// Podstawowa sk≈Çadnia
(String s) -> s.length()           // Jeden parametr
(a, b) -> a + b                    // Dwa parametry
() -> System.out.println("Cze≈õƒá!") // Bez parametr√≥w
x -> x * 2                         // Jeden parametr bez nawias√≥w

// Z blokiem kodu
(String s) -> {
    String upper = s.toUpperCase();
    return upper + "!";
}
```

#### Gdzie u≈ºywaƒá lambd?

Lambdy dzia≈ÇajƒÖ wszƒôdzie tam, gdzie Java oczekuje functional interface (interfejs z jednƒÖ metodƒÖ abstrakcyjnƒÖ):

```java
public class LambdaExamples {
    public static void main(String[] args) {
        List<String> miasta = Arrays.asList("Warszawa", "Krak√≥w", "Gda≈Ñsk", "Wroc≈Çaw");
        
        // Filtrowanie
        List<String> dlugieNazwy = miasta.stream()
            .filter(miasto -> miasto.length() > 6)
            .collect(Collectors.toList());
        
        // Mapowanie (transformacja)
        List<String> wielkieLitery = miasta.stream()
            .map(miasto -> miasto.toUpperCase())
            .collect(Collectors.toList());
        
        // Iterowanie
        miasta.forEach(miasto -> System.out.println("Miasto: " + miasto));
        
        // Sortowanie
        miasta.sort((a, b) -> a.length() - b.length());
        
        System.out.println("D≈Çugie nazwy: " + dlugieNazwy);
        System.out.println("Wielkie litery: " + wielkieLitery);
        System.out.println("Posortowane: " + miasta);
    }
}
```

#### Praktyczne przyk≈Çady z ≈ºycia

**Przetwarzanie danych u≈ºytkownik√≥w:**

```java
public class UserProcessor {
    public static class User {
        private String name;
        private int age;
        private String city;
        private boolean active;
        
        public User(String name, int age, String city, boolean active) {
            this.name = name;
            this.age = age;
            this.city = city;
            this.active = active;
        }
        
        // Gettery
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getCity() { return city; }
        public boolean isActive() { return active; }
        
        @Override
        public String toString() {
            return name + " (" + age + ", " + city + ")";
        }
    }
    
    public static void main(String[] args) {
        List<User> users = Arrays.asList(
            new User("Anna", 25, "Warszawa", true),
            new User("Beata", 30, "Krak√≥w", false),
            new User("Ewa", 22, "Gda≈Ñsk", true),
            new User("Zofia", 35, "Wroc≈Çaw", true)
        );
        
        // Znajd≈∫ aktywnych u≈ºytkownik√≥w z Warszawy
        List<User> activeFromWarsaw = users.stream()
            .filter(user -> user.isActive())
            .filter(user -> user.getCity().equals("Warszawa"))
            .collect(Collectors.toList());
        
        // Pobierz imiona u≈ºytkownik√≥w starszych ni≈º 25 lat
        List<String> namesOver25 = users.stream()
            .filter(user -> user.getAge() > 25)
            .map(user -> user.getName())
            .collect(Collectors.toList());
        
        // Sprawd≈∫ czy wszyscy u≈ºytkownicy sƒÖ aktywni
        boolean allActive = users.stream()
            .allMatch(user -> user.isActive());
        
        // Znajd≈∫ najstarszego u≈ºytkownika
        Optional<User> oldest = users.stream()
            .max((u1, u2) -> Integer.compare(u1.getAge(), u2.getAge()));
        
        System.out.println("Aktywni z Warszawy: " + activeFromWarsaw);
        System.out.println("Imiona 25+: " + namesOver25);
        System.out.println("Wszyscy aktywni: " + allActive);
        oldest.ifPresent(user -> System.out.println("Najstarszy: " + user));
    }
}
```

**Obs≈Çuga zdarze≈Ñ w GUI:**

```java
// Zamiast tworzenia osobnych klas dla ka≈ºdego przycisku
button1.addActionListener(e -> System.out.println("Klikniƒôto przycisk 1"));
button2.addActionListener(e -> saveData());
button3.addActionListener(e -> {
    if (validateForm()) {
        submitForm();
    } else {
        showError("Formularz zawiera b≈Çƒôdy");
    }
});
```

**Walidacja danych:**

```java
public class ValidationExample {
    // Functional interface dla walidacji
    @FunctionalInterface
    interface Validator<T> {
        boolean isValid(T value);
    }
    
    public static void main(String[] args) {
        // R√≥≈ºne walidatory jako lambdy
        Validator<String> notEmpty = s -> s != null && !s.trim().isEmpty();
        Validator<String> minLength = s -> s != null && s.length() >= 3;
        Validator<Integer> positive = n -> n != null && n > 0;
        Validator<Integer> inRange = n -> n != null && n >= 18 && n <= 100;
        
        // Testowanie walidacji
        String name = "Anna";
        Integer age = 25;
        
        if (notEmpty.isValid(name) && minLength.isValid(name)) {
            System.out.println("Imiƒô jest poprawne");
        }
        
        if (positive.isValid(age) && inRange.isValid(age)) {
            System.out.println("Wiek jest poprawny");
        }
        
        // Kombinowanie walidator√≥w
        List<String> emails = Arrays.asList("test@example.com", "", "invalid", "user@domain.org");
        
        emails.stream()
            .filter(email -> email.contains("@"))
            .filter(email -> email.contains("."))
            .forEach(email -> System.out.println("Poprawny email: " + email));
    }
}
```

#### Method References - jeszcze kr√≥cej!

Czasami lambda jest tak prosta, ≈ºe mo≈ºna jƒÖ zastƒÖpiƒá method reference:

```java
// Lambda vs Method Reference
List<String> words = Arrays.asList("java", "lambda", "stream", "method");

// Lambda
words.forEach(word -> System.out.println(word));
// Method reference
words.forEach(System.out::println);

// Lambda
words.stream().map(word -> word.toUpperCase());
// Method reference
words.stream().map(String::toUpperCase);

// Lambda
words.stream().filter(word -> word.startsWith("j"));
// Method reference (nie zawsze mo≈ºliwe)
// words.stream().filter(String::startsWith); // To nie zadzia≈Ça!
```

#### Typy method references

```java
public class MethodReferences {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("java", "python", "kotlin", "scala");
        
        // 1. Reference do static method
        words.stream()
            .map(String::valueOf)  // String.valueOf(word)
            .forEach(System.out::println);
        
        // 2. Reference do instance method konkretnego obiektu
        String prefix = "Language: ";
        words.stream()
            .map(prefix::concat)   // prefix.concat(word)
            .forEach(System.out::println);
        
        // 3. Reference do instance method dowolnego obiektu danego typu
        words.stream()
            .map(String::toUpperCase)  // word.toUpperCase()
            .forEach(System.out::println);
        
        // 4. Reference do konstruktora
        words.stream()
            .map(StringBuilder::new)   // new StringBuilder(word)
            .forEach(sb -> System.out.println(sb.toString()));
    }
}
```

#### Streams API - naturalne ≈õrodowisko lambd

```java
public class StreamsWithLambdas {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // ≈Åa≈Ñcuch operacji z lambdami
        List<String> result = numbers.stream()
            .filter(n -> n % 2 == 0)           // Tylko parzyste
            .map(n -> n * n)                   // Podnie≈õ do kwadratu
            .filter(n -> n > 10)               // Wiƒôksze ni≈º 10
            .map(n -> "Number: " + n)          // Konwertuj na String
            .collect(Collectors.toList());     // Zbierz do listy
        
        result.forEach(System.out::println);
        
        // Operacje redukcji
        int sum = numbers.stream()
            .filter(n -> n > 5)
            .mapToInt(Integer::intValue)
            .sum();
        
        OptionalDouble average = numbers.stream()
            .mapToInt(Integer::intValue)
            .average();
        
        Optional<Integer> max = numbers.stream()
            .max(Integer::compareTo);
        
        System.out.println("Suma liczb > 5: " + sum);
        System.out.println("≈örednia: " + average.orElse(0.0));
        System.out.println("Maksimum: " + max.orElse(0));
        
        // Grupowanie
        Map<Boolean, List<Integer>> evenOdd = numbers.stream()
            .collect(Collectors.partitioningBy(n -> n % 2 == 0));
        
        System.out.println("Parzyste: " + evenOdd.get(true));
        System.out.println("Nieparzyste: " + evenOdd.get(false));
    }
}
```

#### Praktyczne wzorce z lambdami

**1. Factory pattern z lambdami:**

```java
public class LambdaFactory {
    @FunctionalInterface
    interface ShapeFactory {
        Shape create(double... params);
    }
    
    interface Shape {
        double area();
        String getType();
    }
    
    static class Circle implements Shape {
        private final double radius;
        
        Circle(double radius) { this.radius = radius; }
        
        @Override
        public double area() { return Math.PI * radius * radius; }
        
        @Override
        public String getType() { return "Circle"; }
    }
    
    static class Rectangle implements Shape {
        private final double width, height;
        
        Rectangle(double width, double height) {
            this.width = width;
            this.height = height;
        }
        
        @Override
        public double area() { return width * height; }
        
        @Override
        public String getType() { return "Rectangle"; }
    }
    
    public static void main(String[] args) {
        Map<String, ShapeFactory> factories = Map.of(
            "circle", params -> new Circle(params[0]),
            "rectangle", params -> new Rectangle(params[0], params[1])
        );
        
        // Tworzenie kszta≈Çt√≥w przez lambdy
        Shape circle = factories.get("circle").create(5.0);
        Shape rectangle = factories.get("rectangle").create(4.0, 6.0);
        
        System.out.println(circle.getType() + " area: " + circle.area());
        System.out.println(rectangle.getType() + " area: " + rectangle.area());
    }
}
```

**2. Command pattern z lambdami:**

```java
public class LambdaCommands {
    @FunctionalInterface
    interface Command {
        void execute();
    }
    
    static class Calculator {
        private double value = 0;
        
        void add(double x) { value += x; }
        void subtract(double x) { value -= x; }
        void multiply(double x) { value *= x; }
        void divide(double x) { if (x != 0) value /= x; }
        
        double getValue() { return value; }
        void setValue(double value) { this.value = value; }
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        calc.setValue(10);
        
        // Komendy jako lambdy
        List<Command> commands = Arrays.asList(
            () -> calc.add(5),
            () -> calc.multiply(2),
            () -> calc.subtract(3),
            () -> calc.divide(2)
        );
        
        System.out.println("Warto≈õƒá poczƒÖtkowa: " + calc.getValue());
        
        // Wykonanie komend
        commands.forEach(command -> {
            command.execute();
            System.out.println("Po operacji: " + calc.getValue());
        });
    }
}
```

#### üí° Wskaz√≥wki dla Juniorek

- **Zacznij od prostych lambd**: `x -> x * 2` zamiast skomplikowanych blok√≥w
- **U≈ºywaj opisowych nazw parametr√≥w**: `user -> user.getName()` zamiast `u -> u.getName()`
- **Nie b√≥j siƒô eksperymentowaƒá**: IDE podpowie Ci, gdzie mo≈ºesz u≈ºyƒá lambd
- **Method references dla prostych przypadk√≥w**: `String::toUpperCase` zamiast `s -> s.toUpperCase()`
- **Streams + lambdy = potƒôga**: To najczƒôstsze zastosowanie

#### üéØ Zadania dla Juniorek

**Zadanie 1:** Stw√≥rz listƒô liczb i u≈ºyj lambd do:
- Znalezienia wszystkich liczb parzystych
- Pomno≈ºenia ka≈ºdej liczby przez 2
- Znalezienia najwiƒôkszej liczby

**Zadanie 2:** MajƒÖc listƒô produkt√≥w (nazwa, cena), u≈ºyj lambd do:
- Znalezienia produkt√≥w dro≈ºszych ni≈º 100 z≈Ç
- Posortowania po cenie
- Obliczenia ≈õredniej ceny

**Zadanie 3:** Stw√≥rz prosty kalkulator u≈ºywajƒÖc lambd dla r√≥≈ºnych operacji (dodawanie, odejmowanie, mno≈ºenie, dzielenie).

#### ‚ùì Pytania Kontrolne - Poziom Junior

1. Jaka jest sk≈Çadnia podstawowej lambdy?
2. Czym r√≥≈ºni siƒô lambda od method reference?
3. Gdzie najczƒô≈õciej u≈ºywa siƒô lambd w Javie?

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### G≈Çƒôbsza analiza lambd

Lambdy to nie tylko syntactic sugar - to fundamentalna zmiana w sposobie my≈õlenia o programowaniu w Javie. WprowadzajƒÖ elementy programowania funkcyjnego do tradycyjnie obiektowego jƒôzyka.

##### Jak lambdy dzia≈ÇajƒÖ pod maskƒÖ?

```java
public class LambdaInternals {
    public static void main(String[] args) {
        // Ta lambda...
        Runnable r1 = () -> System.out.println("Hello");
        
        // ...jest kompilowana do czego≈õ podobnego do:
        Runnable r2 = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello");
            }
        };
        
        // Ale nie do ko≈Ñca! Lambda u≈ºywa invokedynamic
        // i jest bardziej efektywna ni≈º klasa anonimowa
    }
}
```

**Invokedynamic i performance:**

Lambdy u≈ºywajƒÖ instrukcji `invokedynamic` wprowadzonej w Javie 7. To oznacza, ≈ºe:
- Nie tworzƒÖ nowych plik√≥w `.class` dla ka≈ºdej lambdy
- SƒÖ lazy-loaded - tworzone dopiero przy pierwszym u≈ºyciu
- JVM mo≈ºe je optymalizowaƒá lepiej ni≈º klasy anonimowe
- MajƒÖ mniejszy memory footprint

##### Closures i przechwytywanie zmiennych

```java
public class ClosureExamples {
    private int instanceVar = 10;
    private static int staticVar = 20;
    
    public void demonstrateClosures() {
        int localVar = 30;
        final int finalVar = 40;
        
        // Lambda mo≈ºe przechwyciƒá:
        Runnable lambda = () -> {
            // 1. Zmienne instancji
            System.out.println("Instance: " + instanceVar);
            
            // 2. Zmienne statyczne
            System.out.println("Static: " + staticVar);
            
            // 3. Zmienne lokalne (effectively final)
            System.out.println("Local: " + localVar);
            System.out.println("Final: " + finalVar);
            
            // 4. Mo≈ºe modyfikowaƒá zmienne instancji
            instanceVar = 15; // OK
            
            // 5. Ale NIE mo≈ºe modyfikowaƒá zmiennych lokalnych
            // localVar = 35; // B≈ÇƒÖd kompilacji!
        };
        
        // localVar = 35; // To te≈º spowodowa≈Çoby b≈ÇƒÖd w lambdzie!
        
        lambda.run();
    }
    
    // Workaround dla modyfikacji zmiennych lokalnych
    public void mutableClosureWorkaround() {
        AtomicInteger counter = new AtomicInteger(0);
        List<String> items = Arrays.asList("a", "b", "c");
        
        items.forEach(item -> {
            int current = counter.incrementAndGet();
            System.out.println(current + ": " + item);
        });
        
        System.out.println("Final count: " + counter.get());
    }
    
    // Demonstracja r√≥≈ºnych typ√≥w closure
    public void closureTypes() {
        int localValue = 100;
        
        // Non-capturing lambda - nie przechwytuje ≈ºadnych zmiennych
        Supplier<String> nonCapturing = () -> "Constant value";
        
        // Capturing lambda - przechwytuje zmienne z otoczenia
        Supplier<String> capturing = () -> "Local value: " + localValue;
        
        // Self-contained lambda z w≈Çasnym stanem
        Supplier<Integer> stateful = new Supplier<Integer>() {
            private int count = 0;
            
            @Override
            public Integer get() {
                return ++count;
            }
        };
        
        System.out.println(nonCapturing.get());
        System.out.println(capturing.get());
        System.out.println("Stateful: " + stateful.get() + ", " + stateful.get());
    }
}
```

##### Zaawansowane wzorce z lambdami

**1. Function Composition:**

```java
public class FunctionComposition {
    public static void main(String[] args) {
        Function<String, String> addPrefix = s -> "PREFIX_" + s;
        Function<String, String> addSuffix = s -> s + "_SUFFIX";
        Function<String, String> toUpper = String::toUpperCase;
        
        // Komponowanie funkcji
        Function<String, String> composed = addPrefix
            .andThen(toUpper)
            .andThen(addSuffix);
        
        String result = composed.apply("test");
        System.out.println(result); // PREFIX_TEST_SUFFIX
        
        // Alternatywnie - compose (odwrotna kolejno≈õƒá)
        Function<String, String> composed2 = addSuffix
            .compose(toUpper)
            .compose(addPrefix);
        
        String result2 = composed2.apply("test");
        System.out.println(result2); // PREFIX_TEST_SUFFIX
        
        // Predicate composition
        Predicate<String> notNull = Objects::nonNull;
        Predicate<String> notEmpty = s -> !s.isEmpty();
        Predicate<String> hasContent = notNull.and(notEmpty);
        
        System.out.println("Valid string: " + hasContent.test("hello")); // true
        System.out.println("Invalid string: " + hasContent.test("")); // false
    }
}
```

**2. Currying i Partial Application:**

```java
public class CurryingExample {
    // Funkcja trzech argument√≥w
    static Function<Integer, Function<Integer, Function<Integer, Integer>>> add3 = 
        a -> b -> c -> a + b + c;
    
    // Partial application
    static Function<Integer, Integer> add5And10 = add3.apply(5).apply(10);
    
    public static void main(String[] args) {
        // Pe≈Çne wywo≈Çanie
        int result1 = add3.apply(1).apply(2).apply(3); // 6
        
        // Partial application
        int result2 = add5And10.apply(7); // 22 (5 + 10 + 7)
        
        System.out.println("Result 1: " + result1);
        System.out.println("Result 2: " + result2);
        
        // Praktyczny przyk≈Çad - konfiguracja walidator√≥w
        Function<Integer, Function<Integer, Predicate<Integer>>> rangeValidator = 
            min -> max -> value -> value >= min && value <= max;
        
        Predicate<Integer> ageValidator = rangeValidator.apply(18).apply(65);
        Predicate<Integer> percentageValidator = rangeValidator.apply(0).apply(100);
        
        System.out.println("Age 25 valid: " + ageValidator.test(25)); // true
        System.out.println("Percentage 150 valid: " + percentageValidator.test(150)); // false
    }
}
```

**3. Memoization z lambdami:**

```java
public class MemoizationExample {
    public static <T, R> Function<T, R> memoize(Function<T, R> function) {
        Map<T, R> cache = new ConcurrentHashMap<>();
        return input -> cache.computeIfAbsent(input, function);
    }
    
    // Przyk≈Çad: kosztowna operacja
    static Function<Integer, BigInteger> fibonacci = MemoizationExample.memoize(n -> {
        System.out.println("Computing fibonacci(" + n + ")");
        if (n <= 1) return BigInteger.valueOf(n);
        return MemoizationExample.fibonacci.apply(n - 1)
            .add(MemoizationExample.fibonacci.apply(n - 2));
    });
    
    public static void main(String[] args) {
        System.out.println("First call:");
        System.out.println(fibonacci.apply(10));
        
        System.out.println("\nSecond call (cached):");
        System.out.println(fibonacci.apply(10));
        
        System.out.println("\nThird call (partially cached):");
        System.out.println(fibonacci.apply(12));
    }
}
```

**4. Event-driven programming z lambdami:**

```java
public class EventDrivenExample {
    public interface EventListener<T> {
        void handle(T event);
    }
    
    public static class EventBus<T> {
        private final List<EventListener<T>> listeners = new ArrayList<>();
        private final List<Function<T, T>> middlewares = new ArrayList<>();
        
        public void subscribe(EventListener<T> listener) {
            listeners.add(listener);
        }
        
        public void unsubscribe(EventListener<T> listener) {
            listeners.remove(listener);
        }
        
        public void addMiddleware(Function<T, T> middleware) {
            middlewares.add(middleware);
        }
        
        public void publish(T event) {
            // Zastosuj middleware
            T processedEvent = middlewares.stream()
                .reduce(Function.identity(), Function::andThen)
                .apply(event);
            
            // Powiadom s≈Çuchaczy
            listeners.forEach(listener -> {
                try {
                    listener.handle(processedEvent);
                } catch (Exception e) {
                    System.err.println("Error in event listener: " + e.getMessage());
                }
            });
        }
        
        // Fluent API dla subskrypcji
        public EventBus<T> on(EventListener<T> listener) {
            subscribe(listener);
            return this;
        }
    }
    
    public static class UserEvent {
        private final String type;
        private final String userId;
        private final Map<String, Object> data;
        
        public UserEvent(String type, String userId, Map<String, Object> data) {
            this.type = type;
            this.userId = userId;
            this.data = data;
        }
        
        public String getType() { return type; }
        public String getUserId() { return userId; }
        public Map<String, Object> getData() { return data; }
        
        @Override
        public String toString() {
            return "UserEvent{type='" + type + "', userId='" + userId + "'}";
        }
    }
    
    public static void main(String[] args) {
        EventBus<UserEvent> userEventBus = new EventBus<>();
        
        // Middleware dla logowania
        userEventBus.addMiddleware(event -> {
            System.out.println("Middleware: Processing " + event);
            return event;
        });
        
        // Subskrypcja z lambdami
        userEventBus
            .on(event -> {
                if ("USER_REGISTERED".equals(event.getType())) {
                    System.out.println("Sending welcome email to: " + event.getUserId());
                }
            })
            .on(event -> {
                if ("USER_LOGIN".equals(event.getType())) {
                    System.out.println("Logging user activity: " + event.getUserId());
                }
            })
            .on(event -> System.out.println("Audit log: " + event.getType() + " for " + event.getUserId()));
        
        // Publikowanie zdarze≈Ñ
        userEventBus.publish(new UserEvent("USER_REGISTERED", "user123", Map.of("email", "user@example.com")));
        userEventBus.publish(new UserEvent("USER_LOGIN", "user123", Map.of("ip", "192.168.1.1")));
    }
}
```

##### Efekty uboczne i pu≈Çapki

**1. Side effects w lambdach:**

```java
public class SideEffectsProblems {
    public static void main(String[] args) {
        List<String> items = Arrays.asList("a", "b", "c", "d");
        List<String> results = new ArrayList<>();
        
        // PROBLEM: Side effect w lambdzie
        items.stream()
            .filter(s -> s.length() > 0)
            .forEach(s -> results.add(s.toUpperCase())); // Side effect!
        
        // LEPIEJ: Funkcyjne podej≈õcie
        List<String> betterResults = items.stream()
            .filter(s -> s.length() > 0)
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        
        System.out.println("Side effect results: " + results);
        System.out.println("Functional results: " + betterResults);
        
        // PROBLEM: Modyfikacja zewnƒôtrznego stanu
        AtomicInteger counter = new AtomicInteger(0);
        items.stream()
            .forEach(s -> counter.incrementAndGet()); // Side effect!
        
        // LEPIEJ: U≈ºyj count()
        long count = items.stream().count();
        
        System.out.println("Counter: " + counter.get());
        System.out.println("Count: " + count);
    }
}
```

**2. Exception handling w lambdach:**

```java
public class ExceptionHandling {
    @FunctionalInterface
    interface ThrowingFunction<T, R> {
        R apply(T t) throws Exception;
    }
    
    public static <T, R> Function<T, R> unchecked(ThrowingFunction<T, R> f) {
        return t -> {
            try {
                return f.apply(t);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
    
    public static <T, R> Function<T, Optional<R>> safe(ThrowingFunction<T, R> f) {
        return t -> {
            try {
                return Optional.of(f.apply(t));
            } catch (Exception e) {
                return Optional.empty();
            }
        };
    }
    
    public static void main(String[] args) {
        List<String> urls = Arrays.asList("http://example.com", "invalid-url", "http://google.com");
        
        // Problem: checked exceptions w lambdach
        // urls.stream().map(url -> new URL(url)); // Nie kompiluje siƒô!
        
        // RozwiƒÖzanie 1: wrapper
        List<URL> urlObjects = urls.stream()
            .map(unchecked(URL::new))
            .collect(Collectors.toList());
        
        // RozwiƒÖzanie 2: Optional dla error handling
        List<Optional<URL>> urlOptionals = urls.stream()
            .map(safe(URL::new))
            .collect(Collectors.toList());
        
        // RozwiƒÖzanie 3: filter out errors
        List<URL> validUrls = urls.stream()
            .map(safe(URL::new))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
        
        System.out.println("All URLs (with exceptions): " + urlObjects.size());
        System.out.println("Optional URLs: " + urlOptionals);
        System.out.println("Valid URLs: " + validUrls);
    }
}
```

**3. Performance considerations:**

```java
public class LambdaPerformance {
    private static final int ITERATIONS = 1_000_000;
    
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.range(0, 1000)
            .boxed()
            .collect(Collectors.toList());
        
        // Test 1: Lambda vs Method Reference vs Anonymous Class
        measureTime("Lambda", () -> {
            numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * 2)
                .sum();
        });
        
        measureTime("Method Reference", () -> {
            numbers.stream()
                .filter(LambdaPerformance::isEven)
                .mapToInt(LambdaPerformance::doubleValue)
                .sum();
        });
        
        measureTime("Anonymous Class", () -> {
            numbers.stream()
                .filter(new Predicate<Integer>() {
                    @Override
                    public boolean test(Integer n) {
                        return n % 2 == 0;
                    }
                })
                .mapToInt(new ToIntFunction<Integer>() {
                    @Override
                    public int applyAsInt(Integer n) {
                        return n * 2;
                    }
                })
                .sum();
        });
        
        // Test 2: Primitive streams vs Object streams
        measureTime("Primitive Stream", () -> {
            IntStream.range(0, 1000)
                .filter(n -> n % 2 == 0)
                .map(n -> n * 2)
                .sum();
        });
        
        measureTime("Object Stream", () -> {
            IntStream.range(0, 1000)
                .boxed()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * 2)
                .sum();
        });
        
        // Test 3: Capturing vs non-capturing lambdas
        int multiplier = 2;
        measureTime("Capturing Lambda", () -> {
            numbers.stream()
                .mapToInt(n -> n * multiplier) // Captures 'multiplier'
                .sum();
        });
        
        measureTime("Non-capturing Lambda", () -> {
            numbers.stream()
                .mapToInt(n -> n * 2) // No capture
                .sum();
        });
    }
    
    private static void measureTime(String name, Runnable operation) {
        // Warm-up
        for (int i = 0; i < 10000; i++) {
            operation.run();
        }
        
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            operation.run();
        }
        long end = System.nanoTime();
        
        System.out.printf("%s: %.2f ms%n", name, (end - start) / 1_000_000.0);
    }
    
    private static boolean isEven(Integer n) {
        return n % 2 == 0;
    }
    
    private static int doubleValue(Integer n) {
        return n * 2;
    }
}
```

**4. Memory leaks z lambdami:**

```java
public class LambdaMemoryLeaks {
    private String heavyData = "Very heavy data...".repeat(10000);
    
    // PROBLEM: Lambda przechwytuje ca≈ÇƒÖ instancjƒô
    public Supplier<String> createLeakySupplier() {
        return () -> "Some result"; // Przechwytuje 'this' niepotrzebnie!
    }
    
    // ROZWIƒÑZANIE: Static method lub explicit parameter
    public static Supplier<String> createNonLeakySupplier() {
        return () -> "Some result"; // Nie przechwytuje niczego
    }
    
    public Supplier<String> createSupplierWithParameter(String data) {
        return () -> data; // Przechwytuje tylko 'data', nie ca≈Çe 'this'
    }
    
    // PROBLEM: Listener nie jest usuwany
    public void addListenerWithLeak(EventBus eventBus) {
        eventBus.subscribe(event -> {
            // Lambda przechwytuje 'this', wiƒôc obiekt nie mo≈ºe byƒá GC
            System.out.println("Processing: " + event);
        });
    }
    
    // ROZWIƒÑZANIE: Explicit cleanup
    private EventListener listener;
    
    public void addListenerWithCleanup(EventBus eventBus) {
        listener = event -> System.out.println("Processing: " + event);
        eventBus.subscribe(listener);
    }
    
    public void cleanup(EventBus eventBus) {
        if (listener != null) {
            eventBus.unsubscribe(listener);
            listener = null;
        }
    }
    
    interface EventBus {
        void subscribe(EventListener listener);
        void unsubscribe(EventListener listener);
    }
    
    interface EventListener {
        void handle(Object event);
    }
}
```

#### üîß Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj w≈Çasny reactive streams framework u≈ºywajƒÖc lambd i kompozycji funkcji.

**Zadanie Zaawansowane 2:** Stw√≥rz type-safe query builder z fluent API u≈ºywajƒÖc function composition.

**Zadanie Zaawansowane 3:** Zaprojektuj system middleware dla web applications u≈ºywajƒÖc lambd i partial application.

#### ‚ùì Pytania Kontrolne - Poziom Senior

1. Jak lambdy wp≈ÇywajƒÖ na performance w por√≥wnaniu do klas anonimowych?
2. Jakie sƒÖ ograniczenia closures w lambdach Java?
3. Jak radziƒá sobie z checked exceptions w lambdach?
4. Jakie sƒÖ potencjalne ≈∫r√≥d≈Ça memory leaks z lambdami?

---

### üîë Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Liczby parzyste
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

// Pomno≈ºenie przez 2
List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

// Najwiƒôksza liczba
Optional<Integer> max = numbers.stream()
    .max((a, b) -> Integer.compare(a, b));
// lub kr√≥cej:
Optional<Integer> max2 = numbers.stream()
    .max(Integer::compareTo);

System.out.println("Parzyste: " + evenNumbers);
System.out.println("Podwojone: " + doubled);
System.out.println("Maksimum: " + max.orElse(0));
```

**Zadanie 2:**
```java
public class Product {
    private String name;
    private double price;
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    
    @Override
    public String toString() {
        return name + " (" + price + " z≈Ç)";
    }
}

List<Product> products = Arrays.asList(
    new Product("Laptop", 2500.0),
    new Product("Mysz", 50.0),
    new Product("Klawiatura", 150.0),
    new Product("Monitor", 800.0)
);

// Produkty dro≈ºsze ni≈º 100 z≈Ç
List<Product> expensive = products.stream()
    .filter(p -> p.getPrice() > 100)
    .collect(Collectors.toList());

// Sortowanie po cenie
List<Product> sorted = products.stream()
    .sorted((p1, p2) -> Double.compare(p1.getPrice(), p2.getPrice()))
    .collect(Collectors.toList());

// ≈örednia cena
double averagePrice = products.stream()
    .mapToDouble(Product::getPrice)
    .average()
    .orElse(0.0);

System.out.println("Drogie produkty: " + expensive);
System.out.println("Posortowane: " + sorted);
System.out.println("≈örednia cena: " + averagePrice + " z≈Ç");
```

**Zadanie 3:**
```java
public class LambdaCalculator {
    @FunctionalInterface
    interface Operation {
        double calculate(double a, double b);
    }
    
    private static final Map<String, Operation> operations = Map.of(
        "+", (a, b) -> a + b,
        "-", (a, b) -> a - b,
        "*", (a, b) -> a * b,
        "/", (a, b) -> b != 0 ? a / b : Double.NaN,
        "^", Math::pow,
        "%", (a, b) -> a % b
    );
    
    public static double calculate(double a, double b, String operator) {
        return operations.getOrDefault(operator, (x, y) -> Double.NaN)
                        .calculate(a, b);
    }
    
    public static void main(String[] args) {
        System.out.println("10 + 5 = " + calculate(10, 5, "+"));
        System.out.println("10 - 5 = " + calculate(10, 5, "-"));
        System.out.println("10 * 5 = " + calculate(10, 5, "*"));
        System.out.println("10 / 5 = " + calculate(10, 5, "/"));
        System.out.println("10 ^ 2 = " + calculate(10, 2, "^"));
        System.out.println("10 % 3 = " + calculate(10, 3, "%"));
    }
}
```

**Pytania kontrolne:**
1. `(parametry) -> wyra≈ºenie` lub `(parametry) -> { blok kodu }`
2. Lambda to anonimowa funkcja, method reference to odwo≈Çanie do istniejƒÖcej metody (`String::toUpperCase`)
3. W streams API, event handling, functional interfaces, collections operations

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Lambdy sƒÖ bardziej efektywne - u≈ºywajƒÖ invokedynamic, nie tworzƒÖ nowych klas, majƒÖ lepszy memory footprint i sƒÖ optymalizowane przez JIT
2. MogƒÖ przechwytywaƒá tylko effectively final zmienne lokalne, nie mogƒÖ ich modyfikowaƒá, przechwytujƒÖ ca≈ÇƒÖ instancjƒô gdy u≈ºywajƒÖ this
3. Wrapper functions, Optional, biblioteki jak Vavr, lub w≈Çasne functional interfaces z default methods
4. Przechwytywanie this niepotrzebnie, listeners nie usuwane, capturing lambdas w d≈Çugo ≈ºyjƒÖcych kolekcjach

---

### üìö Co dalej?

*Fantastycznie! Teraz rozumiesz pe≈ÇnƒÖ moc lambd - od prostej sk≈Çadni po zaawansowane wzorce funkcyjne. Lambdy zmieni≈Çy spos√≥b programowania w Javie, czyniƒÖc kod bardziej zwiƒôz≈Çym i ekspresyjnym. W nastƒôpnym rozdziale porozmawiamy o functional interfaces - teoretycznej podstawie, kt√≥ra sprawia, ≈ºe lambdy w og√≥le dzia≈ÇajƒÖ!*

---

*üí° Pamiƒôtaj: Lambdy to nie tylko kr√≥tsza sk≈Çadnia - to nowy spos√≥b my≈õlenia o problemach. Zamiast "jak to zrobiƒá krok po kroku", my≈õl "co chcƒô osiƒÖgnƒÖƒá"!*

## 18. Functional interfaces: teoria spiskowa @FunctionalInterface

*Cze≈õƒá! Dzi≈õ zag≈Çƒôbimy siƒô w tajemnice functional interfaces - teoretycznƒÖ podstawƒô, kt√≥ra sprawia, ≈ºe lambdy w og√≥le dzia≈ÇajƒÖ. To jak poznanie przepisu na ciasto, kt√≥re ju≈º jad≈Ça≈õ - nagle wszystko zaczyna mieƒá sens! Functional interfaces to most miƒôdzy tradycyjnƒÖ JavƒÖ obiektowƒÖ a nowoczesnymi elementami funkcyjnymi.*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Co to w≈Ça≈õciwie jest functional interface?

Functional interface to interfejs, kt√≥ry ma dok≈Çadnie jednƒÖ abstrakcyjnƒÖ metodƒô. To wszystko! Brzmi prosto, prawda? Ale ta prostota kryje w sobie ogromnƒÖ moc.

```java
// To jest functional interface
@FunctionalInterface
public interface Calculator {
    double calculate(double a, double b);
}

// To te≈º jest functional interface (bez adnotacji)
public interface Printer {
    void print(String message);
}

// To NIE jest functional interface - za du≈ºo metod
public interface MultiMethod {
    void method1();
    void method2(); // Za du≈ºo!
}
```

Adnotacja `@FunctionalInterface` nie jest wymagana, ale to dobra praktyka - kompilator sprawdzi, czy rzeczywi≈õcie masz tylko jednƒÖ abstrakcyjnƒÖ metodƒô.

#### Dlaczego to wa≈ºne?

Functional interfaces to klucz do lambd. Java mo≈ºe przekszta≈Çciƒá lambdƒô w implementacjƒô functional interface, bo wie dok≈Çadnie, kt√≥rƒÖ metodƒô ma zaimplementowaƒá.

```java
// Functional interface
@FunctionalInterface
interface StringProcessor {
    String process(String input);
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Stary spos√≥b - klasa anonimowa
        StringProcessor upperCase1 = new StringProcessor() {
            @Override
            public String process(String input) {
                return input.toUpperCase();
            }
        };
        
        // Nowy spos√≥b - lambda
        StringProcessor upperCase2 = input -> input.toUpperCase();
        
        // Jeszcze kr√≥cej - method reference
        StringProcessor upperCase3 = String::toUpperCase;
        
        // Wszystkie robiƒÖ to samo!
        System.out.println(upperCase1.process("hello")); // HELLO
        System.out.println(upperCase2.process("hello")); // HELLO
        System.out.println(upperCase3.process("hello")); // HELLO
    }
}
```

#### Wbudowane functional interfaces

Java dostarcza gotowe functional interfaces w pakiecie `java.util.function`. Nie musisz tworzyƒá w≈Çasnych dla typowych przypadk√≥w:

```java
import java.util.function.*;

public class BuiltInFunctionalInterfaces {
    public static void main(String[] args) {
        // Predicate<T> - zwraca boolean
        Predicate<String> isEmpty = String::isEmpty;
        Predicate<Integer> isEven = n -> n % 2 == 0;
        
        System.out.println(isEmpty.test("")); // true
        System.out.println(isEven.test(4));   // true
        
        // Function<T, R> - przekszta≈Çca T w R
        Function<String, Integer> stringLength = String::length;
        Function<Integer, String> intToString = Object::toString;
        
        System.out.println(stringLength.apply("Hello")); // 5
        System.out.println(intToString.apply(42));       // "42"
        
        // Consumer<T> - przyjmuje T, nic nie zwraca
        Consumer<String> printer = System.out::println;
        Consumer<List<String>> listCleaner = List::clear;
        
        printer.accept("Hello World!");
        
        // Supplier<T> - nie przyjmuje nic, zwraca T
        Supplier<String> randomString = () -> "Random: " + Math.random();
        Supplier<List<String>> listFactory = ArrayList::new;
        
        System.out.println(randomString.get());
        List<String> newList = listFactory.get();
        
        // UnaryOperator<T> - Function<T, T>
        UnaryOperator<String> addPrefix = s -> "PREFIX_" + s;
        UnaryOperator<Integer> square = n -> n * n;
        
        System.out.println(addPrefix.apply("test")); // PREFIX_test
        System.out.println(square.apply(5));         // 25
        
        // BinaryOperator<T> - BiFunction<T, T, T>
        BinaryOperator<Integer> add = (a, b) -> a + b;
        BinaryOperator<String> concat = (a, b) -> a + b;
        
        System.out.println(add.apply(3, 4));           // 7
        System.out.println(concat.apply("Hello", " World")); // Hello World
    }
}
```

#### Praktyczne zastosowania

**1. Walidacja danych:**

```java
public class ValidationExample {
    // W≈Çasny functional interface dla walidacji
    @FunctionalInterface
    interface Validator<T> {
        boolean isValid(T value);
        
        // Default method dla ≈ÇƒÖczenia walidator√≥w
        default Validator<T> and(Validator<T> other) {
            return value -> this.isValid(value) && other.isValid(value);
        }
        
        default Validator<T> or(Validator<T> other) {
            return value -> this.isValid(value) || other.isValid(value);
        }
    }
    
    public static void main(String[] args) {
        // R√≥≈ºne walidatory
        Validator<String> notNull = value -> value != null;
        Validator<String> notEmpty = value -> !value.isEmpty();
        Validator<String> minLength = value -> value.length() >= 3;
        Validator<String> hasAtSign = value -> value.contains("@");
        
        // Kombinowanie walidator√≥w
        Validator<String> basicStringValidator = notNull.and(notEmpty).and(minLength);
        Validator<String> emailValidator = basicStringValidator.and(hasAtSign);
        
        // Testowanie
        String[] testStrings = {null, "", "ab", "abc", "test@example.com"};
        
        for (String test : testStrings) {
            System.out.println("'" + test + "' - basic: " + 
                safeValidate(basicStringValidator, test) + 
                ", email: " + safeValidate(emailValidator, test));
        }
    }
    
    private static <T> boolean safeValidate(Validator<T> validator, T value) {
        try {
            return validator.isValid(value);
        } catch (Exception e) {
            return false;
        }
    }
}
```

**2. Event handling:**

```java
public class EventHandlingExample {
    @FunctionalInterface
    interface EventHandler<T> {
        void handle(T event);
    }
    
    public static class Event {
        private final String type;
        private final String message;
        private final long timestamp;
        
        public Event(String type, String message) {
            this.type = type;
            this.message = message;
            this.timestamp = System.currentTimeMillis();
        }
        
        public String getType() { return type; }
        public String getMessage() { return message; }
        public long getTimestamp() { return timestamp; }
    }
    
    public static class EventProcessor {
        private final Map<String, List<EventHandler<Event>>> handlers = new HashMap<>();
        
        public void subscribe(String eventType, EventHandler<Event> handler) {
            handlers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(handler);
        }
        
        public void publish(Event event) {
            List<EventHandler<Event>> eventHandlers = handlers.get(event.getType());
            if (eventHandlers != null) {
                eventHandlers.forEach(handler -> handler.handle(event));
            }
        }
    }
    
    public static void main(String[] args) {
        EventProcessor processor = new EventProcessor();
        
        // Subskrypcja z lambdami
        processor.subscribe("USER_LOGIN", event -> 
            System.out.println("Logging: " + event.getMessage()));
        
        processor.subscribe("USER_LOGIN", event -> 
            System.out.println("Analytics: User logged in at " + event.getTimestamp()));
        
        processor.subscribe("ERROR", event -> 
            System.err.println("ERROR: " + event.getMessage()));
        
        // Publikowanie zdarze≈Ñ
        processor.publish(new Event("USER_LOGIN", "User john.doe logged in"));
        processor.publish(new Event("ERROR", "Database connection failed"));
    }
}
```

**3. Strategy pattern z functional interfaces:**

```java
public class StrategyPatternExample {
    @FunctionalInterface
    interface DiscountStrategy {
        double calculateDiscount(double price, int quantity);
    }
    
    public static class Product {
        private final String name;
        private final double price;
        
        public Product(String name, double price) {
            this.name = name;
            this.price = price;
        }
        
        public String getName() { return name; }
        public double getPrice() { return price; }
    }
    
    public static class ShoppingCart {
        private final List<Product> products = new ArrayList<>();
        private DiscountStrategy discountStrategy = (price, qty) -> 0; // No discount by default
        
        public void addProduct(Product product) {
            products.add(product);
        }
        
        public void setDiscountStrategy(DiscountStrategy strategy) {
            this.discountStrategy = strategy;
        }
        
        public double calculateTotal() {
            double total = products.stream()
                .mapToDouble(Product::getPrice)
                .sum();
            
            double discount = discountStrategy.calculateDiscount(total, products.size());
            return total - discount;
        }
    }
    
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        cart.addProduct(new Product("Laptop", 2000));
        cart.addProduct(new Product("Mouse", 50));
        cart.addProduct(new Product("Keyboard", 100));
        
        System.out.println("No discount: " + cart.calculateTotal());
        
        // 10% discount for orders over 1000
        cart.setDiscountStrategy((price, qty) -> price > 1000 ? price * 0.1 : 0);
        System.out.println("10% discount: " + cart.calculateTotal());
        
        // 5% discount per item (max 20%)
        cart.setDiscountStrategy((price, qty) -> Math.min(price * 0.05 * qty, price * 0.2));
        System.out.println("Per item discount: " + cart.calculateTotal());
        
        // Fixed 100 discount for 3+ items
        cart.setDiscountStrategy((price, qty) -> qty >= 3 ? 100 : 0);
        System.out.println("Fixed discount: " + cart.calculateTotal());
    }
}
```

#### Tworzenie w≈Çasnych functional interfaces

```java
public class CustomFunctionalInterfaces {
    // Functional interface dla operacji z dwoma argumentami i wyjƒÖtkiem
    @FunctionalInterface
    interface ThrowingBiFunction<T, U, R> {
        R apply(T t, U u) throws Exception;
    }
    
    // Functional interface dla operacji z trzema argumentami
    @FunctionalInterface
    interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }
    
    // Functional interface dla operacji bez argument√≥w z wyjƒÖtkiem
    @FunctionalInterface
    interface ThrowingSupplier<T> {
        T get() throws Exception;
    }
    
    public static void main(String[] args) {
        // U≈ºycie ThrowingBiFunction
        ThrowingBiFunction<String, String, Integer> stringToInt = (s1, s2) -> {
            return Integer.parseInt(s1) + Integer.parseInt(s2);
        };
        
        try {
            int result = stringToInt.apply("10", "20");
            System.out.println("Result: " + result); // 30
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
        }
        
        // U≈ºycie TriFunction
        TriFunction<String, String, String, String> fullNameFormatter = 
            (first, middle, last) -> first + " " + middle + " " + last;
        
        String fullName = fullNameFormatter.apply("Anna", "Maria", "Kowalska");
        System.out.println("Full name: " + fullName);
        
        // U≈ºycie ThrowingSupplier
        ThrowingSupplier<String> fileReader = () -> {
            // Symulacja czytania pliku
            if (Math.random() > 0.5) {
                throw new IOException("File not found");
            }
            return "File content";
        };
        
        try {
            String content = fileReader.get();
            System.out.println("Content: " + content);
        } catch (Exception e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
    }
}
```

#### Kombinowanie functional interfaces

```java
public class CombiningFunctionalInterfaces {
    public static void main(String[] args) {
        // Kombinowanie Predicate
        Predicate<String> notNull = Objects::nonNull;
        Predicate<String> notEmpty = s -> !s.isEmpty();
        Predicate<String> hasContent = notNull.and(notEmpty);
        
        // Kombinowanie Function
        Function<String, String> trim = String::trim;
        Function<String, String> upperCase = String::toUpperCase;
        Function<String, String> addPrefix = s -> "PROCESSED: " + s;
        
        Function<String, String> pipeline = trim
            .andThen(upperCase)
            .andThen(addPrefix);
        
        // Testowanie
        List<String> testData = Arrays.asList("  hello  ", "", null, "world");
        
        testData.stream()
            .filter(hasContent)
            .map(pipeline)
            .forEach(System.out::println);
        
        // Kombinowanie Consumer
        Consumer<String> print = System.out::println;
        Consumer<String> log = s -> System.err.println("LOG: " + s);
        Consumer<String> combined = print.andThen(log);
        
        combined.accept("Test message");
    }
}
```

#### üí° Wskaz√≥wki dla Juniorek

- **U≈ºywaj @FunctionalInterface**: Kompilator sprawdzi poprawno≈õƒá
- **Poznaj wbudowane interfejsy**: Predicate, Function, Consumer, Supplier
- **Kombinuj proste interfejsy**: Zamiast tworzyƒá skomplikowane
- **Default methods sƒÖ OK**: MogƒÖ byƒá w functional interface
- **Jedna abstrakcyjna metoda**: To jedyny wym√≥g

#### üéØ Zadania dla Juniorek

**Zadanie 1:** Stw√≥rz functional interface `Converter<T, R>` i u≈ºyj go do konwersji r√≥≈ºnych typ√≥w danych.

**Zadanie 2:** Zaimplementuj system filtr√≥w u≈ºywajƒÖc Predicate i kombinowania walidator√≥w.

**Zadanie 3:** Stw√≥rz prosty kalkulator u≈ºywajƒÖc r√≥≈ºnych functional interfaces dla operacji matematycznych.

#### ‚ùì Pytania Kontrolne - Poziom Junior

1. Co to jest functional interface i jakie ma wymagania?
2. Jakie sƒÖ najwa≈ºniejsze wbudowane functional interfaces?
3. Czy functional interface mo≈ºe mieƒá default methods?

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### G≈Çƒôbsza analiza functional interfaces

Functional interfaces to nie tylko sk≈Çadnia - to fundamentalna zmiana w architekturze Javy, wprowadzajƒÖca elementy programowania funkcyjnego do tradycyjnie obiektowego jƒôzyka.

##### Type inference i target typing

```java
public class TypeInferenceExample {
    public static void main(String[] args) {
        // Kompilator dedukuje typ na podstawie kontekstu
        List<String> strings = Arrays.asList("a", "b", "c");
        
        // Target type: Predicate<String>
        strings.stream().filter(s -> s.length() > 1);
        
        // Target type: Function<String, Integer>
        strings.stream().map(s -> s.length());
        
        // Target type: Consumer<String>
        strings.forEach(s -> System.out.println(s));
        
        // Ambiguity resolution
        processString(s -> s.toUpperCase()); // Function<String, String>
        // processString((Function<String, String>) s -> s.toUpperCase()); // Explicit cast if needed
    }
    
    static void processString(Function<String, String> processor) {
        System.out.println("Processing with Function");
    }
    
    static void processString(UnaryOperator<String> processor) {
        System.out.println("Processing with UnaryOperator");
    }
}
```

##### Zaawansowane wzorce z functional interfaces

**1. Monad-like patterns:**

```java
public class MonadPatterns {
    // Optional-like monad
    public static class Result<T> {
        private final T value;
        private final Exception error;
        
        private Result(T value, Exception error) {
            this.value = value;
            this.error = error;
        }
        
        public static <T> Result<T> success(T value) {
            return new Result<>(value, null);
        }
        
        public static <T> Result<T> failure(Exception error) {
            return new Result<>(null, error);
        }
        
        public <R> Result<R> map(Function<T, R> mapper) {
            if (error != null) {
                return Result.failure(error);
            }
            try {
                return Result.success(mapper.apply(value));
            } catch (Exception e) {
                return Result.failure(e);
            }
        }
        
        public <R> Result<R> flatMap(Function<T, Result<R>> mapper) {
            if (error != null) {
                return Result.failure(error);
            }
            try {
                return mapper.apply(value);
            } catch (Exception e) {
                return Result.failure(e);
            }
        }
        
        public T orElse(T defaultValue) {
            return error != null ? defaultValue : value;
        }
        
        public void ifSuccess(Consumer<T> consumer) {
            if (error == null) {
                consumer.accept(value);
            }
        }
        
        public void ifFailure(Consumer<Exception> consumer) {
            if (error != null) {
                consumer.accept(error);
            }
        }
    }
    
    // Usage example
    public static void main(String[] args) {
        Result<String> result = parseAndProcess("123")
            .map(Integer::parseInt)
            .map(i -> i * 2)
            .map(Object::toString)
            .map(s -> "Result: " + s);
        
        result.ifSuccess(System.out::println);
        result.ifFailure(e -> System.err.println("Error: " + e.getMessage()));
    }
    
    private static Result<String> parseAndProcess(String input) {
        if (input == null || input.isEmpty()) {
            return Result.failure(new IllegalArgumentException("Input cannot be null or empty"));
        }
        return Result.success(input);
    }
}
```

**2. Functional composition patterns:**

```java
public class FunctionalComposition {
    // Composable validation
    public static class Validation<T> {
        private final List<Function<T, Optional<String>>> validators = new ArrayList<>();
        
        public Validation<T> addRule(Function<T, Optional<String>> validator) {
            validators.add(validator);
            return this;
        }
        
        public Validation<T> addRule(Predicate<T> predicate, String errorMessage) {
            return addRule(value -> predicate.test(value) ? Optional.empty() : Optional.of(errorMessage));
        }
        
        public List<String> validate(T value) {
            return validators.stream()
                .map(validator -> validator.apply(value))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
        }
        
        public boolean isValid(T value) {
            return validate(value).isEmpty();
        }
    }
    
    // Pipeline pattern
    public static class Pipeline<T> {
        private final List<Function<T, T>> transformations = new ArrayList<>();
        
        public Pipeline<T> add(Function<T, T> transformation) {
            transformations.add(transformation);
            return this;
        }
        
        public Pipeline<T> addIf(Predicate<T> condition, Function<T, T> transformation) {
            return add(value -> condition.test(value) ? transformation.apply(value) : value);
        }
        
        public T execute(T input) {
            return transformations.stream()
                .reduce(Function.identity(), Function::andThen)
                .apply(input);
        }
        
        public List<T> execute(List<T> inputs) {
            return inputs.stream()
                .map(this::execute)
                .collect(Collectors.toList());
        }
    }
    
    public static void main(String[] args) {
        // Validation example
        Validation<String> emailValidation = new Validation<String>()
            .addRule(Objects::nonNull, "Email cannot be null")
            .addRule(s -> !s.trim().isEmpty(), "Email cannot be empty")
            .addRule(s -> s.contains("@"), "Email must contain @")
            .addRule(s -> s.contains("."), "Email must contain .")
            .addRule(s -> s.length() <= 100, "Email too long");
        
        String[] emails = {"test@example.com", "", "invalid", null, "very.long.email.address.that.exceeds.the.maximum.length.limit@example.com"};
        
        for (String email : emails) {
            List<String> errors = emailValidation.validate(email);
            System.out.println("Email: " + email + " - " + 
                (errors.isEmpty() ? "Valid" : "Errors: " + errors));
        }
        
        // Pipeline example
        Pipeline<String> textProcessor = new Pipeline<String>()
            .add(String::trim)
            .add(String::toLowerCase)
            .addIf(s -> s.length() > 10, s -> s.substring(0, 10))
            .add(s -> s.replace(" ", "_"));
        
        List<String> texts = Arrays.asList("  Hello World  ", "JAVA PROGRAMMING", "short");
        List<String> processed = textProcessor.execute(texts);
        
        System.out.println("Original: " + texts);
        System.out.println("Processed: " + processed);
    }
}
```

**3. Event-driven architecture z functional interfaces:**

```java
public class EventDrivenArchitecture {
    // Event interface
    public interface Event {
        String getType();
        long getTimestamp();
        Map<String, Object> getData();
    }
    
    // Generic event implementation
    public static class GenericEvent implements Event {
        private final String type;
        private final long timestamp;
        private final Map<String, Object> data;
        
        public GenericEvent(String type, Map<String, Object> data) {
            this.type = type;
            this.timestamp = System.currentTimeMillis();
            this.data = new HashMap<>(data);
        }
        
        @Override
        public String getType() { return type; }
        
        @Override
        public long getTimestamp() { return timestamp; }
        
        @Override
        public Map<String, Object> getData() { return Collections.unmodifiableMap(data); }
    }
    
    // Event bus with functional interfaces
    public static class EventBus {
        private final Map<String, List<Consumer<Event>>> listeners = new ConcurrentHashMap<>();
        private final List<Function<Event, Event>> middlewares = new ArrayList<>();
        private final ExecutorService executor = Executors.newCachedThreadPool();
        
        // Subscribe to events
        public EventBus subscribe(String eventType, Consumer<Event> listener) {
            listeners.computeIfAbsent(eventType, k -> new ArrayList<>()).add(listener);
            return this;
        }
        
        // Subscribe with filter
        public EventBus subscribe(String eventType, Predicate<Event> filter, Consumer<Event> listener) {
            return subscribe(eventType, event -> {
                if (filter.test(event)) {
                    listener.accept(event);
                }
            });
        }
        
        // Add middleware
        public EventBus addMiddleware(Function<Event, Event> middleware) {
            middlewares.add(middleware);
            return this;
        }
        
        // Publish event synchronously
        public void publish(Event event) {
            Event processedEvent = applyMiddlewares(event);
            List<Consumer<Event>> eventListeners = listeners.get(processedEvent.getType());
            
            if (eventListeners != null) {
                eventListeners.forEach(listener -> {
                    try {
                        listener.accept(processedEvent);
                    } catch (Exception e) {
                        System.err.println("Error in event listener: " + e.getMessage());
                    }
                });
            }
        }
        
        // Publish event asynchronously
        public CompletableFuture<Void> publishAsync(Event event) {
            return CompletableFuture.runAsync(() -> publish(event), executor);
        }
        
        private Event applyMiddlewares(Event event) {
            return middlewares.stream()
                .reduce(Function.identity(), Function::andThen)
                .apply(event);
        }
        
        public void shutdown() {
            executor.shutdown();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        EventBus eventBus = new EventBus();
        
        // Add logging middleware
        eventBus.addMiddleware(event -> {
            System.out.println("Middleware: Processing event " + event.getType());
            return event;
        });
        
        // Add enrichment middleware
        eventBus.addMiddleware(event -> {
            Map<String, Object> enrichedData = new HashMap<>(event.getData());
            enrichedData.put("processed_at", System.currentTimeMillis());
            return new GenericEvent(event.getType(), enrichedData);
        });
        
        // Subscribe to user events
        eventBus.subscribe("user.created", event -> 
            System.out.println("Sending welcome email to: " + event.getData().get("email")));
        
        eventBus.subscribe("user.created", event -> 
            System.out.println("Creating user profile for: " + event.getData().get("userId")));
        
        // Subscribe to order events with filter
        eventBus.subscribe("order.placed", 
            event -> (Double) event.getData().get("amount") > 1000,
            event -> System.out.println("High-value order alert: " + event.getData().get("amount")));
        
        // Subscribe to all events
        eventBus.subscribe("*", event -> 
            System.out.println("Audit log: " + event.getType() + " at " + event.getTimestamp()));
        
        // Publish events
        eventBus.publish(new GenericEvent("user.created", Map.of(
            "userId", "123",
            "email", "user@example.com"
        )));
        
        eventBus.publishAsync(new GenericEvent("order.placed", Map.of(
            "orderId", "456",
            "amount", 1500.0
        ))).join();
        
        Thread.sleep(100); // Wait for async processing
        eventBus.shutdown();
    }
}
```

##### Performance i memory considerations

```java
public class PerformanceConsiderations {
    private static final int ITERATIONS = 1_000_000;
    
    // Functional interface vs method call performance
    @FunctionalInterface
    interface IntOperation {
        int apply(int x);
    }
    
    public static void main(String[] args) {
        // Test 1: Lambda vs method reference vs direct call
        measurePerformance("Direct method call", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += square(i);
            }
            return sum;
        });
        
        IntOperation squareLambda = x -> x * x;
        measurePerformance("Lambda", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += squareLambda.apply(i);
            }
            return sum;
        });
        
        IntOperation squareMethodRef = PerformanceConsiderations::square;
        measurePerformance("Method reference", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += squareMethodRef.apply(i);
            }
            return sum;
        });
        
        // Test 2: Capturing vs non-capturing lambdas
        int multiplier = 2;
        IntOperation capturingLambda = x -> x * multiplier; // Captures 'multiplier'
        IntOperation nonCapturingLambda = x -> x * 2;       // No capture
        
        measurePerformance("Capturing lambda", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += capturingLambda.apply(i);
            }
            return sum;
        });
        
        measurePerformance("Non-capturing lambda", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += nonCapturingLambda.apply(i);
            }
            return sum;
        });
        
        // Test 3: Memory allocation
        System.out.println("\nMemory allocation test:");
        testMemoryAllocation();
    }
    
    private static int square(int x) {
        return x * x;
    }
    
    private static void measurePerformance(String name, Supplier<Integer> operation) {
        // Warm-up
        for (int i = 0; i < 10; i++) {
            operation.get();
        }
        
        long start = System.nanoTime();
        int result = operation.get();
        long end = System.nanoTime();
        
        System.out.printf("%-20s: %6.2f ms (result: %d)%n", 
            name, (end - start) / 1_000_000.0, result);
    }
    
    private static void testMemoryAllocation() {
        Runtime runtime = Runtime.getRuntime();
        
        // Test lambda creation in loop
        runtime.gc();
        long memBefore = runtime.totalMemory() - runtime.freeMemory();
        
        List<Function<Integer, Integer>> lambdas = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            final int multiplier = i;
            lambdas.add(x -> x * multiplier); // Each creates new lambda instance
        }
        
        long memAfter = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used by 10k capturing lambdas: " + 
            (memAfter - memBefore) / 1024 + " KB");
        
        // Test non-capturing lambda reuse
        runtime.gc();
        memBefore = runtime.totalMemory() - runtime.freeMemory();
        
        List<Function<Integer, Integer>> nonCapturingLambdas = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            nonCapturingLambdas.add(x -> x * 2); // Same lambda instance reused
        }
        
        memAfter = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used by 10k non-capturing lambdas: " + 
            (memAfter - memBefore) / 1024 + " KB");
    }
}
```

##### Zaawansowane functional interfaces

```java
public class AdvancedFunctionalInterfaces {
    // Functional interface z multiple type parameters
    @FunctionalInterface
    interface QuadFunction<T, U, V, W, R> {
        R apply(T t, U u, V v, W w);
    }
    
    // Functional interface z exception handling
    @FunctionalInterface
    interface CheckedFunction<T, R> {
        R apply(T t) throws Exception;
        
        // Default method dla error handling
        default Function<T, Optional<R>> safe() {
            return t -> {
                try {
                    return Optional.of(apply(t));
                } catch (Exception e) {
                    return Optional.empty();
                }
            };
        }
        
        // Default method dla unchecked wrapper
        default Function<T, R> unchecked() {
            return t -> {
                try {
                    return apply(t);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            };
        }
    }
    
    // Functional interface z fluent API
    @FunctionalInterface
    interface FluentProcessor<T> {
        T process(T input);
        
        default FluentProcessor<T> andThen(FluentProcessor<T> after) {
            return input -> after.process(this.process(input));
        }
        
        default FluentProcessor<T> compose(FluentProcessor<T> before) {
            return input -> this.process(before.process(input));
        }
        
        default FluentProcessor<T> when(Predicate<T> condition) {
            return input -> condition.test(input) ? this.process(input) : input;
        }
    }
    
    // Memoized function interface
    @FunctionalInterface
    interface MemoizedFunction<T, R> extends Function<T, R> {
        static <T, R> MemoizedFunction<T, R> of(Function<T, R> function) {
            Map<T, R> cache = new ConcurrentHashMap<>();
            return input -> cache.computeIfAbsent(input, function);
        }
        
        default void clearCache() {
            // Implementation would need access to cache
        }
    }
    
    public static void main(String[] args) {
        // QuadFunction example
        QuadFunction<String, String, String, String, String> fullAddress = 
            (street, city, state, zip) -> street + ", " + city + ", " + state + " " + zip;
        
        String address = fullAddress.apply("123 Main St", "Anytown", "CA", "12345");
        System.out.println("Address: " + address);
        
        // CheckedFunction example
        CheckedFunction<String, Integer> parseInt = Integer::parseInt;
        
        Function<String, Optional<Integer>> safeParseInt = parseInt.safe();
        Function<String, Integer> uncheckedParseInt = parseInt.unchecked();
        
        System.out.println("Safe parse '123': " + safeParseInt.apply("123"));
        System.out.println("Safe parse 'abc': " + safeParseInt.apply("abc"));
        
        // FluentProcessor example
        FluentProcessor<String> trimmer = String::trim;
        FluentProcessor<String> upperCase = String::toUpperCase;
        FluentProcessor<String> addPrefix = s -> "PROCESSED: " + s;
        
        FluentProcessor<String> pipeline = trimmer
            .andThen(upperCase)
            .when(s -> s.length() > 5)
            .andThen(addPrefix);
        
        System.out.println("Pipeline result: " + pipeline.process("  hello world  "));
        
        // MemoizedFunction example
        MemoizedFunction<Integer, Integer> fibonacci = MemoizedFunction.of(n -> {
            System.out.println("Computing fibonacci(" + n + ")");
            if (n <= 1) return n;
            return fibonacci.apply(n - 1) + fibonacci.apply(n - 2);
        });
        
        System.out.println("Fibonacci(10): " + fibonacci.apply(10));
        System.out.println("Fibonacci(10) again: " + fibonacci.apply(10)); // Cached
    }
}
```

#### üîß Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj w≈Çasny reactive streams framework u≈ºywajƒÖc functional interfaces.

**Zadanie Zaawansowane 2:** Stw√≥rz type-safe query builder u≈ºywajƒÖc functional interfaces i method chaining.

**Zadanie Zaawansowane 3:** Zaprojektuj middleware system dla web applications u≈ºywajƒÖc functional composition.

#### ‚ùì Pytania Kontrolne - Poziom Senior

1. Jak functional interfaces wp≈ÇywajƒÖ na performance aplikacji?
2. Jaka jest r√≥≈ºnica miƒôdzy capturing a non-capturing lambdami?
3. Jak zaimplementowaƒá w≈Çasny functional interface z zaawansowanymi operacjami?

---

### üîë Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
@FunctionalInterface
public interface Converter<T, R> {
    R convert(T input);
}

public class ConverterExample {
    public static void main(String[] args) {
        // String to Integer
        Converter<String, Integer> stringToInt = Integer::parseInt;
        
        // Integer to String
        Converter<Integer, String> intToString = Object::toString;
        
        // String to uppercase
        Converter<String, String> toUpperCase = String::toUpperCase;
        
        // Double to formatted string
        Converter<Double, String> formatDouble = d -> String.format("%.2f", d);
        
        System.out.println(stringToInt.convert("123"));
        System.out.println(intToString.convert(456));
        System.out.println(toUpperCase.convert("hello"));
        System.out.println(formatDouble.convert(3.14159));
    }
}
```

**Zadanie 2:**
```java
public class FilterSystem {
    public static <T> Predicate<T> and(Predicate<T>... predicates) {
        return Arrays.stream(predicates)
            .reduce(Predicate::and)
            .orElse(x -> true);
    }
    
    public static <T> Predicate<T> or(Predicate<T>... predicates) {
        return Arrays.stream(predicates)
            .reduce(Predicate::or)
            .orElse(x -> false);
    }
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> greaterThan5 = n -> n > 5;
        Predicate<Integer> lessThan10 = n -> n < 10;
        
        // Even numbers greater than 5
        List<Integer> filtered1 = numbers.stream()
            .filter(and(isEven, greaterThan5))
            .collect(Collectors.toList());
        
        // Numbers that are even OR greater than 8
        List<Integer> filtered2 = numbers.stream()
            .filter(or(isEven, n -> n > 8))
            .collect(Collectors.toList());
        
        System.out.println("Even and > 5: " + filtered1);
        System.out.println("Even or > 8: " + filtered2);
    }
}
```

**Zadanie 3:**
```java
public class FunctionalCalculator {
    @FunctionalInterface
    interface MathOperation {
        double calculate(double a, double b);
    }
    
    private static final Map<String, MathOperation> operations = Map.of(
        "+", (a, b) -> a + b,
        "-", (a, b) -> a - b,
        "*", (a, b) -> a * b,
        "/", (a, b) -> b != 0 ? a / b : Double.NaN,
        "^", Math::pow,
        "%", (a, b) -> a % b
    );
    
    public static double calculate(double a, double b, String operator) {
        return operations.getOrDefault(operator, (x, y) -> Double.NaN)
                        .calculate(a, b);
    }
    
    public static void main(String[] args) {
        System.out.println("10 + 5 = " + calculate(10, 5, "+"));
        System.out.println("10 - 5 = " + calculate(10, 5, "-"));
        System.out.println("10 * 5 = " + calculate(10, 5, "*"));
        System.out.println("10 / 5 = " + calculate(10, 5, "/"));
        System.out.println("10 ^ 2 = " + calculate(10, 2, "^"));
    }
}
```

**Pytania kontrolne:**
1. Interfejs z dok≈Çadnie jednƒÖ abstrakcyjnƒÖ metodƒÖ, mo≈ºe mieƒá default i static methods
2. Predicate<T>, Function<T,R>, Consumer<T>, Supplier<T>, UnaryOperator<T>, BinaryOperator<T>
3. Tak, default i static methods nie liczƒÖ siƒô do limitu jednej abstrakcyjnej metody

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Functional interfaces sƒÖ optymalizowane przez JVM, non-capturing lambdy sƒÖ reused, capturing lambdy mogƒÖ mieƒá overhead
2. Capturing lambdy przechwytujƒÖ zmienne z otoczenia i tworzƒÖ nowe instancje, non-capturing sƒÖ reused
3. U≈ºywajƒÖc default methods, static methods, i kompozycji z innymi functional interfaces

---

### üìö Co dalej?

*Fantastycznie! Teraz rozumiesz teoretyczne podstawy lambd i functional interfaces. To fundament nowoczesnego programowania w Javie - od prostych operacji po zaawansowane wzorce architektoniczne. W nastƒôpnym rozdziale porozmawiamy o klasach wewnƒôtrznych i anonimowych - starszych mechanizmach, kt√≥re warto znaƒá dla pe≈Çnego obrazu!*

---

*üí° Pamiƒôtaj: Functional interfaces to most miƒôdzy ≈õwiatem obiektowym a funkcyjnym. U≈ºywaj ich ≈õwiadomie - nie ka≈ºdy problem wymaga functional approach!*


## 19. Klasy wewnƒôtrzne i anonimowe (Inner classes)

*Cze≈õƒá! Dzi≈õ porozmawiamy o klasach wewnƒôtrznych - mechanizmie, kt√≥ry istnia≈Ç w Javie d≈Çugo przed lambdami i nadal ma swoje miejsce. To jak matrioszka - klasy w klasach, ka≈ºda ze swoim przeznaczeniem. Choƒá lambdy zastƒÖpi≈Çy wiele zastosowa≈Ñ klas anonimowych, warto znaƒá te mechanizmy, bo spotkasz je w starszym kodzie i czasami sƒÖ nadal najlepszym rozwiƒÖzaniem!*

---

### üå± Czƒô≈õƒá dla Juniorek

#### Co to sƒÖ klasy wewnƒôtrzne?

Klasa wewnƒôtrzna to klasa zdefiniowana wewnƒÖtrz innej klasy. Java ma cztery typy klas wewnƒôtrznych:

1. **Non-static nested classes (inner classes)** - majƒÖ dostƒôp do wszystkich cz≈Çonk√≥w klasy zewnƒôtrznej
2. **Static nested classes** - nie majƒÖ dostƒôpu do non-static cz≈Çonk√≥w klasy zewnƒôtrznej  
3. **Local classes** - zdefiniowane wewnƒÖtrz metody
4. **Anonymous classes** - klasy bez nazwy, tworzone "w locie"

```java
public class OuterClass {
    private String outerField = "Outer field";
    private static String staticOuterField = "Static outer field";
    
    // 1. Non-static inner class
    public class InnerClass {
        public void display() {
            System.out.println("Dostƒôp do: " + outerField); // OK
            System.out.println("Dostƒôp do: " + staticOuterField); // OK
        }
    }
    
    // 2. Static nested class
    public static class StaticNestedClass {
        public void display() {
            // System.out.println(outerField); // B≈ÅƒÑD! Brak dostƒôpu
            System.out.println("Dostƒôp do: " + staticOuterField); // OK
        }
    }
    
    public void methodWithLocalClass() {
        final String localVar = "Local variable";
        
        // 3. Local class
        class LocalClass {
            public void display() {
                System.out.println("Dostƒôp do: " + outerField); // OK
                System.out.println("Dostƒôp do: " + localVar); // OK (effectively final)
            }
        }
        
        LocalClass local = new LocalClass();
        local.display();
    }
    
    public void methodWithAnonymousClass() {
        // 4. Anonymous class
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous class: " + outerField);
            }
        };
        
        runnable.run();
    }
}
```

#### Praktyczne przyk≈Çady

**1. Iterator pattern z inner class:**

```java
public class MyList<T> {
    private Object[] elements = new Object[10];
    private int size = 0;
    
    public void add(T element) {
        if (size < elements.length) {
            elements[size++] = element;
        }
    }
    
    @SuppressWarnings("unchecked")
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return (T) elements[index];
    }
    
    public int size() {
        return size;
    }
    
    // Inner class implementing Iterator
    public class MyIterator {
        private int currentIndex = 0;
        
        public boolean hasNext() {
            return currentIndex < size;
        }
        
        @SuppressWarnings("unchecked")
        public T next() {
            if (!hasNext()) {
                throw new RuntimeException("No more elements");
            }
            return (T) elements[currentIndex++];
        }
        
        // Ma dostƒôp do prywatnych p√≥l klasy zewnƒôtrznej
        public void remove() {
            if (currentIndex <= 0) {
                throw new RuntimeException("Nothing to remove");
            }
            
            // Przesuniƒôcie element√≥w
            for (int i = currentIndex - 1; i < size - 1; i++) {
                elements[i] = elements[i + 1];
            }
            size--;
            currentIndex--;
        }
    }
    
    public MyIterator iterator() {
        return new MyIterator();
    }
    
    public static void main(String[] args) {
        MyList<String> list = new MyList<>();
        list.add("Anna");
        list.add("Beata");
        list.add("Ewa");
        
        MyList<String>.MyIterator iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

**2. Event handling z anonymous classes:**

```java
public class EventHandlingExample {
    public interface ClickListener {
        void onClick();
    }
    
    public interface KeyListener {
        void onKeyPressed(String key);
    }
    
    public static class Button {
        private String text;
        private ClickListener clickListener;
        
        public Button(String text) {
            this.text = text;
        }
        
        public void setClickListener(ClickListener listener) {
            this.clickListener = listener;
        }
        
        public void click() {
            System.out.println("Button '" + text + "' clicked!");
            if (clickListener != null) {
                clickListener.onClick();
            }
        }
    }
    
    public static void main(String[] args) {
        Button saveButton = new Button("Save");
        Button cancelButton = new Button("Cancel");
        
        // Anonymous class dla save button
        saveButton.setClickListener(new ClickListener() {
            @Override
            public void onClick() {
                System.out.println("Saving data...");
                // Logika zapisywania
            }
        });
        
        // Anonymous class dla cancel button
        cancelButton.setClickListener(new ClickListener() {
            @Override
            public void onClick() {
                System.out.println("Operation cancelled");
                // Logika anulowania
            }
        });
        
        // Testowanie
        saveButton.click();
        cancelButton.click();
        
        // Por√≥wnanie z lambdƒÖ (kr√≥cej!)
        Button deleteButton = new Button("Delete");
        deleteButton.setClickListener(() -> System.out.println("Deleting..."));
        deleteButton.click();
    }
}
```

**3. Builder pattern z static nested class:**

```java
public class User {
    private final String firstName;
    private final String lastName;
    private final String email;
    private final int age;
    private final String city;
    
    // Prywatny konstruktor
    private User(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.email = builder.email;
        this.age = builder.age;
        this.city = builder.city;
    }
    
    // Static nested class Builder
    public static class Builder {
        // Wymagane pola
        private final String firstName;
        private final String lastName;
        
        // Opcjonalne pola z domy≈õlnymi warto≈õciami
        private String email = "";
        private int age = 0;
        private String city = "";
        
        public Builder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }
        
        public Builder email(String email) {
            this.email = email;
            return this;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder city(String city) {
            this.city = city;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
    
    // Gettery
    public String getFirstName() { return firstName; }
    public String getLastName() { return lastName; }
    public String getEmail() { return email; }
    public int getAge() { return age; }
    public String getCity() { return city; }
    
    @Override
    public String toString() {
        return "User{" +
                "firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", age=" + age +
                ", city='" + city + '\'' +
                '}';
    }
    
    public static void main(String[] args) {
        // U≈ºycie Builder pattern
        User user1 = new User.Builder("Anna", "Kowalska")
                .email("anna@example.com")
                .age(25)
                .city("Warszawa")
                .build();
        
        User user2 = new User.Builder("Beata", "Nowak")
                .email("beata@example.com")
                .build(); // Tylko wymagane pola + email
        
        System.out.println(user1);
        System.out.println(user2);
    }
}
```

**4. Local classes dla specjalizowanych operacji:**

```java
public class DataProcessor {
    public void processData(List<String> data, String operation) {
        switch (operation.toLowerCase()) {
            case "sort":
                // Local class dla sortowania
                class SortProcessor {
                    public List<String> process() {
                        return data.stream()
                                .sorted()
                                .collect(Collectors.toList());
                    }
                }
                
                SortProcessor sorter = new SortProcessor();
                List<String> sorted = sorter.process();
                System.out.println("Sorted: " + sorted);
                break;
                
            case "filter":
                // Local class dla filtrowania
                class FilterProcessor {
                    private final int minLength = 3; // Mo≈ºe mieƒá w≈Çasne pola
                    
                    public List<String> process() {
                        return data.stream()
                                .filter(s -> s.length() >= minLength)
                                .collect(Collectors.toList());
                    }
                }
                
                FilterProcessor filter = new FilterProcessor();
                List<String> filtered = filter.process();
                System.out.println("Filtered: " + filtered);
                break;
                
            case "transform":
                final String prefix = "PROCESSED_"; // Effectively final dla local class
                
                // Local class z dostƒôpem do local variables
                class TransformProcessor {
                    public List<String> process() {
                        return data.stream()
                                .map(s -> prefix + s.toUpperCase())
                                .collect(Collectors.toList());
                    }
                }
                
                TransformProcessor transformer = new TransformProcessor();
                List<String> transformed = transformer.process();
                System.out.println("Transformed: " + transformed);
                break;
        }
    }
    
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor();
        List<String> data = Arrays.asList("java", "python", "c++", "go", "rust");
        
        processor.processData(data, "sort");
        processor.processData(data, "filter");
        processor.processData(data, "transform");
    }
}
```

#### Kiedy u≈ºywaƒá kt√≥rych klas?

**Non-static inner classes:**
- Gdy inner class potrzebuje dostƒôpu do instance members outer class
- Iterator patterns, event handlers z dostƒôpem do stanu

**Static nested classes:**
- Builder pattern, helper classes
- Gdy nie potrzebujesz dostƒôpu do instance members outer class

**Local classes:**
- Gdy potrzebujesz klasy tylko w jednej metodzie
- Specjalizowane operacje z dostƒôpem do local variables

**Anonymous classes:**
- Implementacja prostych interfejs√≥w "w locie"
- Event handling (choƒá lambdy sƒÖ teraz lepsze)

#### üí° Wskaz√≥wki dla Juniorek

- **Inner classes majƒÖ dostƒôp do prywatnych cz≈Çonk√≥w** outer class
- **Static nested classes** nie mogƒÖ dostaƒá siƒô do non-static members
- **Local classes** mogƒÖ u≈ºywaƒá effectively final local variables
- **Anonymous classes** sƒÖ dobre dla prostych implementacji
- **Lambdy zastƒÖpi≈Çy wiƒôkszo≈õƒá anonymous classes** dla functional interfaces

#### üéØ Zadania dla Juniorek

**Zadanie 1:** Stw√≥rz klasƒô `Calculator` z inner class `Operation` implementujƒÖcƒÖ r√≥≈ºne operacje matematyczne.

**Zadanie 2:** Zaimplementuj prostƒÖ strukturƒô danych `Stack` z w≈Çasnym iteratorem u≈ºywajƒÖc inner class.

**Zadanie 3:** Stw√≥rz system obs≈Çugi zdarze≈Ñ u≈ºywajƒÖc anonymous classes i por√≥wnaj z lambdami.

#### ‚ùì Pytania Kontrolne - Poziom Junior

1. Jaka jest r√≥≈ºnica miƒôdzy inner class a static nested class?
2. Kiedy u≈ºywaƒá local classes?
3. Czy anonymous class mo≈ºe implementowaƒá wiele interfejs√≥w?

---

### üöÄ Czƒô≈õƒá dla Seniorek

#### G≈Çƒôbsza analiza klas wewnƒôtrznych

Klasy wewnƒôtrzne to nie tylko sk≈Çadnia - to mechanizm enkapsulacji i organizacji kodu, kt√≥ry ma swoje miejsce nawet w erze lambd i nowoczesnej Javy.

##### Memory model i performance implications

```java
public class MemoryAnalysis {
    private String outerField = "Outer";
    
    // Non-static inner class - trzyma referencjƒô do outer instance
    public class InnerClass {
        private String innerField = "Inner";
        
        public void printFields() {
            System.out.println(outerField + " " + innerField);
            // Kompilator generuje: MemoryAnalysis.this.outerField
        }
    }
    
    // Static nested class - nie trzyma referencji do outer instance
    public static class StaticNestedClass {
        private String nestedField = "Nested";
        
        public void printField() {
            System.out.println(nestedField);
            // Brak dostƒôpu do outerField bez explicit reference
        }
    }
    
    public void demonstrateMemoryUsage() {
        // Inner class instance zawsze trzyma referencjƒô do outer instance
        InnerClass inner = new InnerClass();
        
        // To mo≈ºe prowadziƒá do memory leaks!
        List<InnerClass> innerInstances = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            innerInstances.add(new InnerClass());
            // Ka≈ºda instancja trzyma referencjƒô do 'this' (MemoryAnalysis)
        }
        
        // Static nested class nie ma tego problemu
        List<StaticNestedClass> nestedInstances = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            nestedInstances.add(new StaticNestedClass());
            // Brak referencji do outer instance
        }
    }
    
    // Demonstracja synthetic methods
    private void privateMethod() {
        System.out.println("Private method called");
    }
    
    public class AccessingInner {
        public void callPrivateMethod() {
            privateMethod(); // Kompilator generuje synthetic accessor method
        }
    }
}
```

##### Zaawansowane wzorce z inner classes

**1. State pattern z inner classes:**

```java
public class StateMachine {
    private State currentState;
    private String data = "";
    
    public StateMachine() {
        currentState = new IdleState();
    }
    
    public void process(String input) {
        currentState.handle(input);
    }
    
    public void setState(State state) {
        this.currentState = state;
    }
    
    public String getData() {
        return data;
    }
    
    public void setData(String data) {
        this.data = data;
    }
    
    // Abstract state class
    public abstract class State {
        public abstract void handle(String input);
        
        protected void changeState(State newState) {
            System.out.println("Changing state from " + this.getClass().getSimpleName() + 
                             " to " + newState.getClass().getSimpleName());
            setState(newState);
        }
    }
    
    // Concrete states as inner classes
    public class IdleState extends State {
        @Override
        public void handle(String input) {
            if ("start".equals(input)) {
                setData("Processing started");
                changeState(new ProcessingState());
            } else {
                System.out.println("Idle: Ignoring input '" + input + "'");
            }
        }
    }
    
    public class ProcessingState extends State {
        @Override
        public void handle(String input) {
            if ("complete".equals(input)) {
                setData(getData() + " - Completed");
                changeState(new CompletedState());
            } else if ("error".equals(input)) {
                setData(getData() + " - Error occurred");
                changeState(new ErrorState());
            } else {
                setData(getData() + " - Processing: " + input);
            }
        }
    }
    
    public class CompletedState extends State {
        @Override
        public void handle(String input) {
            if ("reset".equals(input)) {
                setData("");
                changeState(new IdleState());
            } else {
                System.out.println("Completed: Cannot process '" + input + "'");
            }
        }
    }
    
    public class ErrorState extends State {
        @Override
        public void handle(String input) {
            if ("reset".equals(input)) {
                setData("");
                changeState(new IdleState());
            } else {
                System.out.println("Error: Cannot process '" + input + "' until reset");
            }
        }
    }
    
    public static void main(String[] args) {
        StateMachine machine = new StateMachine();
        
        machine.process("start");
        System.out.println("Data: " + machine.getData());
        
        machine.process("data1");
        System.out.println("Data: " + machine.getData());
        
        machine.process("complete");
        System.out.println("Data: " + machine.getData());
        
        machine.process("reset");
        System.out.println("Data: " + machine.getData());
    }
}
```

**2. Complex Builder pattern z validation:**

```java
public class ComplexConfiguration {
    private final String host;
    private final int port;
    private final String username;
    private final String password;
    private final boolean sslEnabled;
    private final int timeout;
    private final int retryCount;
    private final Map<String, String> properties;
    
    private ComplexConfiguration(Builder builder) {
        this.host = builder.host;
        this.port = builder.port;
        this.username = builder.username;
        this.password = builder.password;
        this.sslEnabled = builder.sslEnabled;
        this.timeout = builder.timeout;
        this.retryCount = builder.retryCount;
        this.properties = Collections.unmodifiableMap(new HashMap<>(builder.properties));
    }
    
    public static class Builder {
        // Required fields
        private final String host;
        private final int port;
        
        // Optional fields with defaults
        private String username = "";
        private String password = "";
        private boolean sslEnabled = false;
        private int timeout = 5000;
        private int retryCount = 3;
        private Map<String, String> properties = new HashMap<>();
        
        public Builder(String host, int port) {
            this.host = Objects.requireNonNull(host, "Host cannot be null");
            if (port <= 0 || port > 65535) {
                throw new IllegalArgumentException("Port must be between 1 and 65535");
            }
            this.port = port;
        }
        
        public Builder username(String username) {
            this.username = Objects.requireNonNull(username, "Username cannot be null");
            return this;
        }
        
        public Builder password(String password) {
            this.password = Objects.requireNonNull(password, "Password cannot be null");
            return this;
        }
        
        public Builder ssl(boolean enabled) {
            this.sslEnabled = enabled;
            return this;
        }
        
        public Builder timeout(int timeout) {
            if (timeout <= 0) {
                throw new IllegalArgumentException("Timeout must be positive");
            }
            this.timeout = timeout;
            return this;
        }
        
        public Builder retryCount(int retryCount) {
            if (retryCount < 0) {
                throw new IllegalArgumentException("Retry count cannot be negative");
            }
            this.retryCount = retryCount;
            return this;
        }
        
        public Builder property(String key, String value) {
            this.properties.put(
                Objects.requireNonNull(key, "Property key cannot be null"),
                Objects.requireNonNull(value, "Property value cannot be null")
            );
            return this;
        }
        
        public Builder properties(Map<String, String> properties) {
            this.properties.putAll(Objects.requireNonNull(properties, "Properties cannot be null"));
            return this;
        }
        
        // Validation inner class
        private class Validator {
            public void validate() {
                if (sslEnabled && port == 80) {
                    throw new IllegalStateException("SSL cannot be enabled on port 80");
                }
                
                if (!username.isEmpty() && password.isEmpty()) {
                    throw new IllegalStateException("Password required when username is provided");
                }
                
                if (timeout > 60000) {
                    System.out.println("Warning: Timeout > 60s may cause issues");
                }
                
                if (retryCount > 10) {
                    System.out.println("Warning: High retry count may impact performance");
                }
            }
        }
        
        public ComplexConfiguration build() {
            new Validator().validate();
            return new ComplexConfiguration(this);
        }
    }
    
    // Getters
    public String getHost() { return host; }
    public int getPort() { return port; }
    public String getUsername() { return username; }
    public boolean isSslEnabled() { return sslEnabled; }
    public int getTimeout() { return timeout; }
    public int getRetryCount() { return retryCount; }
    public Map<String, String> getProperties() { return properties; }
    
    @Override
    public String toString() {
        return "Configuration{" +
                "host='" + host + '\'' +
                ", port=" + port +
                ", username='" + username + '\'' +
                ", ssl=" + sslEnabled +
                ", timeout=" + timeout +
                ", retryCount=" + retryCount +
                ", properties=" + properties +
                '}';
    }
    
    public static void main(String[] args) {
        try {
            ComplexConfiguration config = new ComplexConfiguration.Builder("localhost", 8080)
                    .username("admin")
                    .password("secret")
                    .ssl(true)
                    .timeout(10000)
                    .retryCount(5)
                    .property("charset", "UTF-8")
                    .property("compression", "gzip")
                    .build();
            
            System.out.println(config);
        } catch (Exception e) {
            System.err.println("Configuration error: " + e.getMessage());
        }
    }
}
```

**3. Advanced Iterator pattern z multiple traversal strategies:**

```java
public class AdvancedTree<T> {
    private Node<T> root;
    
    private static class Node<T> {
        T data;
        Node<T> left, right;
        
        Node(T data) {
            this.data = data;
        }
    }
    
    public void insert(T data) {
        root = insertRec(root, data);
    }
    
    @SuppressWarnings("unchecked")
    private Node<T> insertRec(Node<T> root, T data) {
        if (root == null) {
            return new Node<>(data);
        }
        
        if (((Comparable<T>) data).compareTo(root.data) < 0) {
            root.left = insertRec(root.left, data);
        } else {
            root.right = insertRec(root.right, data);
        }
        
        return root;
    }
    
    // Abstract iterator base class
    public abstract class TreeIterator {
        protected Stack<Node<T>> stack = new Stack<>();
        
        public abstract boolean hasNext();
        public abstract T next();
        
        protected void pushLeft(Node<T> node) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
        }
    }
    
    // In-order iterator (left, root, right)
    public class InOrderIterator extends TreeIterator {
        public InOrderIterator() {
            pushLeft(root);
        }
        
        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            Node<T> node = stack.pop();
            T result = node.data;
            
            if (node.right != null) {
                pushLeft(node.right);
            }
            
            return result;
        }
    }
    
    // Pre-order iterator (root, left, right)
    public class PreOrderIterator extends TreeIterator {
        public PreOrderIterator() {
            if (root != null) {
                stack.push(root);
            }
        }
        
        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            Node<T> node = stack.pop();
            T result = node.data;
            
            // Push right first, then left (stack is LIFO)
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
            
            return result;
        }
    }
    
    // Level-order iterator (breadth-first)
    public class LevelOrderIterator {
        private Queue<Node<T>> queue = new LinkedList<>();
        
        public LevelOrderIterator() {
            if (root != null) {
                queue.offer(root);
            }
        }
        
        public boolean hasNext() {
            return !queue.isEmpty();
        }
        
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            Node<T> node = queue.poll();
            T result = node.data;
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
            
            return result;
        }
    }
    
    // Factory methods for iterators
    public InOrderIterator inOrderIterator() {
        return new InOrderIterator();
    }
    
    public PreOrderIterator preOrderIterator() {
        return new PreOrderIterator();
    }
    
    public LevelOrderIterator levelOrderIterator() {
        return new LevelOrderIterator();
    }
    
    public static void main(String[] args) {
        AdvancedTree<Integer> tree = new AdvancedTree<>();
        int[] values = {5, 3, 7, 2, 4, 6, 8};
        
        for (int value : values) {
            tree.insert(value);
        }
        
        System.out.print("In-order: ");
        AdvancedTree<Integer>.InOrderIterator inOrder = tree.inOrderIterator();
        while (inOrder.hasNext()) {
            System.out.print(inOrder.next() + " ");
        }
        System.out.println();
        
        System.out.print("Pre-order: ");
        AdvancedTree<Integer>.PreOrderIterator preOrder = tree.preOrderIterator();
        while (preOrder.hasNext()) {
            System.out.print(preOrder.next() + " ");
        }
        System.out.println();
        
        System.out.print("Level-order: ");
        AdvancedTree<Integer>.LevelOrderIterator levelOrder = tree.levelOrderIterator();
        while (levelOrder.hasNext()) {
            System.out.print(levelOrder.next() + " ");
        }
        System.out.println();
    }
}
```

##### Anonymous classes vs Lambdas - kiedy co u≈ºywaƒá?

```java
public class AnonymousVsLambda {
    interface SingleMethod {
        void doSomething();
    }
    
    interface MultipleDefaultMethods {
        void primaryMethod();
        
        default void secondaryMethod() {
            System.out.println("Default implementation");
        }
        
        default void anotherMethod() {
            System.out.println("Another default");
        }
    }
    
    abstract class AbstractClass {
        abstract void abstractMethod();
        
        void concreteMethod() {
            System.out.println("Concrete method");
        }
    }
    
    public static void main(String[] args) {
        // Lambda - idealne dla functional interfaces
        SingleMethod lambda = () -> System.out.println("Lambda implementation");
        
        // Anonymous class - gdy potrzebujesz wiƒôcej kontroli
        SingleMethod anonymous = new SingleMethod() {
            private int counter = 0; // Mo≈ºe mieƒá w≈Çasne pola
            
            @Override
            public void doSomething() {
                counter++;
                System.out.println("Anonymous implementation, call #" + counter);
            }
        };
        
        // Anonymous class - gdy implementujesz abstract class
        AbstractClass abstractImpl = new AbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Abstract method implementation");
                concreteMethod(); // Mo≈ºe wywo≈Çywaƒá metody z klasy bazowej
            }
        };
        
        // Anonymous class - gdy potrzebujesz przes≈Çoniƒá default methods
        MultipleDefaultMethods multiImpl = new MultipleDefaultMethods() {
            @Override
            public void primaryMethod() {
                System.out.println("Primary method");
            }
            
            @Override
            public void secondaryMethod() {
                System.out.println("Overridden secondary method");
            }
        };
        
        // Performance comparison
        measurePerformance("Lambda", () -> {
            for (int i = 0; i < 1_000_000; i++) {
                SingleMethod l = () -> {};
                l.doSomething();
            }
        });
        
        measurePerformance("Anonymous class", () -> {
            for (int i = 0; i < 1_000_000; i++) {
                SingleMethod a = new SingleMethod() {
                    @Override
                    public void doSomething() {}
                };
                a.doSomething();
            }
        });
    }
    
    private static void measurePerformance(String name, Runnable operation) {
        long start = System.nanoTime();
        operation.run();
        long end = System.nanoTime();
        System.out.printf("%s: %.2f ms%n", name, (end - start) / 1_000_000.0);
    }
}
```

#### üîß Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj thread-safe cache z inner classes dla r√≥≈ºnych strategii eviction.

**Zadanie Zaawansowane 2:** Stw√≥rz parser expression z visitor pattern u≈ºywajƒÖc inner classes.

**Zadanie Zaawansowane 3:** Zaprojektuj event sourcing system z inner classes dla r√≥≈ºnych typ√≥w event√≥w.

#### ‚ùì Pytania Kontrolne - Poziom Senior

1. Jakie sƒÖ implikacje memory model dla inner classes?
2. Kiedy anonymous classes sƒÖ lepsze od lambd?
3. Jak synthetic methods wp≈ÇywajƒÖ na performance?

---

### üîë Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public class Calculator {
    private double result = 0;
    
    public abstract class Operation {
        protected abstract double execute(double a, double b);
        
        public Calculator apply(double a, double b) {
            result = execute(a, b);
            return Calculator.this;
        }
        
        public double getResult() {
            return result;
        }
    }
    
    public Operation add() {
        return new Operation() {
            @Override
            protected double execute(double a, double b) {
                return a + b;
            }
        };
    }
    
    public Operation multiply() {
        return new Operation() {
            @Override
            protected double execute(double a, double b) {
                return a * b;
            }
        };
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        double result = calc.add().apply(5, 3).getResult();
        System.out.println("Result: " + result); // 8.0
    }
}
```

**Pytania kontrolne:**
1. Inner class ma dostƒôp do wszystkich cz≈Çonk√≥w outer class, static nested class tylko do static cz≈Çonk√≥w
2. Gdy potrzebujesz klasy tylko w jednej metodzie z dostƒôpem do local variables
3. Nie, anonymous class mo≈ºe implementowaƒá tylko jeden interfejs lub rozszerzaƒá jednƒÖ klasƒô

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Inner classes trzymajƒÖ implicit reference do outer instance, co mo≈ºe prowadziƒá do memory leaks
2. Gdy potrzebujesz state, implementujesz abstract class, lub przes≈Çaniasz default methods
3. Synthetic methods sƒÖ generowane przez kompilator dla dostƒôpu do private members, mogƒÖ wp≈Çywaƒá na performance

---
