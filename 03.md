# III. Obiektowość i zaawansowane typy

## 14. OOP po ludzku — dziedziczenie, polimorfizm i enkapsulacja

*Cześć! Dziś zagłębimy się w serce Javy - programowanie obiektowe. Jeśli myślisz, że OOP to tylko klasy i obiekty, to czeka Cię miła niespodzianka. To sposób myślenia o kodzie, który pozwala modelować rzeczywisty świat w programie. Dziedziczenie, polimorfizm, enkapsulacja - brzmi skomplikowanie? Spokojnie, wyjaśnię Ci to wszystko prostymi słowami, jak podczas rozmowy przy kawie!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Programowanie obiektowe (OOP) to sposób organizowania kodu wokół obiektów - rzeczy, które mają właściwości (pola) i zachowania (metody). To jak myślenie o programie jako o zbiorze współpracujących ze sobą obiektów, podobnie jak w rzeczywistym świecie.

```java
// Myśl o obiekcie jak o rzeczywistej rzeczy
public class Samochod {
    // Właściwości (co ma)
    private String marka;
    private String model;
    private int rokProdukcji;
    private boolean wlaczony;
    
    // Zachowania (co może robić)
    public void wlacz() {
        wlaczony = true;
        System.out.println("Samochód został włączony");
    }
    
    public void wylacz() {
        wlaczony = false;
        System.out.println("Samochód został wyłączony");
    }
    
    public void jedz() {
        if (wlaczony) {
            System.out.println("Samochód jedzie");
        } else {
            System.out.println("Najpierw włącz samochód!");
        }
    }
}
```

#### Dlaczego to ważne?

OOP pozwala tworzyć kod, który jest:
- **Zrozumiały** - modeluje rzeczywisty świat
- **Wielokrotnego użytku** - raz napisane klasy można używać w wielu miejscach
- **Łatwy w utrzymaniu** - zmiany w jednym miejscu nie psują reszty
- **Skalowalny** - łatwo dodawać nowe funkcjonalności

#### Enkapsulacja - ukrywanie szczegółów

Enkapsulacja to ukrywanie wewnętrznych szczegółów obiektu i udostępnianie tylko tego, co potrzebne na zewnątrz.

```java
public class KontoBankowe {
    // Prywatne pola - nikt z zewnątrz nie może ich bezpośrednio zmieniać
    private String numerKonta;
    private double saldo;
    private String wlasciciel;
    
    public KontoBankowe(String numerKonta, String wlasciciel) {
        this.numerKonta = numerKonta;
        this.wlasciciel = wlasciciel;
        this.saldo = 0.0;
    }
    
    // Publiczne metody - kontrolowany dostęp do danych
    public void wplac(double kwota) {
        if (kwota > 0) {
            saldo += kwota;
            System.out.println("Wpłacono: " + kwota + " zł");
        } else {
            System.out.println("Kwota musi być większa od zera");
        }
    }
    
    public boolean wyplac(double kwota) {
        if (kwota > 0 && kwota <= saldo) {
            saldo -= kwota;
            System.out.println("Wypłacono: " + kwota + " zł");
            return true;
        } else {
            System.out.println("Niewystarczające środki lub nieprawidłowa kwota");
            return false;
        }
    }
    
    // Getter - kontrolowany dostęp do odczytu
    public double getSaldo() {
        return saldo;
    }
    
    public String getWlasciciel() {
        return wlasciciel;
    }
    
    // Nie ma settera dla saldo - można je zmieniać tylko przez wpłaty/wypłaty!
}

// Użycie
public class TestKonta {
    public static void main(String[] args) {
        KontoBankowe konto = new KontoBankowe("123456789", "Anna Kowalska");
        
        konto.wplac(1000);
        System.out.println("Saldo: " + konto.getSaldo());
        
        konto.wyplac(300);
        System.out.println("Saldo: " + konto.getSaldo());
        
        // To nie zadziała - pole jest prywatne!
        // konto.saldo = 1000000;  // Błąd kompilacji!
    }
}
```

#### Dziedziczenie - budowanie na istniejących klasach

Dziedziczenie pozwala tworzyć nowe klasy na podstawie istniejących, dziedzicząc ich właściwości i zachowania.

```java
// Klasa bazowa (nadklasa)
public class Zwierze {
    protected String imie;
    protected int wiek;
    
    public Zwierze(String imie, int wiek) {
        this.imie = imie;
        this.wiek = wiek;
    }
    
    public void jedz() {
        System.out.println(imie + " je");
    }
    
    public void spij() {
        System.out.println(imie + " śpi");
    }
    
    public void wydajDzwiek() {
        System.out.println(imie + " wydaje dźwięk");
    }
    
    // Gettery
    public String getImie() { return imie; }
    public int getWiek() { return wiek; }
}

// Klasa pochodna (podklasa)
public class Pies extends Zwierze {
    private String rasa;
    
    public Pies(String imie, int wiek, String rasa) {
        super(imie, wiek);  // Wywołanie konstruktora nadklasy
        this.rasa = rasa;
    }
    
    // Przesłanianie metody (override)
    @Override
    public void wydajDzwiek() {
        System.out.println(imie + " szczeka: Hau hau!");
    }
    
    // Nowa metoda specyficzna dla psa
    public void aportuj() {
        System.out.println(imie + " aportuje piłkę");
    }
    
    public String getRasa() { return rasa; }
}

public class Kot extends Zwierze {
    private boolean domowy;
    
    public Kot(String imie, int wiek, boolean domowy) {
        super(imie, wiek);
        this.domowy = domowy;
    }
    
    @Override
    public void wydajDzwiek() {
        System.out.println(imie + " miauczy: Miau miau!");
    }
    
    public void mruczenie() {
        System.out.println(imie + " mruczy");
    }
    
    public boolean isDomowy() { return domowy; }
}

// Użycie
public class TestZwierzat {
    public static void main(String[] args) {
        Pies pies = new Pies("Burek", 3, "Labrador");
        Kot kot = new Kot("Mruczek", 2, true);
        
        // Metody dziedziczone z Zwierze
        pies.jedz();
        kot.spij();
        
        // Przesłonięte metody
        pies.wydajDzwiek();  // Szczeka
        kot.wydajDzwiek();   // Miauczy
        
        // Metody specyficzne dla podklas
        pies.aportuj();
        kot.mruczenie();
        
        System.out.println("Pies " + pies.getImie() + " to " + pies.getRasa());
        System.out.println("Kot " + kot.getImie() + " jest " + 
                          (kot.isDomowy() ? "domowy" : "dziki"));
    }
}
```

#### Polimorfizm - jedna forma, wiele zachowań

Polimorfizm pozwala traktować obiekty różnych klas w jednolity sposób, jeśli dziedziczą z tej samej nadklasy.

```java
public class TestPolimorfizmu {
    public static void main(String[] args) {
        // Polimorfizm - referencja nadklasy może wskazywać na obiekty podklas
        Zwierze[] zwierzeta = {
            new Pies("Burek", 3, "Labrador"),
            new Kot("Mruczek", 2, true),
            new Pies("Azor", 5, "Owczarek"),
            new Kot("Filemon", 1, false)
        };
        
        // Jedna pętla obsługuje wszystkie typy zwierząt!
        for (Zwierze zwierze : zwierzeta) {
            System.out.println("--- " + zwierze.getImie() + " ---");
            zwierze.jedz();
            zwierze.wydajDzwiek();  // Każde zwierzę wydaje swój dźwięk!
            
            // Sprawdzanie typu i rzutowanie
            if (zwierze instanceof Pies) {
                Pies pies = (Pies) zwierze;
                pies.aportuj();
            } else if (zwierze instanceof Kot) {
                Kot kot = (Kot) zwierze;
                kot.mruczenie();
            }
        }
    }
    
    // Metoda przyjmująca dowolne zwierzę
    public static void opiekujSie(Zwierze zwierze) {
        System.out.println("Opiekuję się " + zwierze.getImie());
        zwierze.jedz();
        zwierze.spij();
        zwierze.wydajDzwiek();
    }
}
```

#### Abstrakcyjne klasy i metody

Czasami chcemy zdefiniować klasę, która nie może być bezpośrednio instancjonowana, ale służy jako szablon dla podklas.

```java
// Abstrakcyjna klasa
public abstract class Ksztalt {
    protected String kolor;
    
    public Ksztalt(String kolor) {
        this.kolor = kolor;
    }
    
    // Zwykła metoda
    public String getKolor() {
        return kolor;
    }
    
    // Abstrakcyjna metoda - musi być zaimplementowana w podklasach
    public abstract double obliczPole();
    public abstract double obliczObwod();
    
    // Metoda używająca abstrakcyjnych metod
    public void wyswietlInfo() {
        System.out.println("Kształt w kolorze " + kolor);
        System.out.println("Pole: " + obliczPole());
        System.out.println("Obwód: " + obliczObwod());
    }
}

public class Prostokat extends Ksztalt {
    private double szerokosc;
    private double wysokosc;
    
    public Prostokat(String kolor, double szerokosc, double wysokosc) {
        super(kolor);
        this.szerokosc = szerokosc;
        this.wysokosc = wysokosc;
    }
    
    @Override
    public double obliczPole() {
        return szerokosc * wysokosc;
    }
    
    @Override
    public double obliczObwod() {
        return 2 * (szerokosc + wysokosc);
    }
}

public class Kolo extends Ksztalt {
    private double promien;
    
    public Kolo(String kolor, double promien) {
        super(kolor);
        this.promien = promien;
    }
    
    @Override
    public double obliczPole() {
        return Math.PI * promien * promien;
    }
    
    @Override
    public double obliczObwod() {
        return 2 * Math.PI * promien;
    }
}

// Użycie
public class TestKsztaltow {
    public static void main(String[] args) {
        // Nie można utworzyć obiektu abstrakcyjnej klasy
        // Ksztalt ksztalt = new Ksztalt("czerwony");  // Błąd!
        
        Ksztalt[] ksztalty = {
            new Prostokat("niebieski", 5, 3),
            new Kolo("czerwony", 4),
            new Prostokat("zielony", 2, 2)
        };
        
        for (Ksztalt ksztalt : ksztalty) {
            ksztalt.wyswietlInfo();
            System.out.println();
        }
    }
}
```

#### Kompozycja vs dziedziczenie

Nie zawsze dziedziczenie jest najlepszym rozwiązaniem. Czasami lepiej użyć kompozycji.

```java
// Kompozycja - "ma" zamiast "jest"
public class Silnik {
    private int moc;
    private String typ;
    
    public Silnik(int moc, String typ) {
        this.moc = moc;
        this.typ = typ;
    }
    
    public void uruchom() {
        System.out.println("Silnik " + typ + " (" + moc + " KM) został uruchomiony");
    }
    
    public void zatrzymaj() {
        System.out.println("Silnik został zatrzymany");
    }
    
    public int getMoc() { return moc; }
    public String getTyp() { return typ; }
}

public class Samochod {
    private String marka;
    private String model;
    private Silnik silnik;  // Kompozycja - samochód "ma" silnik
    
    public Samochod(String marka, String model, Silnik silnik) {
        this.marka = marka;
        this.model = model;
        this.silnik = silnik;
    }
    
    public void uruchom() {
        System.out.println("Uruchamiam " + marka + " " + model);
        silnik.uruchom();
    }
    
    public void zatrzymaj() {
        System.out.println("Zatrzymuję " + marka + " " + model);
        silnik.zatrzymaj();
    }
    
    public void wyswietlInfo() {
        System.out.println(marka + " " + model + " z silnikiem " + 
                          silnik.getTyp() + " (" + silnik.getMoc() + " KM)");
    }
}

// Użycie
public class TestKompozycji {
    public static void main(String[] args) {
        Silnik silnikBenzyna = new Silnik(150, "benzyna");
        Silnik silnikDiesel = new Silnik(120, "diesel");
        
        Samochod toyota = new Samochod("Toyota", "Corolla", silnikBenzyna);
        Samochod volkswagen = new Samochod("Volkswagen", "Golf", silnikDiesel);
        
        toyota.wyswietlInfo();
        toyota.uruchom();
        toyota.zatrzymaj();
        
        System.out.println();
        
        volkswagen.wyswietlInfo();
        volkswagen.uruchom();
        volkswagen.zatrzymaj();
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Nadużywanie dziedziczenia**

```java
// ŹLE - dziedziczenie dla współdzielenia kodu
public class Osoba {
    protected String imie;
    protected String adres;
    
    public void wyswietlInfo() {
        System.out.println(imie + ", " + adres);
    }
}

public class Samochod extends Osoba {  // To nie ma sensu!
    private String marka;
    // Samochód nie "jest" osobą!
}

// DOBRZE - kompozycja lub wspólny interfejs
public interface Wyswietlalny {
    void wyswietlInfo();
}

public class Osoba implements Wyswietlalny {
    private String imie;
    private String adres;
    
    @Override
    public void wyswietlInfo() {
        System.out.println(imie + ", " + adres);
    }
}

public class Samochod implements Wyswietlalny {
    private String marka;
    private String model;
    
    @Override
    public void wyswietlInfo() {
        System.out.println(marka + " " + model);
    }
}
```

**Pułapka 2: Łamanie enkapsulacji przez protected**

```java
public class Bazowa {
    protected int wartosc;  // Dostępne dla podklas
}

public class Pochodna extends Bazowa {
    public void zepsujEnkapsulacje() {
        wartosc = -999;  // Podklasa może zepsuć stan nadklasy!
    }
}

// Lepiej: prywatne pola + protected metody
public class LepszaBazowa {
    private int wartosc;
    
    protected int getWartosc() { return wartosc; }
    protected void setWartosc(int wartosc) {
        if (wartosc >= 0) {  // Walidacja
            this.wartosc = wartosc;
        }
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Enkapsulacja** - ukrywaj szczegóły implementacji
- **Dziedziczenie** - używaj gdy jest relacja "jest" (is-a)
- **Kompozycja** - używaj gdy jest relacja "ma" (has-a)
- **Polimorfizm** - jedna metoda, różne zachowania
- **Abstrakcyjne klasy** - gdy chcesz wymusić implementację metod

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz hierarchię klas dla różnych typów pracowników (Manager, Developer, Designer) z polimorficzną metodą obliczania wynagrodzenia.

**Zadanie 2:** Zaprojektuj system biblioteki z klasami Book, Author, Library używając kompozycji.

**Zadanie 3:** Zaimplementuj abstrakcyjną klasę Vehicle z konkretnymi implementacjami Car, Bike, Truck.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między dziedziczeniem a kompozycją?
2. Kiedy używać abstrakcyjnych klas?
3. Co to jest polimorfizm i jak działa?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

OOP w Javie to nie tylko składnia - to zestaw wzorców projektowych i zasad, które pozwalają budować skalowalne, maintainable systemy. Przyjrzyjmy się zaawansowanym aspektom i best practices.

##### SOLID Principles w praktyce

```java
// Single Responsibility Principle (SRP)
// ŹLE - klasa robi za dużo
public class User {
    private String name;
    private String email;
    
    public void save() {
        // Logika zapisu do bazy danych
        System.out.println("Saving user to database");
    }
    
    public void sendEmail() {
        // Logika wysyłania emaili
        System.out.println("Sending email to " + email);
    }
    
    public String generateReport() {
        // Logika generowania raportów
        return "User report for " + name;
    }
}

// DOBRZE - każda klasa ma jedną odpowiedzialność
public class User {
    private String name;
    private String email;
    
    // Tylko dane użytkownika
    public String getName() { return name; }
    public String getEmail() { return email; }
}

public class UserRepository {
    public void save(User user) {
        System.out.println("Saving user to database");
    }
    
    public User findById(String id) {
        // Logika wyszukiwania
        return new User();
    }
}

public class EmailService {
    public void sendEmail(User user, String message) {
        System.out.println("Sending email to " + user.getEmail());
    }
}

public class ReportGenerator {
    public String generateUserReport(User user) {
        return "User report for " + user.getName();
    }
}

// Open/Closed Principle (OCP)
// Klasy otwarte na rozszerzenia, zamknięte na modyfikacje
public abstract class Shape {
    public abstract double calculateArea();
}

public class Rectangle extends Shape {
    private double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

public class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

// Można dodać nowe kształty bez modyfikacji istniejącego kodu
public class Triangle extends Shape {
    private double base, height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

// Liskov Substitution Principle (LSP)
// Obiekty podklas muszą być zastępowalne obiektami nadklasy
public class Bird {
    public void fly() {
        System.out.println("Bird is flying");
    }
}

// ŹLE - łamie LSP
public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

// DOBRZE - lepszy design
public abstract class Bird {
    public abstract void move();
}

public class FlyingBird extends Bird {
    @Override
    public void move() {
        fly();
    }
    
    protected void fly() {
        System.out.println("Flying");
    }
}

public class SwimmingBird extends Bird {
    @Override
    public void move() {
        swim();
    }
    
    protected void swim() {
        System.out.println("Swimming");
    }
}

public class Eagle extends FlyingBird {}
public class Penguin extends SwimmingBird {}

// Interface Segregation Principle (ISP)
// Klienci nie powinni zależeć od interfejsów, których nie używają

// ŹLE - fat interface
public interface Worker {
    void work();
    void eat();
    void sleep();
}

// DOBRZE - segregated interfaces
public interface Workable {
    void work();
}

public interface Eater {
    void eat();
}

public interface Sleeper {
    void sleep();
}

public class Human implements Workable, Eater, Sleeper {
    @Override
    public void work() { System.out.println("Human working"); }
    
    @Override
    public void eat() { System.out.println("Human eating"); }
    
    @Override
    public void sleep() { System.out.println("Human sleeping"); }
}

public class Robot implements Workable {
    @Override
    public void work() { System.out.println("Robot working"); }
    // Robot nie musi implementować eat() i sleep()
}

// Dependency Inversion Principle (DIP)
// Zależności powinny być od abstrakcji, nie od konkretnych implementacji

// ŹLE - zależność od konkretnej klasy
public class OrderService {
    private EmailService emailService = new EmailService();  // Tight coupling
    
    public void processOrder(Order order) {
        // Process order
        emailService.sendEmail(order.getCustomer(), "Order processed");
    }
}

// DOBRZE - zależność od abstrakcji
public interface NotificationService {
    void sendNotification(String recipient, String message);
}

public class EmailNotificationService implements NotificationService {
    @Override
    public void sendNotification(String recipient, String message) {
        System.out.println("Sending email to " + recipient + ": " + message);
    }
}

public class SMSNotificationService implements NotificationService {
    @Override
    public void sendNotification(String recipient, String message) {
        System.out.println("Sending SMS to " + recipient + ": " + message);
    }
}

public class OrderService {
    private final NotificationService notificationService;
    
    // Dependency injection
    public OrderService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
    
    public void processOrder(Order order) {
        // Process order
        notificationService.sendNotification(
            order.getCustomer().getEmail(), 
            "Order processed"
        );
    }
}
```

##### Zaawansowane wzorce dziedziczenia

```java
// Template Method Pattern
public abstract class DataProcessor {
    // Template method - definiuje algorytm
    public final void processData() {
        loadData();
        validateData();
        transformData();
        saveData();
        cleanup();
    }
    
    // Kroki do zaimplementowania przez podklasy
    protected abstract void loadData();
    protected abstract void validateData();
    protected abstract void transformData();
    protected abstract void saveData();
    
    // Hook method - opcjonalne do przesłonięcia
    protected void cleanup() {
        System.out.println("Default cleanup");
    }
}

public class CSVDataProcessor extends DataProcessor {
    @Override
    protected void loadData() {
        System.out.println("Loading CSV data");
    }
    
    @Override
    protected void validateData() {
        System.out.println("Validating CSV format");
    }
    
    @Override
    protected void transformData() {
        System.out.println("Transforming CSV data");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving to database");
    }
    
    @Override
    protected void cleanup() {
        System.out.println("Closing CSV file");
    }
}

public class XMLDataProcessor extends DataProcessor {
    @Override
    protected void loadData() {
        System.out.println("Loading XML data");
    }
    
    @Override
    protected void validateData() {
        System.out.println("Validating XML schema");
    }
    
    @Override
    protected void transformData() {
        System.out.println("Transforming XML data");
    }
    
    @Override
    protected void saveData() {
        System.out.println("Saving to database");
    }
}

// Strategy Pattern z dziedziczeniem
public abstract class SortingStrategy {
    public abstract <T extends Comparable<T>> void sort(T[] array);
    
    // Template method dla benchmarking
    public final <T extends Comparable<T>> long sortWithTiming(T[] array) {
        long start = System.nanoTime();
        sort(array);
        long end = System.nanoTime();
        return end - start;
    }
}

public class QuickSort extends SortingStrategy {
    @Override
    public <T extends Comparable<T>> void sort(T[] array) {
        quickSort(array, 0, array.length - 1);
    }
    
    private <T extends Comparable<T>> void quickSort(T[] array, int low, int high) {
        if (low < high) {
            int pi = partition(array, low, high);
            quickSort(array, low, pi - 1);
            quickSort(array, pi + 1, high);
        }
    }
    
    private <T extends Comparable<T>> int partition(T[] array, int low, int high) {
        T pivot = array[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (array[j].compareTo(pivot) <= 0) {
                i++;
                T temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
        
        T temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;
        
        return i + 1;
    }
}

public class MergeSort extends SortingStrategy {
    @Override
    public <T extends Comparable<T>> void sort(T[] array) {
        mergeSort(array, 0, array.length - 1);
    }
    
    private <T extends Comparable<T>> void mergeSort(T[] array, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(array, left, mid);
            mergeSort(array, mid + 1, right);
            merge(array, left, mid, right);
        }
    }
    
    @SuppressWarnings("unchecked")
    private <T extends Comparable<T>> void merge(T[] array, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        T[] leftArray = (T[]) new Comparable[n1];
        T[] rightArray = (T[]) new Comparable[n2];
        
        System.arraycopy(array, left, leftArray, 0, n1);
        System.arraycopy(array, mid + 1, rightArray, 0, n2);
        
        int i = 0, j = 0, k = left;
        
        while (i < n1 && j < n2) {
            if (leftArray[i].compareTo(rightArray[j]) <= 0) {
                array[k] = leftArray[i];
                i++;
            } else {
                array[k] = rightArray[j];
                j++;
            }
            k++;
        }
        
        while (i < n1) {
            array[k] = leftArray[i];
            i++;
            k++;
        }
        
        while (j < n2) {
            array[k] = rightArray[j];
            j++;
            k++;
        }
    }
}
```

##### Composition over inheritance patterns

```java
// Decorator Pattern z kompozycją
public interface Coffee {
    String getDescription();
    double getCost();
}

public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple coffee";
    }
    
    @Override
    public double getCost() {
        return 2.0;
    }
}

public abstract class CoffeeDecorator implements Coffee {
    protected final Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription();
    }
    
    @Override
    public double getCost() {
        return coffee.getCost();
    }
}

public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", milk";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", sugar";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.2;
    }
}

// Użycie
Coffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " costs $" + coffee.getCost());

// Bridge Pattern
public interface DrawingAPI {
    void drawCircle(double x, double y, double radius);
}

public class DrawingAPI1 implements DrawingAPI {
    @Override
    public void drawCircle(double x, double y, double radius) {
        System.out.printf("API1.circle at %f:%f radius %f%n", x, y, radius);
    }
}

public class DrawingAPI2 implements DrawingAPI {
    @Override
    public void drawCircle(double x, double y, double radius) {
        System.out.printf("API2.circle at %f:%f radius %f%n", x, y, radius);
    }
}

public abstract class Shape {
    protected DrawingAPI drawingAPI;
    
    protected Shape(DrawingAPI drawingAPI) {
        this.drawingAPI = drawingAPI;
    }
    
    public abstract void draw();
    public abstract void resizeByPercentage(double pct);
}

public class CircleShape extends Shape {
    private double x, y, radius;
    
    public CircleShape(double x, double y, double radius, DrawingAPI drawingAPI) {
        super(drawingAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        drawingAPI.drawCircle(x, y, radius);
    }
    
    @Override
    public void resizeByPercentage(double pct) {
        radius *= (1.0 + pct / 100.0);
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj system plugin'ów używając abstract factory pattern z dziedziczeniem i kompozycją.

**Zadanie Zaawansowane 2:** Stwórz framework do obsługi eventów z hierarchią klas event'ów i polimorficznym dispatchingiem.

**Zadanie Zaawansowane 3:** Zaprojektuj system permission management z multiple inheritance simulation przez interfaces i composition.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak SOLID principles wpływają na design klas i hierarchii dziedziczenia?
2. Kiedy preferować composition over inheritance i dlaczego?
3. Jak template method pattern różni się od strategy pattern w kontekście dziedziczenia?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public abstract class Pracownik {
    protected String imie;
    protected String nazwisko;
    protected double podstawa;
    
    public Pracownik(String imie, String nazwisko, double podstawa) {
        this.imie = imie;
        this.nazwisko = nazwisko;
        this.podstawa = podstawa;
    }
    
    public abstract double obliczWynagrodzenie();
    
    public String getPelneImie() {
        return imie + " " + nazwisko;
    }
    
    public void wyswietlInfo() {
        System.out.println(getPelneImie() + " - wynagrodzenie: " + obliczWynagrodzenie());
    }
}

public class Manager extends Pracownik {
    private double bonus;
    
    public Manager(String imie, String nazwisko, double podstawa, double bonus) {
        super(imie, nazwisko, podstawa);
        this.bonus = bonus;
    }
    
    @Override
    public double obliczWynagrodzenie() {
        return podstawa + bonus;
    }
}

public class Developer extends Pracownik {
    private int przepracowaneGodziny;
    private double stawkaGodzinowa;
    
    public Developer(String imie, String nazwisko, double podstawa, int godziny, double stawka) {
        super(imie, nazwisko, podstawa);
        this.przepracowaneGodziny = godziny;
        this.stawkaGodzinowa = stawka;
    }
    
    @Override
    public double obliczWynagrodzenie() {
        return podstawa + (przepracowaneGodziny * stawkaGodzinowa);
    }
}

public class Designer extends Pracownik {
    private int liczbaProjektow;
    private double stawkaZaProjekt;
    
    public Designer(String imie, String nazwisko, double podstawa, int projekty, double stawka) {
        super(imie, nazwisko, podstawa);
        this.liczbaProjektow = projekty;
        this.stawkaZaProjekt = stawka;
    }
    
    @Override
    public double obliczWynagrodzenie() {
        return podstawa + (liczbaProjektow * stawkaZaProjekt);
    }
}
```

**Zadanie 2:**
```java
public class Author {
    private String imie;
    private String nazwisko;
    private String narodowosc;
    
    public Author(String imie, String nazwisko, String narodowosc) {
        this.imie = imie;
        this.nazwisko = nazwisko;
        this.narodowosc = narodowosc;
    }
    
    public String getPelneImie() {
        return imie + " " + nazwisko;
    }
    
    // gettery...
}

public class Book {
    private String tytul;
    private Author autor;
    private String isbn;
    private int rokWydania;
    private boolean dostepna;
    
    public Book(String tytul, Author autor, String isbn, int rokWydania) {
        this.tytul = tytul;
        this.autor = autor;
        this.isbn = isbn;
        this.rokWydania = rokWydania;
        this.dostepna = true;
    }
    
    public void wypozycz() {
        if (dostepna) {
            dostepna = false;
            System.out.println("Książka '" + tytul + "' została wypożyczona");
        } else {
            System.out.println("Książka '" + tytul + "' jest już wypożyczona");
        }
    }
    
    public void zwroc() {
        dostepna = true;
        System.out.println("Książka '" + tytul + "' została zwrócona");
    }
    
    // gettery...
}

public class Library {
    private List<Book> ksiazki;
    private String nazwa;
    
    public Library(String nazwa) {
        this.nazwa = nazwa;
        this.ksiazki = new ArrayList<>();
    }
    
    public void dodajKsiazke(Book ksiazka) {
        ksiazki.add(ksiazka);
    }
    
    public List<Book> znajdzKsiazki(String tytul) {
        return ksiazki.stream()
                     .filter(book -> book.getTytul().toLowerCase().contains(tytul.toLowerCase()))
                     .collect(Collectors.toList());
    }
    
    public List<Book> znajdzKsiazkiAutora(String autor) {
        return ksiazki.stream()
                     .filter(book -> book.getAutor().getPelneImie().toLowerCase().contains(autor.toLowerCase()))
                     .collect(Collectors.toList());
    }
    
    public void wyswietlDostepneKsiazki() {
        ksiazki.stream()
               .filter(Book::isDostepna)
               .forEach(book -> System.out.println(book.getTytul() + " - " + book.getAutor().getPelneImie()));
    }
}
```

**Zadanie 3:**
```java
public abstract class Vehicle {
    protected String marka;
    protected String model;
    protected int rokProdukcji;
    protected double predkosc;
    
    public Vehicle(String marka, String model, int rokProdukcji) {
        this.marka = marka;
        this.model = model;
        this.rokProdukcji = rokProdukcji;
        this.predkosc = 0;
    }
    
    public abstract void uruchom();
    public abstract void zatrzymaj();
    public abstract double obliczZuzyciePaliwa(double dystans);
    
    public void przyspiesz(double deltaPredkosc) {
        predkosc += deltaPredkosc;
        System.out.println(marka + " " + model + " przyspiesza do " + predkosc + " km/h");
    }
    
    public void zwolnij(double deltaPredkosc) {
        predkosc = Math.max(0, predkosc - deltaPredkosc);
        System.out.println(marka + " " + model + " zwalnia do " + predkosc + " km/h");
    }
    
    public void wyswietlInfo() {
        System.out.println(marka + " " + model + " (" + rokProdukcji + ") - prędkość: " + predkosc + " km/h");
    }
}

public class Car extends Vehicle {
    private int liczbaDrzwi;
    
    public Car(String marka, String model, int rokProdukcji, int liczbaDrzwi) {
        super(marka, model, rokProdukcji);
        this.liczbaDrzwi = liczbaDrzwi;
    }
    
    @Override
    public void uruchom() {
        System.out.println("Samochód " + marka + " " + model + " został uruchomiony");
    }
    
    @Override
    public void zatrzymaj() {
        predkosc = 0;
        System.out.println("Samochód " + marka + " " + model + " został zatrzymany");
    }
    
    @Override
    public double obliczZuzyciePaliwa(double dystans) {
        return dystans * 0.08; // 8l/100km
    }
}

public class Bike extends Vehicle {
    private boolean elektryczny;
    
    public Bike(String marka, String model, int rokProdukcji, boolean elektryczny) {
        super(marka, model, rokProdukcji);
        this.elektryczny = elektryczny;
    }
    
    @Override
    public void uruchom() {
        System.out.println("Rower " + marka + " " + model + " jest gotowy do jazdy");
    }
    
    @Override
    public void zatrzymaj() {
        predkosc = 0;
        System.out.println("Rower " + marka + " " + model + " został zatrzymany");
    }
    
    @Override
    public double obliczZuzyciePaliwa(double dystans) {
        return elektryczny ? dystans * 0.01 : 0; // Elektryczny zużywa energię
    }
}

public class Truck extends Vehicle {
    private double ladownosc;
    
    public Truck(String marka, String model, int rokProdukcji, double ladownosc) {
        super(marka, model, rokProdukcji);
        this.ladownosc = ladownosc;
    }
    
    @Override
    public void uruchom() {
        System.out.println("Ciężarówka " + marka + " " + model + " została uruchomiona");
    }
    
    @Override
    public void zatrzymaj() {
        predkosc = 0;
        System.out.println("Ciężarówka " + marka + " " + model + " została zatrzymana");
    }
    
    @Override
    public double obliczZuzyciePaliwa(double dystans) {
        return dystans * 0.25; // 25l/100km
    }
}
```

**Pytania kontrolne:**
1. Dziedziczenie to relacja "jest" (is-a), kompozycja to relacja "ma" (has-a). Kompozycja jest bardziej elastyczna i łatwiejsza w testowaniu.
2. Abstrakcyjne klasy gdy chcesz udostępnić wspólną implementację i wymusić implementację niektórych metod w podklasach.
3. Polimorfizm pozwala traktować obiekty różnych klas w jednolity sposób przez wspólny interfejs lub nadklasę.

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. SOLID principles promują loose coupling, high cohesion i extensibility. SRP zapobiega god classes, OCP pozwala na rozszerzenia bez modyfikacji, LSP gwarantuje poprawność polimorfizmu.
2. Composition gdy nie ma prawdziwej relacji "is-a", gdy potrzebujesz multiple inheritance, gdy chcesz runtime flexibility, gdy testability jest ważna.
3. Template method definiuje szkielet algorytmu w nadklasie, strategy pozwala na wymianę całego algorytmu. Template method używa dziedziczenia, strategy kompozycji.

---

### 📚 Co dalej?

*Fantastycznie! Teraz masz solidne podstawy programowania obiektowego w Javie. Rozumiesz enkapsulację, dziedziczenie, polimorfizm i znasz SOLID principles. To fundament, na którym będziesz budować wszystkie swoje aplikacje. W następnym rozdziale porozmawiamy o sealed classes - czyli jak kontrolować hierarchie dziedziczenia w nowoczesnej Javie!*

---

*💡 Pamiętaj: OOP to nie tylko składnia, to sposób myślenia o kodzie. Modeluj rzeczywisty świat, ukrywaj szczegóły, używaj polimorfizmu mądrze!*


## 15. Sealed classes — kontrolowana hierarchia dziedziczenia

*Cześć! Dziś porozmawiamy o sealed classes - jednej z najciekawszych nowości w Javie 17. Jeśli kiedykolwiek chciałaś mieć kontrolę nad tym, kto może dziedziczyć z Twojej klasy, to sealed classes to odpowiedź na Twoje modlitwy. To jak VIP lista dla dziedziczenia - tylko wybrane klasy mogą wejść do klubu! Przygotuj się na odkrycie, jak tworzyć bezpieczne i przewidywalne hierarchie klas.*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Sealed class to klasa, która może być dziedziczona tylko przez określone, z góry zdefiniowane klasy. To jak zamknięta lista - wiesz dokładnie, kto może być Twoim dzieckiem w hierarchii dziedziczenia.

```java
// Przed sealed classes - każdy mógł dziedziczyć
public abstract class Ksztalt {
    public abstract double obliczPole();
}

// Ktoś mógł stworzyć nieprzewidzianą implementację
public class DziwnyKsztalt extends Ksztalt {
    @Override
    public double obliczPole() {
        return -1; // Nieprawidłowa implementacja!
    }
}

// Z sealed classes - kontrolujesz hierarchię
public sealed class KsztaltSealed 
    permits Prostokat, Kolo, Trojkat {
    
    public abstract double obliczPole();
}

// Tylko te klasy mogą dziedziczyć
public final class Prostokat extends KsztaltSealed {
    private final double szerokosc, wysokosc;
    
    public Prostokat(double szerokosc, double wysokosc) {
        this.szerokosc = szerokosc;
        this.wysokosc = wysokosc;
    }
    
    @Override
    public double obliczPole() {
        return szerokosc * wysokosc;
    }
}

public final class Kolo extends KsztaltSealed {
    private final double promien;
    
    public Kolo(double promien) {
        this.promien = promien;
    }
    
    @Override
    public double obliczPole() {
        return Math.PI * promien * promien;
    }
}

public final class Trojkat extends KsztaltSealed {
    private final double podstawa, wysokosc;
    
    public Trojkat(double podstawa, double wysokosc) {
        this.podstawa = podstawa;
        this.wysokosc = wysokosc;
    }
    
    @Override
    public double obliczPole() {
        return 0.5 * podstawa * wysokosc;
    }
}

// Próba stworzenia nowej klasy dziedziczącej zakończy się błędem kompilacji!
// public class NowyKsztalt extends KsztaltSealed {} // Błąd!
```

#### Dlaczego to ważne?

Sealed classes dają Ci:
- **Kontrolę** nad hierarchią dziedziczenia
- **Bezpieczeństwo** - wiesz wszystkie możliwe implementacje
- **Exhaustive pattern matching** - kompilator wie o wszystkich przypadkach
- **Lepsze API design** - jasne granice tego, co można rozszerzyć

#### Jak to działa w praktyce?

**Podstawowa składnia:**

```java
public class PodstawoweSealed {
    // Sealed class z permits
    public sealed class Pojazd permits Samochod, Rower, Motocykl {
        protected String marka;
        
        public Pojazd(String marka) {
            this.marka = marka;
        }
        
        public String getMarka() { return marka; }
        public abstract void jedz();
    }
    
    // Permitted classes muszą być final, sealed lub non-sealed
    public final class Samochod extends Pojazd {
        private int liczbaDrzwi;
        
        public Samochod(String marka, int liczbaDrzwi) {
            super(marka);
            this.liczbaDrzwi = liczbaDrzwi;
        }
        
        @Override
        public void jedz() {
            System.out.println("Samochód " + marka + " jedzie po drodze");
        }
        
        public int getLiczbaDrzwi() { return liczbaDrzwi; }
    }
    
    public final class Rower extends Pojazd {
        private boolean elektryczny;
        
        public Rower(String marka, boolean elektryczny) {
            super(marka);
            this.elektryczny = elektryczny;
        }
        
        @Override
        public void jedz() {
            System.out.println("Rower " + marka + " jedzie po ścieżce rowerowej");
        }
        
        public boolean isElektryczny() { return elektryczny; }
    }
    
    // Non-sealed pozwala na dalsze dziedziczenie
    public non-sealed class Motocykl extends Pojazd {
        private int pojemnoscSilnika;
        
        public Motocykl(String marka, int pojemnoscSilnika) {
            super(marka);
            this.pojemnoscSilnika = pojemnoscSilnika;
        }
        
        @Override
        public void jedz() {
            System.out.println("Motocykl " + marka + " jedzie po drodze");
        }
        
        public int getPojemnoscSilnika() { return pojemnoscSilnika; }
    }
    
    // Teraz można dziedziczyć z Motocykl
    public class Skuter extends Motocykl {
        public Skuter(String marka) {
            super(marka, 125);
        }
        
        @Override
        public void jedz() {
            System.out.println("Skuter " + marka + " jedzie powoli");
        }
    }
    
    public static void main(String[] args) {
        Pojazd[] pojazdy = {
            new Samochod("Toyota", 4),
            new Rower("Giant", true),
            new Motocykl("Honda", 600),
            new Skuter("Yamaha")
        };
        
        for (Pojazd pojazd : pojazdy) {
            System.out.println("--- " + pojazd.getMarka() + " ---");
            pojazd.jedz();
        }
    }
}
```

**Sealed interfaces:**

```java
public class SealedInterfaces {
    // Sealed interface
    public sealed interface Platnosc permits KartaKredytowa, Gotowka, PrzelewBankowy {
        double getKwota();
        boolean przetworzPlatnosc();
    }
    
    public final class KartaKredytowa implements Platnosc {
        private final double kwota;
        private final String numerKarty;
        
        public KartaKredytowa(double kwota, String numerKarty) {
            this.kwota = kwota;
            this.numerKarty = numerKarty;
        }
        
        @Override
        public double getKwota() { return kwota; }
        
        @Override
        public boolean przetworzPlatnosc() {
            System.out.println("Przetwarzanie płatności kartą: " + kwota + " zł");
            // Logika płatności kartą
            return true;
        }
        
        public String getNumerKarty() { return numerKarty; }
    }
    
    public final class Gotowka implements Platnosc {
        private final double kwota;
        
        public Gotowka(double kwota) {
            this.kwota = kwota;
        }
        
        @Override
        public double getKwota() { return kwota; }
        
        @Override
        public boolean przetworzPlatnosc() {
            System.out.println("Płatność gotówką: " + kwota + " zł");
            return true;
        }
    }
    
    public final class PrzelewBankowy implements Platnosc {
        private final double kwota;
        private final String numerKonta;
        
        public PrzelewBankowy(double kwota, String numerKonta) {
            this.kwota = kwota;
            this.numerKonta = numerKonta;
        }
        
        @Override
        public double getKwota() { return kwota; }
        
        @Override
        public boolean przetworzPlatnosc() {
            System.out.println("Przelew bankowy: " + kwota + " zł na konto " + numerKonta);
            return true;
        }
        
        public String getNumerKonta() { return numerKonta; }
    }
    
    // Metoda wykorzystująca sealed interface
    public static void przetworzPlatnosci(List<Platnosc> platnosci) {
        for (Platnosc platnosc : platnosci) {
            System.out.println("Przetwarzanie płatności na kwotę: " + platnosc.getKwota());
            
            // Pattern matching (Java 17+)
            switch (platnosc) {
                case KartaKredytowa karta -> {
                    System.out.println("Karta końcówka: " + 
                        karta.getNumerKarty().substring(karta.getNumerKarty().length() - 4));
                    karta.przetworzPlatnosc();
                }
                case Gotowka gotowka -> {
                    System.out.println("Płatność gotówką");
                    gotowka.przetworzPlatnosc();
                }
                case PrzelewBankowy przelew -> {
                    System.out.println("Przelew na konto: " + przelew.getNumerKonta());
                    przelew.przetworzPlatnosc();
                }
                // Nie potrzeba default - kompilator wie o wszystkich przypadkach!
            }
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        List<Platnosc> platnosci = List.of(
            new KartaKredytowa(100.0, "1234567890123456"),
            new Gotowka(50.0),
            new PrzelewBankowy(200.0, "PL12345678901234567890123456")
        );
        
        przetworzPlatnosci(platnosci);
    }
}
```

**Sealed classes z records:**

```java
public class SealedRecords {
    // Sealed interface dla eventów
    public sealed interface Event permits UserEvent, OrderEvent, SystemEvent {}
    
    // Sealed interface dla user events
    public sealed interface UserEvent extends Event 
        permits UserRegistered, UserLoggedIn, UserLoggedOut {}
    
    // Records implementujące sealed interfaces
    public record UserRegistered(String userId, String email, long timestamp) implements UserEvent {}
    public record UserLoggedIn(String userId, String ipAddress, long timestamp) implements UserEvent {}
    public record UserLoggedOut(String userId, long sessionDuration, long timestamp) implements UserEvent {}
    
    public sealed interface OrderEvent extends Event 
        permits OrderCreated, OrderPaid, OrderShipped, OrderDelivered {}
    
    public record OrderCreated(String orderId, String userId, double amount, long timestamp) implements OrderEvent {}
    public record OrderPaid(String orderId, String paymentMethod, long timestamp) implements OrderEvent {}
    public record OrderShipped(String orderId, String trackingNumber, long timestamp) implements OrderEvent {}
    public record OrderDelivered(String orderId, long timestamp) implements OrderEvent {}
    
    public sealed interface SystemEvent extends Event 
        permits SystemStarted, SystemStopped, SystemError {}
    
    public record SystemStarted(String version, long timestamp) implements SystemEvent {}
    public record SystemStopped(String reason, long timestamp) implements SystemEvent {}
    public record SystemError(String errorMessage, String stackTrace, long timestamp) implements SystemEvent {}
    
    // Event processor z exhaustive pattern matching
    public static class EventProcessor {
        public void processEvent(Event event) {
            switch (event) {
                // User events
                case UserRegistered(var userId, var email, var timestamp) -> 
                    System.out.println("Nowy użytkownik: " + email);
                case UserLoggedIn(var userId, var ipAddress, var timestamp) -> 
                    System.out.println("Użytkownik " + userId + " zalogował się z " + ipAddress);
                case UserLoggedOut(var userId, var sessionDuration, var timestamp) -> 
                    System.out.println("Użytkownik " + userId + " wylogował się po " + sessionDuration + "ms");
                
                // Order events
                case OrderCreated(var orderId, var userId, var amount, var timestamp) -> 
                    System.out.println("Nowe zamówienie " + orderId + " na kwotę " + amount);
                case OrderPaid(var orderId, var paymentMethod, var timestamp) -> 
                    System.out.println("Zamówienie " + orderId + " opłacone przez " + paymentMethod);
                case OrderShipped(var orderId, var trackingNumber, var timestamp) -> 
                    System.out.println("Zamówienie " + orderId + " wysłane, tracking: " + trackingNumber);
                case OrderDelivered(var orderId, var timestamp) -> 
                    System.out.println("Zamówienie " + orderId + " dostarczone");
                
                // System events
                case SystemStarted(var version, var timestamp) -> 
                    System.out.println("System uruchomiony, wersja: " + version);
                case SystemStopped(var reason, var timestamp) -> 
                    System.out.println("System zatrzymany: " + reason);
                case SystemError(var errorMessage, var stackTrace, var timestamp) -> 
                    System.out.println("Błąd systemu: " + errorMessage);
                
                // Kompilator gwarantuje exhaustiveness - nie potrzeba default!
            }
        }
        
        public void processUserEvents(List<UserEvent> userEvents) {
            for (UserEvent event : userEvents) {
                switch (event) {
                    case UserRegistered(var userId, var email, var timestamp) -> {
                        System.out.println("Wysyłanie email powitalnego do: " + email);
                        // Logika wysyłania emaila
                    }
                    case UserLoggedIn(var userId, var ipAddress, var timestamp) -> {
                        System.out.println("Aktualizacja ostatniego logowania dla: " + userId);
                        // Logika aktualizacji
                    }
                    case UserLoggedOut(var userId, var sessionDuration, var timestamp) -> {
                        System.out.println("Zapisywanie statystyk sesji dla: " + userId);
                        // Logika zapisywania statystyk
                    }
                }
            }
        }
    }
    
    public static void main(String[] args) {
        EventProcessor processor = new EventProcessor();
        
        List<Event> events = List.of(
            new UserRegistered("user123", "anna@example.com", System.currentTimeMillis()),
            new OrderCreated("order456", "user123", 99.99, System.currentTimeMillis()),
            new SystemStarted("1.0.0", System.currentTimeMillis()),
            new UserLoggedIn("user123", "192.168.1.1", System.currentTimeMillis()),
            new OrderPaid("order456", "karta kredytowa", System.currentTimeMillis())
        );
        
        System.out.println("=== Przetwarzanie wszystkich eventów ===");
        for (Event event : events) {
            processor.processEvent(event);
        }
        
        System.out.println("\n=== Przetwarzanie tylko user eventów ===");
        List<UserEvent> userEvents = events.stream()
            .filter(event -> event instanceof UserEvent)
            .map(event -> (UserEvent) event)
            .collect(Collectors.toList());
        
        processor.processUserEvents(userEvents);
    }
}
```

**Praktyczne zastosowania:**

```java
public class PraktyczneSealedClasses {
    // State machine z sealed classes
    public sealed interface ConnectionState 
        permits Disconnected, Connecting, Connected, Error {
        
        default String getDisplayName() {
            return switch (this) {
                case Disconnected() -> "Rozłączony";
                case Connecting() -> "Łączenie...";
                case Connected(var serverName) -> "Połączony z " + serverName;
                case Error(var message) -> "Błąd: " + message;
            };
        }
    }
    
    public record Disconnected() implements ConnectionState {}
    public record Connecting() implements ConnectionState {}
    public record Connected(String serverName) implements ConnectionState {}
    public record Error(String message) implements ConnectionState {}
    
    public static class ConnectionManager {
        private ConnectionState currentState = new Disconnected();
        
        public void connect(String serverName) {
            currentState = switch (currentState) {
                case Disconnected() -> {
                    System.out.println("Rozpoczynam łączenie z " + serverName);
                    yield new Connecting();
                }
                case Connecting() -> {
                    System.out.println("Już trwa łączenie");
                    yield currentState;
                }
                case Connected(var current) -> {
                    System.out.println("Już połączony z " + current);
                    yield currentState;
                }
                case Error(var message) -> {
                    System.out.println("Próba ponownego łączenia po błędzie: " + message);
                    yield new Connecting();
                }
            };
        }
        
        public void finishConnection(String serverName) {
            currentState = switch (currentState) {
                case Connecting() -> {
                    System.out.println("Połączenie z " + serverName + " zakończone sukcesem");
                    yield new Connected(serverName);
                }
                case Disconnected(), Connected(var current), Error(var message) -> {
                    System.out.println("Nie można zakończyć połączenia w stanie: " + currentState.getDisplayName());
                    yield currentState;
                }
            };
        }
        
        public void disconnect() {
            currentState = switch (currentState) {
                case Connected(var serverName) -> {
                    System.out.println("Rozłączanie z " + serverName);
                    yield new Disconnected();
                }
                case Connecting() -> {
                    System.out.println("Anulowanie łączenia");
                    yield new Disconnected();
                }
                case Disconnected() -> {
                    System.out.println("Już rozłączony");
                    yield currentState;
                }
                case Error(var message) -> {
                    System.out.println("Rozłączanie po błędzie");
                    yield new Disconnected();
                }
            };
        }
        
        public void error(String message) {
            currentState = new Error(message);
            System.out.println("Wystąpił błąd: " + message);
        }
        
        public ConnectionState getCurrentState() {
            return currentState;
        }
        
        public void printStatus() {
            System.out.println("Status połączenia: " + currentState.getDisplayName());
        }
    }
    
    // Result type z sealed classes
    public sealed interface Result<T> permits Success, Failure {
        static <T> Result<T> success(T value) {
            return new Success<>(value);
        }
        
        static <T> Result<T> failure(String error) {
            return new Failure<>(error);
        }
        
        default boolean isSuccess() {
            return this instanceof Success;
        }
        
        default boolean isFailure() {
            return this instanceof Failure;
        }
        
        default T getValue() {
            return switch (this) {
                case Success<T>(var value) -> value;
                case Failure<T>(var error) -> throw new RuntimeException("Result is failure: " + error);
            };
        }
        
        default String getError() {
            return switch (this) {
                case Success<T>(var value) -> throw new RuntimeException("Result is success");
                case Failure<T>(var error) -> error;
            };
        }
        
        default <U> Result<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Success<T>(var value) -> Result.success(mapper.apply(value));
                case Failure<T>(var error) -> Result.failure(error);
            };
        }
        
        default <U> Result<U> flatMap(Function<T, Result<U>> mapper) {
            return switch (this) {
                case Success<T>(var value) -> mapper.apply(value);
                case Failure<T>(var error) -> Result.failure(error);
            };
        }
    }
    
    public record Success<T>(T value) implements Result<T> {}
    public record Failure<T>(String error) implements Result<T> {}
    
    // Service używający Result
    public static class UserService {
        private final Map<String, String> users = Map.of(
            "1", "Anna",
            "2", "Kasia",
            "3", "Ola"
        );
        
        public Result<String> findUser(String id) {
            if (id == null || id.trim().isEmpty()) {
                return Result.failure("ID użytkownika nie może być puste");
            }
            
            String user = users.get(id);
            if (user != null) {
                return Result.success(user);
            } else {
                return Result.failure("Użytkownik o ID " + id + " nie istnieje");
            }
        }
        
        public Result<String> getUserDisplayName(String id) {
            return findUser(id)
                .map(name -> "Użytkownik: " + name)
                .flatMap(displayName -> {
                    if (displayName.length() > 50) {
                        return Result.failure("Nazwa wyświetlana jest za długa");
                    }
                    return Result.success(displayName);
                });
        }
    }
    
    public static void main(String[] args) {
        // Test connection manager
        System.out.println("=== Test Connection Manager ===");
        ConnectionManager manager = new ConnectionManager();
        
        manager.printStatus();
        manager.connect("server1.example.com");
        manager.printStatus();
        manager.finishConnection("server1.example.com");
        manager.printStatus();
        manager.error("Utrata połączenia");
        manager.printStatus();
        manager.disconnect();
        manager.printStatus();
        
        System.out.println("\n=== Test Result Type ===");
        UserService userService = new UserService();
        
        String[] userIds = {"1", "2", "999", "", null};
        
        for (String id : userIds) {
            Result<String> result = userService.getUserDisplayName(id);
            
            switch (result) {
                case Success<String>(var displayName) -> 
                    System.out.println("Sukces: " + displayName);
                case Failure<String>(var error) -> 
                    System.out.println("Błąd: " + error);
            }
        }
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Zapomnienie o permits**

```java
// ŹLE - brak permits
public sealed class BadSealed {
    // Kompilator nie wie, które klasy mogą dziedziczyć
}

// DOBRZE - z permits
public sealed class GoodSealed permits Child1, Child2 {
    // Jasno określone permitted classes
}

public final class Child1 extends GoodSealed {}
public final class Child2 extends GoodSealed {}
```

**Pułapka 2: Nieprawidłowe modyfikatory w permitted classes**

```java
public sealed class Parent permits Child {}

// ŹLE - permitted class musi być final, sealed lub non-sealed
public class Child extends Parent {}  // Błąd kompilacji!

// DOBRZE - jedna z trzech opcji
public final class Child extends Parent {}
// LUB
public sealed class Child extends Parent permits GrandChild {}
// LUB
public non-sealed class Child extends Parent {}
```

**Pułapka 3: Sealed classes w różnych pakietach**

```java
// Sealed class i jej permitted classes muszą być w tym samym module
// lub w tym samym pakiecie (jeśli nie używasz modułów)

package com.example.shapes;

public sealed class Shape permits Circle, Rectangle {
    // Circle i Rectangle muszą być w pakiecie com.example.shapes
}
```

#### 💡 Wskazówki dla Juniorek

- **Używaj sealed classes** gdy chcesz kontrolować hierarchię
- **Pattern matching** z sealed classes jest exhaustive
- **Records + sealed interfaces** = potężna kombinacja
- **Permitted classes** muszą być final, sealed lub non-sealed
- **Wszystkie w tym samym pakiecie** (lub module)

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz sealed interface dla różnych typów notyfikacji (Email, SMS, Push) z pattern matching.

**Zadanie 2:** Zaprojektuj system stanów zamówienia używając sealed classes i state machine.

**Zadanie 3:** Zaimplementuj calculator z sealed interface dla operacji matematycznych.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jakie są trzy możliwe modyfikatory dla permitted classes?
2. Dlaczego sealed classes są przydatne w pattern matching?
3. Gdzie muszą znajdować się permitted classes względem sealed class?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Sealed classes to nie tylko ograniczenie dziedziczenia - to narzędzie do tworzenia type-safe domain models, algebraic data types i zaawansowanych wzorców funkcyjnych w Javie. Przyjrzyjmy się zaawansowanym zastosowaniom i wzorcom.

##### Algebraic Data Types w Javie

```java
// Sum types (tagged unions) z sealed classes
public class AlgebraicDataTypes {
    // Option type - alternatywa dla Optional
    public sealed interface Option<T> permits Some, None {
        static <T> Option<T> some(T value) {
            return new Some<>(value);
        }
        
        static <T> Option<T> none() {
            return new None<>();
        }
        
        default boolean isSome() {
            return this instanceof Some;
        }
        
        default boolean isNone() {
            return this instanceof None;
        }
        
        default T get() {
            return switch (this) {
                case Some<T>(var value) -> value;
                case None<T>() -> throw new NoSuchElementException("Option is None");
            };
        }
        
        default T getOrElse(T defaultValue) {
            return switch (this) {
                case Some<T>(var value) -> value;
                case None<T>() -> defaultValue;
            };
        }
        
        default <U> Option<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Some<T>(var value) -> Option.some(mapper.apply(value));
                case None<T>() -> Option.none();
            };
        }
        
        default <U> Option<U> flatMap(Function<T, Option<U>> mapper) {
            return switch (this) {
                case Some<T>(var value) -> mapper.apply(value);
                case None<T>() -> Option.none();
            };
        }
        
        default Option<T> filter(Predicate<T> predicate) {
            return switch (this) {
                case Some<T>(var value) when predicate.test(value) -> this;
                case Some<T>(var value) -> Option.none();
                case None<T>() -> this;
            };
        }
        
        default void ifSome(Consumer<T> action) {
            switch (this) {
                case Some<T>(var value) -> action.accept(value);
                case None<T>() -> {}
            }
        }
        
        default void ifSomeOrElse(Consumer<T> action, Runnable emptyAction) {
            switch (this) {
                case Some<T>(var value) -> action.accept(value);
                case None<T>() -> emptyAction.run();
            }
        }
    }
    
    public record Some<T>(T value) implements Option<T> {}
    public record None<T>() implements Option<T> {}
    
    // Either type - dla error handling
    public sealed interface Either<L, R> permits Left, Right {
        static <L, R> Either<L, R> left(L value) {
            return new Left<>(value);
        }
        
        static <L, R> Either<L, R> right(R value) {
            return new Right<>(value);
        }
        
        default boolean isLeft() {
            return this instanceof Left;
        }
        
        default boolean isRight() {
            return this instanceof Right;
        }
        
        default L getLeft() {
            return switch (this) {
                case Left<L, R>(var value) -> value;
                case Right<L, R>(var value) -> throw new NoSuchElementException("Either is Right");
            };
        }
        
        default R getRight() {
            return switch (this) {
                case Left<L, R>(var value) -> throw new NoSuchElementException("Either is Left");
                case Right<L, R>(var value) -> value;
            };
        }
        
        default <U> Either<L, U> map(Function<R, U> mapper) {
            return switch (this) {
                case Left<L, R>(var value) -> Either.left(value);
                case Right<L, R>(var value) -> Either.right(mapper.apply(value));
            };
        }
        
        default <U> Either<U, R> mapLeft(Function<L, U> mapper) {
            return switch (this) {
                case Left<L, R>(var value) -> Either.left(mapper.apply(value));
                case Right<L, R>(var value) -> Either.right(value);
            };
        }
        
        default <U> Either<L, U> flatMap(Function<R, Either<L, U>> mapper) {
            return switch (this) {
                case Left<L, R>(var value) -> Either.left(value);
                case Right<L, R>(var value) -> mapper.apply(value);
            };
        }
        
        default R getOrElse(R defaultValue) {
            return switch (this) {
                case Left<L, R>(var value) -> defaultValue;
                case Right<L, R>(var value) -> value;
            };
        }
        
        default R getOrElse(Function<L, R> defaultMapper) {
            return switch (this) {
                case Left<L, R>(var value) -> defaultMapper.apply(value);
                case Right<L, R>(var value) -> value;
            };
        }
    }
    
    public record Left<L, R>(L value) implements Either<L, R> {}
    public record Right<L, R>(R value) implements Either<L, R> {}
    
    // List type - immutable linked list
    public sealed interface ImmutableList<T> permits Nil, Cons {
        static <T> ImmutableList<T> nil() {
            return new Nil<>();
        }
        
        static <T> ImmutableList<T> cons(T head, ImmutableList<T> tail) {
            return new Cons<>(head, tail);
        }
        
        static <T> ImmutableList<T> of(T... elements) {
            ImmutableList<T> result = nil();
            for (int i = elements.length - 1; i >= 0; i--) {
                result = cons(elements[i], result);
            }
            return result;
        }
        
        default boolean isEmpty() {
            return this instanceof Nil;
        }
        
        default boolean nonEmpty() {
            return this instanceof Cons;
        }
        
        default T head() {
            return switch (this) {
                case Nil<T>() -> throw new NoSuchElementException("Empty list");
                case Cons<T>(var head, var tail) -> head;
            };
        }
        
        default ImmutableList<T> tail() {
            return switch (this) {
                case Nil<T>() -> throw new NoSuchElementException("Empty list");
                case Cons<T>(var head, var tail) -> tail;
            };
        }
        
        default int size() {
            return switch (this) {
                case Nil<T>() -> 0;
                case Cons<T>(var head, var tail) -> 1 + tail.size();
            };
        }
        
        default <U> ImmutableList<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Nil<T>() -> nil();
                case Cons<T>(var head, var tail) -> cons(mapper.apply(head), tail.map(mapper));
            };
        }
        
        default ImmutableList<T> filter(Predicate<T> predicate) {
            return switch (this) {
                case Nil<T>() -> nil();
                case Cons<T>(var head, var tail) when predicate.test(head) -> 
                    cons(head, tail.filter(predicate));
                case Cons<T>(var head, var tail) -> tail.filter(predicate);
            };
        }
        
        default <U> U foldLeft(U initial, BiFunction<U, T, U> folder) {
            return switch (this) {
                case Nil<T>() -> initial;
                case Cons<T>(var head, var tail) -> tail.foldLeft(folder.apply(initial, head), folder);
            };
        }
        
        default <U> U foldRight(U initial, BiFunction<T, U, U> folder) {
            return switch (this) {
                case Nil<T>() -> initial;
                case Cons<T>(var head, var tail) -> folder.apply(head, tail.foldRight(initial, folder));
            };
        }
        
        default ImmutableList<T> reverse() {
            return foldLeft(nil(), (acc, elem) -> cons(elem, acc));
        }
        
        default ImmutableList<T> append(ImmutableList<T> other) {
            return switch (this) {
                case Nil<T>() -> other;
                case Cons<T>(var head, var tail) -> cons(head, tail.append(other));
            };
        }
        
        default java.util.List<T> toJavaList() {
            return foldRight(new ArrayList<>(), (elem, acc) -> {
                acc.add(0, elem);
                return acc;
            });
        }
    }
    
    public record Nil<T>() implements ImmutableList<T> {}
    public record Cons<T>(T head, ImmutableList<T> tail) implements ImmutableList<T> {}
    
    // Tree type
    public sealed interface Tree<T> permits Leaf, Branch {
        static <T> Tree<T> leaf(T value) {
            return new Leaf<>(value);
        }
        
        static <T> Tree<T> branch(Tree<T> left, Tree<T> right) {
            return new Branch<>(left, right);
        }
        
        default int size() {
            return switch (this) {
                case Leaf<T>(var value) -> 1;
                case Branch<T>(var left, var right) -> left.size() + right.size();
            };
        }
        
        default int depth() {
            return switch (this) {
                case Leaf<T>(var value) -> 1;
                case Branch<T>(var left, var right) -> 1 + Math.max(left.depth(), right.depth());
            };
        }
        
        default <U> Tree<U> map(Function<T, U> mapper) {
            return switch (this) {
                case Leaf<T>(var value) -> Tree.leaf(mapper.apply(value));
                case Branch<T>(var left, var right) -> Tree.branch(left.map(mapper), right.map(mapper));
            };
        }
        
        default ImmutableList<T> toList() {
            return switch (this) {
                case Leaf<T>(var value) -> ImmutableList.of(value);
                case Branch<T>(var left, var right) -> left.toList().append(right.toList());
            };
        }
        
        default <U> U fold(Function<T, U> leafFolder, BiFunction<U, U, U> branchFolder) {
            return switch (this) {
                case Leaf<T>(var value) -> leafFolder.apply(value);
                case Branch<T>(var left, var right) -> 
                    branchFolder.apply(left.fold(leafFolder, branchFolder), 
                                     right.fold(leafFolder, branchFolder));
            };
        }
    }
    
    public record Leaf<T>(T value) implements Tree<T> {}
    public record Branch<T>(Tree<T> left, Tree<T> right) implements Tree<T> {}
}
```

##### Domain Modeling z sealed classes

```java
public class DomainModeling {
    // E-commerce domain model
    public sealed interface OrderStatus permits Pending, Confirmed, Shipped, Delivered, Cancelled {
        default boolean canTransitionTo(OrderStatus newStatus) {
            return switch (this) {
                case Pending() -> newStatus instanceof Confirmed || newStatus instanceof Cancelled;
                case Confirmed() -> newStatus instanceof Shipped || newStatus instanceof Cancelled;
                case Shipped() -> newStatus instanceof Delivered;
                case Delivered(), Cancelled() -> false;
            };
        }
        
        default String getDisplayName() {
            return switch (this) {
                case Pending() -> "Oczekujące";
                case Confirmed() -> "Potwierdzone";
                case Shipped() -> "Wysłane";
                case Delivered() -> "Dostarczone";
                case Cancelled(var reason) -> "Anulowane: " + reason;
            };
        }
    }
    
    public record Pending() implements OrderStatus {}
    public record Confirmed() implements OrderStatus {}
    public record Shipped() implements OrderStatus {}
    public record Delivered() implements OrderStatus {}
    public record Cancelled(String reason) implements OrderStatus {}
    
    // Payment domain model
    public sealed interface PaymentMethod permits CreditCard, DebitCard, PayPal, BankTransfer, Cash {
        double calculateFee(double amount);
        boolean requiresVerification();
        
        default String getDisplayName() {
            return switch (this) {
                case CreditCard(var number, var expiryDate) -> "Karta kredytowa ****" + number.substring(number.length() - 4);
                case DebitCard(var number, var expiryDate) -> "Karta debetowa ****" + number.substring(number.length() - 4);
                case PayPal(var email) -> "PayPal (" + email + ")";
                case BankTransfer(var accountNumber) -> "Przelew bankowy (" + accountNumber + ")";
                case Cash() -> "Gotówka";
            };
        }
    }
    
    public record CreditCard(String number, String expiryDate) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return amount * 0.029; // 2.9% fee
        }
        
        @Override
        public boolean requiresVerification() {
            return true;
        }
    }
    
    public record DebitCard(String number, String expiryDate) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return amount * 0.015; // 1.5% fee
        }
        
        @Override
        public boolean requiresVerification() {
            return true;
        }
    }
    
    public record PayPal(String email) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return amount * 0.034 + 0.35; // 3.4% + $0.35
        }
        
        @Override
        public boolean requiresVerification() {
            return false;
        }
    }
    
    public record BankTransfer(String accountNumber) implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return 2.50; // Flat fee
        }
        
        @Override
        public boolean requiresVerification() {
            return true;
        }
    }
    
    public record Cash() implements PaymentMethod {
        @Override
        public double calculateFee(double amount) {
            return 0.0; // No fee
        }
        
        @Override
        public boolean requiresVerification() {
            return false;
        }
    }
    
    // Order aggregate
    public static class Order {
        private final String id;
        private final String customerId;
        private final List<OrderItem> items;
        private final PaymentMethod paymentMethod;
        private OrderStatus status;
        private final LocalDateTime createdAt;
        
        public Order(String id, String customerId, List<OrderItem> items, PaymentMethod paymentMethod) {
            this.id = id;
            this.customerId = customerId;
            this.items = List.copyOf(items);
            this.paymentMethod = paymentMethod;
            this.status = new Pending();
            this.createdAt = LocalDateTime.now();
        }
        
        public void changeStatus(OrderStatus newStatus) {
            if (status.canTransitionTo(newStatus)) {
                OrderStatus oldStatus = status;
                status = newStatus;
                System.out.println("Order " + id + " status changed from " + 
                                 oldStatus.getDisplayName() + " to " + newStatus.getDisplayName());
            } else {
                throw new IllegalStateException("Cannot transition from " + 
                                              status.getDisplayName() + " to " + newStatus.getDisplayName());
            }
        }
        
        public double calculateTotal() {
            double subtotal = items.stream()
                                  .mapToDouble(item -> item.price() * item.quantity())
                                  .sum();
            double paymentFee = paymentMethod.calculateFee(subtotal);
            return subtotal + paymentFee;
        }
        
        public boolean requiresPaymentVerification() {
            return paymentMethod.requiresVerification();
        }
        
        public void processPayment() {
            switch (status) {
                case Pending() -> {
                    if (requiresPaymentVerification()) {
                        System.out.println("Payment verification required for " + paymentMethod.getDisplayName());
                    }
                    System.out.println("Processing payment of $" + calculateTotal() + 
                                     " via " + paymentMethod.getDisplayName());
                    changeStatus(new Confirmed());
                }
                default -> throw new IllegalStateException("Cannot process payment in status: " + status.getDisplayName());
            }
        }
        
        public void ship(String trackingNumber) {
            switch (status) {
                case Confirmed() -> {
                    System.out.println("Shipping order " + id + " with tracking: " + trackingNumber);
                    changeStatus(new Shipped());
                }
                default -> throw new IllegalStateException("Cannot ship order in status: " + status.getDisplayName());
            }
        }
        
        public void deliver() {
            switch (status) {
                case Shipped() -> {
                    System.out.println("Order " + id + " has been delivered");
                    changeStatus(new Delivered());
                }
                default -> throw new IllegalStateException("Cannot deliver order in status: " + status.getDisplayName());
            }
        }
        
        public void cancel(String reason) {
            switch (status) {
                case Pending(), Confirmed() -> {
                    System.out.println("Cancelling order " + id + ": " + reason);
                    changeStatus(new Cancelled(reason));
                }
                default -> throw new IllegalStateException("Cannot cancel order in status: " + status.getDisplayName());
            }
        }
        
        // Getters
        public String getId() { return id; }
        public String getCustomerId() { return customerId; }
        public List<OrderItem> getItems() { return items; }
        public PaymentMethod getPaymentMethod() { return paymentMethod; }
        public OrderStatus getStatus() { return status; }
        public LocalDateTime getCreatedAt() { return createdAt; }
    }
    
    public record OrderItem(String productId, String name, double price, int quantity) {}
}
```

##### Advanced Pattern Matching

```java
public class AdvancedPatternMatching {
    // Nested pattern matching z sealed classes
    public sealed interface Expression permits Literal, Variable, BinaryOp, UnaryOp {}
    
    public record Literal(double value) implements Expression {}
    public record Variable(String name) implements Expression {}
    public record BinaryOp(Expression left, String operator, Expression right) implements Expression {}
    public record UnaryOp(String operator, Expression operand) implements Expression {}
    
    public static class ExpressionEvaluator {
        private final Map<String, Double> variables;
        
        public ExpressionEvaluator(Map<String, Double> variables) {
            this.variables = variables;
        }
        
        public double evaluate(Expression expr) {
            return switch (expr) {
                case Literal(var value) -> value;
                case Variable(var name) -> variables.getOrDefault(name, 0.0);
                case BinaryOp(var left, var op, var right) -> switch (op) {
                    case "+" -> evaluate(left) + evaluate(right);
                    case "-" -> evaluate(left) - evaluate(right);
                    case "*" -> evaluate(left) * evaluate(right);
                    case "/" -> evaluate(left) / evaluate(right);
                    case "^" -> Math.pow(evaluate(left), evaluate(right));
                    default -> throw new IllegalArgumentException("Unknown binary operator: " + op);
                };
                case UnaryOp(var op, var operand) -> switch (op) {
                    case "-" -> -evaluate(operand);
                    case "sin" -> Math.sin(evaluate(operand));
                    case "cos" -> Math.cos(evaluate(operand));
                    case "sqrt" -> Math.sqrt(evaluate(operand));
                    default -> throw new IllegalArgumentException("Unknown unary operator: " + op);
                };
            };
        }
        
        public Expression simplify(Expression expr) {
            return switch (expr) {
                case Literal(var value) -> expr;
                case Variable(var name) -> expr;
                case BinaryOp(var left, "+", var right) -> switch (simplify(left), simplify(right)) {
                    case (Literal(var l), Literal(var r)) -> new Literal(l + r);
                    case (Literal(0.0), var r) -> r;
                    case (var l, Literal(0.0)) -> l;
                    case (var l, var r) -> new BinaryOp(l, "+", r);
                };
                case BinaryOp(var left, "*", var right) -> switch (simplify(left), simplify(right)) {
                    case (Literal(var l), Literal(var r)) -> new Literal(l * r);
                    case (Literal(0.0), var r) -> new Literal(0.0);
                    case (var l, Literal(0.0)) -> new Literal(0.0);
                    case (Literal(1.0), var r) -> r;
                    case (var l, Literal(1.0)) -> l;
                    case (var l, var r) -> new BinaryOp(l, "*", r);
                };
                case BinaryOp(var left, var op, var right) -> 
                    new BinaryOp(simplify(left), op, simplify(right));
                case UnaryOp(var op, var operand) -> switch (simplify(operand)) {
                    case Literal(var value) when op.equals("-") -> new Literal(-value);
                    case var simplified -> new UnaryOp(op, simplified);
                };
            };
        }
        
        public String toString(Expression expr) {
            return switch (expr) {
                case Literal(var value) -> String.valueOf(value);
                case Variable(var name) -> name;
                case BinaryOp(var left, var op, var right) -> 
                    "(" + toString(left) + " " + op + " " + toString(right) + ")";
                case UnaryOp(var op, var operand) -> op + "(" + toString(operand) + ")";
            };
        }
    }
    
    // Pattern matching z guards
    public sealed interface Shape permits Circle, Rectangle, Triangle {}
    
    public record Circle(double radius) implements Shape {}
    public record Rectangle(double width, double height) implements Shape {}
    public record Triangle(double a, double b, double c) implements Shape {}
    
    public static class ShapeAnalyzer {
        public double area(Shape shape) {
            return switch (shape) {
                case Circle(var r) -> Math.PI * r * r;
                case Rectangle(var w, var h) -> w * h;
                case Triangle(var a, var b, var c) -> {
                    double s = (a + b + c) / 2;
                    yield Math.sqrt(s * (s - a) * (s - b) * (s - c));
                }
            };
        }
        
        public String classify(Shape shape) {
            return switch (shape) {
                case Circle(var r) when r < 1 -> "Small circle";
                case Circle(var r) when r < 5 -> "Medium circle";
                case Circle(var r) -> "Large circle";
                case Rectangle(var w, var h) when w == h -> "Square";
                case Rectangle(var w, var h) when w > h -> "Wide rectangle";
                case Rectangle(var w, var h) -> "Tall rectangle";
                case Triangle(var a, var b, var c) when a == b && b == c -> "Equilateral triangle";
                case Triangle(var a, var b, var c) when a == b || b == c || a == c -> "Isosceles triangle";
                case Triangle(var a, var b, var c) -> "Scalene triangle";
            };
        }
        
        public boolean isValid(Shape shape) {
            return switch (shape) {
                case Circle(var r) -> r > 0;
                case Rectangle(var w, var h) -> w > 0 && h > 0;
                case Triangle(var a, var b, var c) -> 
                    a > 0 && b > 0 && c > 0 && 
                    a + b > c && b + c > a && a + c > b;
            };
        }
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj type-safe SQL query builder używając sealed classes dla różnych typów klauzul.

**Zadanie Zaawansowane 2:** Stwórz system workflow engine z sealed classes dla stanów i przejść z validation rules.

**Zadanie Zaawansowane 3:** Zaprojektuj functional programming library z algebraic data types (Option, Either, Try) używając sealed classes.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak sealed classes wpływają na exhaustiveness checking w pattern matching?
2. Jakie są zalety używania sealed classes w domain modeling?
3. Jak sealed classes pomagają w implementacji algebraic data types?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public sealed interface Notification permits EmailNotification, SMSNotification, PushNotification {
    String getRecipient();
    String getMessage();
    boolean send();
    
    default String getType() {
        return switch (this) {
            case EmailNotification(var email, var subject, var body) -> "Email";
            case SMSNotification(var phoneNumber, var message) -> "SMS";
            case PushNotification(var deviceId, var title, var message) -> "Push";
        };
    }
}

public record EmailNotification(String email, String subject, String body) implements Notification {
    @Override
    public String getRecipient() { return email; }
    
    @Override
    public String getMessage() { return subject + ": " + body; }
    
    @Override
    public boolean send() {
        System.out.println("Sending email to " + email + ": " + subject);
        return true;
    }
}

public record SMSNotification(String phoneNumber, String message) implements Notification {
    @Override
    public String getRecipient() { return phoneNumber; }
    
    @Override
    public String getMessage() { return message; }
    
    @Override
    public boolean send() {
        System.out.println("Sending SMS to " + phoneNumber + ": " + message);
        return true;
    }
}

public record PushNotification(String deviceId, String title, String message) implements Notification {
    @Override
    public String getRecipient() { return deviceId; }
    
    @Override
    public String getMessage() { return title + ": " + message; }
    
    @Override
    public boolean send() {
        System.out.println("Sending push to " + deviceId + ": " + title);
        return true;
    }
}

public class NotificationService {
    public void sendNotification(Notification notification) {
        switch (notification) {
            case EmailNotification(var email, var subject, var body) -> {
                System.out.println("Preparing email infrastructure");
                notification.send();
            }
            case SMSNotification(var phone, var message) -> {
                System.out.println("Connecting to SMS gateway");
                notification.send();
            }
            case PushNotification(var deviceId, var title, var message) -> {
                System.out.println("Connecting to push service");
                notification.send();
            }
        }
    }
}
```

**Zadanie 2:**
```java
public sealed interface OrderState permits Created, PaymentPending, Paid, Shipped, Delivered, Cancelled {
    default boolean canTransitionTo(OrderState newState) {
        return switch (this) {
            case Created() -> newState instanceof PaymentPending || newState instanceof Cancelled;
            case PaymentPending() -> newState instanceof Paid || newState instanceof Cancelled;
            case Paid() -> newState instanceof Shipped || newState instanceof Cancelled;
            case Shipped() -> newState instanceof Delivered;
            case Delivered(), Cancelled(var reason) -> false;
        };
    }
}

public record Created() implements OrderState {}
public record PaymentPending() implements OrderState {}
public record Paid() implements OrderState {}
public record Shipped() implements OrderState {}
public record Delivered() implements OrderState {}
public record Cancelled(String reason) implements OrderState {}

public class OrderStateMachine {
    private final String orderId;
    private OrderState currentState;
    
    public OrderStateMachine(String orderId) {
        this.orderId = orderId;
        this.currentState = new Created();
    }
    
    public void transition(OrderState newState) {
        if (currentState.canTransitionTo(newState)) {
            OrderState oldState = currentState;
            currentState = newState;
            System.out.println("Order " + orderId + " transitioned from " + 
                             oldState.getClass().getSimpleName() + " to " + 
                             newState.getClass().getSimpleName());
        } else {
            throw new IllegalStateException("Invalid transition from " + 
                                          currentState.getClass().getSimpleName() + " to " + 
                                          newState.getClass().getSimpleName());
        }
    }
    
    public OrderState getCurrentState() {
        return currentState;
    }
}
```

**Zadanie 3:**
```java
public sealed interface Operation permits Addition, Subtraction, Multiplication, Division, Power, SquareRoot {
    double calculate(double... operands);
    int getRequiredOperands();
    
    default String getSymbol() {
        return switch (this) {
            case Addition() -> "+";
            case Subtraction() -> "-";
            case Multiplication() -> "*";
            case Division() -> "/";
            case Power() -> "^";
            case SquareRoot() -> "√";
        };
    }
}

public record Addition() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Addition requires 2 operands");
        return operands[0] + operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Subtraction() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Subtraction requires 2 operands");
        return operands[0] - operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Multiplication() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Multiplication requires 2 operands");
        return operands[0] * operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Division() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Division requires 2 operands");
        if (operands[1] == 0) throw new ArithmeticException("Division by zero");
        return operands[0] / operands[1];
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record Power() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 2) throw new IllegalArgumentException("Power requires 2 operands");
        return Math.pow(operands[0], operands[1]);
    }
    
    @Override
    public int getRequiredOperands() { return 2; }
}

public record SquareRoot() implements Operation {
    @Override
    public double calculate(double... operands) {
        if (operands.length != 1) throw new IllegalArgumentException("Square root requires 1 operand");
        if (operands[0] < 0) throw new ArithmeticException("Square root of negative number");
        return Math.sqrt(operands[0]);
    }
    
    @Override
    public int getRequiredOperands() { return 1; }
}

public class Calculator {
    public double calculate(Operation operation, double... operands) {
        if (operands.length != operation.getRequiredOperands()) {
            throw new IllegalArgumentException("Operation " + operation.getSymbol() + 
                                             " requires " + operation.getRequiredOperands() + " operands");
        }
        
        return switch (operation) {
            case Addition() -> operation.calculate(operands);
            case Subtraction() -> operation.calculate(operands);
            case Multiplication() -> operation.calculate(operands);
            case Division() -> operation.calculate(operands);
            case Power() -> operation.calculate(operands);
            case SquareRoot() -> operation.calculate(operands);
        };
    }
}
```

**Pytania kontrolne:**
1. final (nie można dalej dziedziczyć), sealed (można dalej kontrolować dziedziczenie), non-sealed (otwiera dziedziczenie).
2. Kompilator wie o wszystkich możliwych implementacjach, więc może sprawdzić czy wszystkie przypadki są obsłużone.
3. W tym samym pakiecie (lub module jeśli używasz modułów).

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Kompilator może sprawdzić czy wszystkie możliwe przypadki są obsłużone w switch expressions, eliminując potrzebę default case.
2. Sealed classes pozwalają na precyzyjne modelowanie domeny z kontrolowaną hierarchią, type safety i exhaustive pattern matching.
3. Sealed classes pozwalają na implementację sum types (tagged unions), które są podstawą algebraic data types jak Option, Either, List.

---

### 📚 Co dalej?

*Świetnie! Teraz rozumiesz pełną moc sealed classes - od podstawowej kontroli dziedziczenia po zaawansowane algebraic data types. Sealed classes to narzędzie, które pozwala tworzyć bezpieczne i przewidywalne hierarchie klas w nowoczesnej Javie. W następnym rozdziale porozmawiamy o interfejsach - czyli jak definiować kontrakty i tworzyć elastyczne architektury!*

---

*💡 Pamiętaj: Sealed classes to nie tylko ograniczenie - to narzędzie do tworzenia bezpiecznych i przewidywalnych hierarchii. Używaj ich mądrze do modelowania domeny!*


## 16. Interfejsy — kontrakty i elastyczność

*Cześć! Dziś porozmawiamy o interfejsach - jednym z najważniejszych narzędzi w Javie. Jeśli klasy to aktorzy, to interfejsy to scenariusze - definiują co ma być zrobione, ale nie jak. To klucz do tworzenia elastycznego, testowalnego i maintainable kodu. Od prostych kontraktów po zaawansowane functional interfaces - pokażę Ci, jak interfejsy mogą zmienić sposób, w jaki myślisz o programowaniu!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Interfejs to kontrakt - zestaw metod, które klasa musi zaimplementować. To jak umowa: "jeśli chcesz być X, musisz umieć robić Y i Z". Interfejsy pozwalają na polimorfizm bez dziedziczenia i są podstawą wielu wzorców projektowych.

```java
// Interfejs definiuje "co" ale nie "jak"
public interface Drawable {
    void draw();
    void move(int x, int y);
    double getArea();
}

// Różne klasy mogą implementować ten sam interfejs na swój sposób
public class Circle implements Drawable {
    private int x, y;
    private double radius;
    
    public Circle(int x, int y, double radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Rysowanie koła na pozycji (" + x + ", " + y + ") o promieniu " + radius);
    }
    
    @Override
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
        System.out.println("Koło przesunięte na pozycję (" + x + ", " + y + ")");
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle implements Drawable {
    private int x, y;
    private double width, height;
    
    public Rectangle(int x, int y, double width, double height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        System.out.println("Rysowanie prostokąta na pozycji (" + x + ", " + y + 
                          ") o wymiarach " + width + "x" + height);
    }
    
    @Override
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
        System.out.println("Prostokąt przesunięty na pozycję (" + x + ", " + y + ")");
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
}

// Użycie - polimorfizm przez interfejsy
public class DrawingApp {
    public static void main(String[] args) {
        List<Drawable> shapes = List.of(
            new Circle(10, 20, 5),
            new Rectangle(30, 40, 10, 15),
            new Circle(50, 60, 8)
        );
        
        // Jedna pętla obsługuje wszystkie kształty!
        for (Drawable shape : shapes) {
            shape.draw();
            System.out.println("Pole: " + shape.getArea());
            shape.move(100, 100);
            System.out.println();
        }
    }
}
```

#### Dlaczego to ważne?

Interfejsy dają Ci:
- **Polimorfizm** - różne implementacje tego samego kontraktu
- **Loose coupling** - kod zależy od abstrakcji, nie od konkretnych klas
- **Testowalność** - łatwo tworzyć mock objects
- **Elastyczność** - łatwo dodawać nowe implementacje
- **Multiple inheritance** - klasa może implementować wiele interfejsów

#### Jak to działa w praktyce?

**Podstawowe interfejsy:**

```java
public class PodstawoweInterfejsy {
    // Interfejs dla operacji na plikach
    public interface FileProcessor {
        boolean processFile(String filename);
        String getFileType();
        long getMaxFileSize();
    }
    
    // Implementacja dla plików tekstowych
    public static class TextFileProcessor implements FileProcessor {
        @Override
        public boolean processFile(String filename) {
            System.out.println("Przetwarzanie pliku tekstowego: " + filename);
            // Logika przetwarzania plików .txt
            return true;
        }
        
        @Override
        public String getFileType() {
            return "text/plain";
        }
        
        @Override
        public long getMaxFileSize() {
            return 10 * 1024 * 1024; // 10 MB
        }
    }
    
    // Implementacja dla plików obrazów
    public static class ImageFileProcessor implements FileProcessor {
        @Override
        public boolean processFile(String filename) {
            System.out.println("Przetwarzanie pliku obrazu: " + filename);
            // Logika przetwarzania plików .jpg, .png
            return true;
        }
        
        @Override
        public String getFileType() {
            return "image/*";
        }
        
        @Override
        public long getMaxFileSize() {
            return 50 * 1024 * 1024; // 50 MB
        }
    }
    
    // Serwis używający interfejsu
    public static class FileService {
        private final List<FileProcessor> processors;
        
        public FileService(List<FileProcessor> processors) {
            this.processors = processors;
        }
        
        public boolean processFile(String filename, String fileType) {
            for (FileProcessor processor : processors) {
                if (processor.getFileType().equals(fileType) || 
                    processor.getFileType().endsWith("/*")) {
                    return processor.processFile(filename);
                }
            }
            System.out.println("Brak procesora dla typu: " + fileType);
            return false;
        }
        
        public void showSupportedTypes() {
            System.out.println("Obsługiwane typy plików:");
            for (FileProcessor processor : processors) {
                System.out.println("- " + processor.getFileType() + 
                                 " (max " + processor.getMaxFileSize() / (1024 * 1024) + " MB)");
            }
        }
    }
    
    public static void main(String[] args) {
        List<FileProcessor> processors = List.of(
            new TextFileProcessor(),
            new ImageFileProcessor()
        );
        
        FileService fileService = new FileService(processors);
        fileService.showSupportedTypes();
        
        fileService.processFile("document.txt", "text/plain");
        fileService.processFile("photo.jpg", "image/jpeg");
        fileService.processFile("video.mp4", "video/mp4");
    }
}
```

**Multiple inheritance przez interfejsy:**

```java
public class MultipleInheritance {
    // Różne interfejsy dla różnych aspektów
    public interface Flyable {
        void fly();
        double getMaxAltitude();
    }
    
    public interface Swimmable {
        void swim();
        double getMaxDepth();
    }
    
    public interface Walkable {
        void walk();
        double getMaxSpeed();
    }
    
    // Klasa może implementować wiele interfejsów
    public static class Duck implements Flyable, Swimmable, Walkable {
        private String name;
        
        public Duck(String name) {
            this.name = name;
        }
        
        @Override
        public void fly() {
            System.out.println(name + " leci nad wodą");
        }
        
        @Override
        public double getMaxAltitude() {
            return 1000; // metry
        }
        
        @Override
        public void swim() {
            System.out.println(name + " pływa po wodzie");
        }
        
        @Override
        public double getMaxDepth() {
            return 2; // metry
        }
        
        @Override
        public void walk() {
            System.out.println(name + " chodzi po ziemi");
        }
        
        @Override
        public double getMaxSpeed() {
            return 5; // km/h
        }
        
        public void showCapabilities() {
            System.out.println(name + " potrafi:");
            System.out.println("- Latać do wysokości " + getMaxAltitude() + "m");
            System.out.println("- Pływać do głębokości " + getMaxDepth() + "m");
            System.out.println("- Chodzić z prędkością " + getMaxSpeed() + " km/h");
        }
    }
    
    public static class Fish implements Swimmable {
        private String species;
        
        public Fish(String species) {
            this.species = species;
        }
        
        @Override
        public void swim() {
            System.out.println(species + " pływa w wodzie");
        }
        
        @Override
        public double getMaxDepth() {
            return 100; // metry
        }
    }
    
    public static class Bird implements Flyable, Walkable {
        private String species;
        
        public Bird(String species) {
            this.species = species;
        }
        
        @Override
        public void fly() {
            System.out.println(species + " leci w powietrzu");
        }
        
        @Override
        public double getMaxAltitude() {
            return 5000; // metry
        }
        
        @Override
        public void walk() {
            System.out.println(species + " skacze po ziemi");
        }
        
        @Override
        public double getMaxSpeed() {
            return 10; // km/h
        }
    }
    
    // Metody używające interfejsów
    public static void makeItFly(Flyable flyable) {
        flyable.fly();
        System.out.println("Maksymalna wysokość: " + flyable.getMaxAltitude() + "m");
    }
    
    public static void makeItSwim(Swimmable swimmable) {
        swimmable.swim();
        System.out.println("Maksymalna głębokość: " + swimmable.getMaxDepth() + "m");
    }
    
    public static void makeItWalk(Walkable walkable) {
        walkable.walk();
        System.out.println("Maksymalna prędkość: " + walkable.getMaxSpeed() + " km/h");
    }
    
    public static void main(String[] args) {
        Duck duck = new Duck("Kaczka");
        Fish fish = new Fish("Łosoś");
        Bird bird = new Bird("Orzeł");
        
        duck.showCapabilities();
        System.out.println();
        
        // Polimorfizm przez interfejsy
        makeItFly(duck);
        makeItFly(bird);
        System.out.println();
        
        makeItSwim(duck);
        makeItSwim(fish);
        System.out.println();
        
        makeItWalk(duck);
        makeItWalk(bird);
    }
}
```

**Default methods w interfejsach (Java 8+):**

```java
public class DefaultMethods {
    // Interfejs z default methods
    public interface Logger {
        // Abstrakcyjna metoda - musi być zaimplementowana
        void log(String message);
        
        // Default method - ma domyślną implementację
        default void logInfo(String message) {
            log("[INFO] " + message);
        }
        
        default void logWarning(String message) {
            log("[WARNING] " + message);
        }
        
        default void logError(String message) {
            log("[ERROR] " + message);
        }
        
        default void logDebug(String message) {
            if (isDebugEnabled()) {
                log("[DEBUG] " + message);
            }
        }
        
        // Default method może wywoływać inne metody
        default boolean isDebugEnabled() {
            return false; // Domyślnie debug wyłączony
        }
        
        // Static method w interfejsie
        static Logger createConsoleLogger() {
            return new ConsoleLogger();
        }
        
        static Logger createFileLogger(String filename) {
            return new FileLogger(filename);
        }
    }
    
    // Prosta implementacja
    public static class ConsoleLogger implements Logger {
        @Override
        public void log(String message) {
            System.out.println(message);
        }
    }
    
    // Implementacja z przesłoniętymi default methods
    public static class FileLogger implements Logger {
        private final String filename;
        
        public FileLogger(String filename) {
            this.filename = filename;
        }
        
        @Override
        public void log(String message) {
            System.out.println("Zapisywanie do " + filename + ": " + message);
        }
        
        // Przesłaniamy default method
        @Override
        public boolean isDebugEnabled() {
            return true; // W file logger debug jest włączony
        }
    }
    
    // Implementacja z własną logiką
    public static class DatabaseLogger implements Logger {
        private final String tableName;
        
        public DatabaseLogger(String tableName) {
            this.tableName = tableName;
        }
        
        @Override
        public void log(String message) {
            System.out.println("INSERT INTO " + tableName + " (message) VALUES ('" + message + "')");
        }
        
        // Przesłaniamy default method z własną implementacją
        @Override
        public void logError(String message) {
            log("[CRITICAL ERROR] " + message);
            // Dodatkowa logika dla błędów
            System.out.println("Wysyłanie alertu do administratora");
        }
    }
    
    public static void main(String[] args) {
        // Używanie static factory methods
        Logger consoleLogger = Logger.createConsoleLogger();
        Logger fileLogger = Logger.createFileLogger("app.log");
        Logger dbLogger = new DatabaseLogger("logs");
        
        List<Logger> loggers = List.of(consoleLogger, fileLogger, dbLogger);
        
        for (Logger logger : loggers) {
            System.out.println("=== " + logger.getClass().getSimpleName() + " ===");
            logger.logInfo("Aplikacja uruchomiona");
            logger.logWarning("Niski poziom pamięci");
            logger.logError("Błąd połączenia z bazą danych");
            logger.logDebug("Szczegóły debugowania");
            System.out.println();
        }
    }
}
```

**Functional interfaces:**

```java
public class FunctionalInterfaces {
    // Własny functional interface
    @FunctionalInterface
    public interface Calculator {
        double calculate(double a, double b);
        
        // Default methods są dozwolone
        default double calculateAndRound(double a, double b) {
            return Math.round(calculate(a, b) * 100.0) / 100.0;
        }
        
        // Static methods też są dozwolone
        static Calculator add() {
            return (a, b) -> a + b;
        }
        
        static Calculator subtract() {
            return (a, b) -> a - b;
        }
        
        static Calculator multiply() {
            return (a, b) -> a * b;
        }
        
        static Calculator divide() {
            return (a, b) -> {
                if (b == 0) {
                    throw new ArithmeticException("Division by zero");
                }
                return a / b;
            };
        }
    }
    
    // Functional interface dla walidacji
    @FunctionalInterface
    public interface Validator<T> {
        boolean isValid(T value);
        
        // Kombinowanie walidatorów
        default Validator<T> and(Validator<T> other) {
            return value -> this.isValid(value) && other.isValid(value);
        }
        
        default Validator<T> or(Validator<T> other) {
            return value -> this.isValid(value) || other.isValid(value);
        }
        
        default Validator<T> negate() {
            return value -> !this.isValid(value);
        }
        
        // Static factory methods
        static <T> Validator<T> notNull() {
            return value -> value != null;
        }
        
        static Validator<String> notEmpty() {
            return value -> value != null && !value.trim().isEmpty();
        }
        
        static Validator<String> minLength(int minLength) {
            return value -> value != null && value.length() >= minLength;
        }
        
        static Validator<String> maxLength(int maxLength) {
            return value -> value != null && value.length() <= maxLength;
        }
        
        static Validator<Integer> inRange(int min, int max) {
            return value -> value != null && value >= min && value <= max;
        }
    }
    
    // Klasa używająca functional interfaces
    public static class MathService {
        public double performCalculation(double a, double b, Calculator calculator) {
            return calculator.calculate(a, b);
        }
        
        public List<Double> performBatchCalculation(List<Double> numbers1, 
                                                   List<Double> numbers2, 
                                                   Calculator calculator) {
            List<Double> results = new ArrayList<>();
            for (int i = 0; i < Math.min(numbers1.size(), numbers2.size()); i++) {
                results.add(calculator.calculate(numbers1.get(i), numbers2.get(i)));
            }
            return results;
        }
    }
    
    public static class ValidationService {
        public <T> boolean validate(T value, Validator<T> validator) {
            return validator.isValid(value);
        }
        
        public <T> List<T> filterValid(List<T> values, Validator<T> validator) {
            return values.stream()
                        .filter(validator::isValid)
                        .collect(Collectors.toList());
        }
        
        public List<String> validateUserInput(String name, String email, Integer age) {
            List<String> errors = new ArrayList<>();
            
            // Walidacja imienia
            Validator<String> nameValidator = Validator.<String>notNull()
                .and(Validator.notEmpty())
                .and(Validator.minLength(2))
                .and(Validator.maxLength(50));
            
            if (!nameValidator.isValid(name)) {
                errors.add("Imię musi mieć 2-50 znaków");
            }
            
            // Walidacja emaila
            Validator<String> emailValidator = Validator.<String>notNull()
                .and(Validator.notEmpty())
                .and(email -> email.contains("@"))
                .and(email -> email.contains("."));
            
            if (!emailValidator.isValid(email)) {
                errors.add("Email musi być prawidłowy");
            }
            
            // Walidacja wieku
            Validator<Integer> ageValidator = Validator.<Integer>notNull()
                .and(Validator.inRange(0, 150));
            
            if (!ageValidator.isValid(age)) {
                errors.add("Wiek musi być w zakresie 0-150");
            }
            
            return errors;
        }
    }
    
    public static void main(String[] args) {
        MathService mathService = new MathService();
        
        // Używanie lambda expressions z functional interfaces
        System.out.println("=== Calculator Examples ===");
        System.out.println("10 + 5 = " + mathService.performCalculation(10, 5, Calculator.add()));
        System.out.println("10 - 5 = " + mathService.performCalculation(10, 5, Calculator.subtract()));
        System.out.println("10 * 5 = " + mathService.performCalculation(10, 5, Calculator.multiply()));
        System.out.println("10 / 5 = " + mathService.performCalculation(10, 5, Calculator.divide()));
        
        // Własne lambda
        Calculator power = (a, b) -> Math.pow(a, b);
        System.out.println("10 ^ 2 = " + mathService.performCalculation(10, 2, power));
        
        // Batch calculations
        List<Double> numbers1 = List.of(1.0, 2.0, 3.0, 4.0);
        List<Double> numbers2 = List.of(5.0, 6.0, 7.0, 8.0);
        List<Double> sums = mathService.performBatchCalculation(numbers1, numbers2, Calculator.add());
        System.out.println("Batch addition: " + sums);
        
        // Validation examples
        System.out.println("\n=== Validation Examples ===");
        ValidationService validationService = new ValidationService();
        
        String[] names = {"Anna", "A", "", null, "VeryLongNameThatExceedsTheMaximumLengthAllowed"};
        for (String name : names) {
            List<String> errors = validationService.validateUserInput(name, "test@example.com", 25);
            System.out.println("Name '" + name + "': " + (errors.isEmpty() ? "Valid" : errors));
        }
        
        // Filtering with validators
        List<String> emails = List.of("valid@example.com", "invalid", "", null, "another@test.org");
        Validator<String> emailValidator = Validator.<String>notNull()
            .and(Validator.notEmpty())
            .and(email -> email.contains("@"));
        
        List<String> validEmails = validationService.filterValid(emails, emailValidator);
        System.out.println("Valid emails: " + validEmails);
    }
}
```

**Interfejsy w wzorcach projektowych:**

```java
public class InterfacePatterns {
    // Strategy Pattern
    public interface PaymentStrategy {
        boolean processPayment(double amount);
        String getPaymentMethod();
        double calculateFee(double amount);
    }
    
    public static class CreditCardPayment implements PaymentStrategy {
        private String cardNumber;
        
        public CreditCardPayment(String cardNumber) {
            this.cardNumber = cardNumber;
        }
        
        @Override
        public boolean processPayment(double amount) {
            System.out.println("Przetwarzanie płatności kartą kredytową: $" + amount);
            return true;
        }
        
        @Override
        public String getPaymentMethod() {
            return "Credit Card ****" + cardNumber.substring(cardNumber.length() - 4);
        }
        
        @Override
        public double calculateFee(double amount) {
            return amount * 0.029; // 2.9% fee
        }
    }
    
    public static class PayPalPayment implements PaymentStrategy {
        private String email;
        
        public PayPalPayment(String email) {
            this.email = email;
        }
        
        @Override
        public boolean processPayment(double amount) {
            System.out.println("Przetwarzanie płatności PayPal: $" + amount);
            return true;
        }
        
        @Override
        public String getPaymentMethod() {
            return "PayPal (" + email + ")";
        }
        
        @Override
        public double calculateFee(double amount) {
            return amount * 0.034 + 0.35; // 3.4% + $0.35
        }
    }
    
    // Observer Pattern
    public interface Observer {
        void update(String event, Object data);
    }
    
    public interface Subject {
        void addObserver(Observer observer);
        void removeObserver(Observer observer);
        void notifyObservers(String event, Object data);
    }
    
    public static class NewsAgency implements Subject {
        private List<Observer> observers = new ArrayList<>();
        private String latestNews;
        
        @Override
        public void addObserver(Observer observer) {
            observers.add(observer);
        }
        
        @Override
        public void removeObserver(Observer observer) {
            observers.remove(observer);
        }
        
        @Override
        public void notifyObservers(String event, Object data) {
            for (Observer observer : observers) {
                observer.update(event, data);
            }
        }
        
        public void publishNews(String news) {
            this.latestNews = news;
            notifyObservers("NEWS_PUBLISHED", news);
        }
    }
    
    public static class NewsChannel implements Observer {
        private String channelName;
        
        public NewsChannel(String channelName) {
            this.channelName = channelName;
        }
        
        @Override
        public void update(String event, Object data) {
            if ("NEWS_PUBLISHED".equals(event)) {
                System.out.println(channelName + " otrzymał wiadomość: " + data);
            }
        }
    }
    
    // Command Pattern
    public interface Command {
        void execute();
        void undo();
        String getDescription();
    }
    
    public static class Light {
        private boolean isOn = false;
        
        public void turnOn() {
            isOn = true;
            System.out.println("Światło włączone");
        }
        
        public void turnOff() {
            isOn = false;
            System.out.println("Światło wyłączone");
        }
        
        public boolean isOn() {
            return isOn;
        }
    }
    
    public static class LightOnCommand implements Command {
        private Light light;
        
        public LightOnCommand(Light light) {
            this.light = light;
        }
        
        @Override
        public void execute() {
            light.turnOn();
        }
        
        @Override
        public void undo() {
            light.turnOff();
        }
        
        @Override
        public String getDescription() {
            return "Włącz światło";
        }
    }
    
    public static class LightOffCommand implements Command {
        private Light light;
        
        public LightOffCommand(Light light) {
            this.light = light;
        }
        
        @Override
        public void execute() {
            light.turnOff();
        }
        
        @Override
        public void undo() {
            light.turnOn();
        }
        
        @Override
        public String getDescription() {
            return "Wyłącz światło";
        }
    }
    
    public static class RemoteControl {
        private Command[] commands = new Command[7];
        private Command lastCommand;
        
        public void setCommand(int slot, Command command) {
            commands[slot] = command;
        }
        
        public void pressButton(int slot) {
            if (commands[slot] != null) {
                commands[slot].execute();
                lastCommand = commands[slot];
            }
        }
        
        public void pressUndo() {
            if (lastCommand != null) {
                lastCommand.undo();
            }
        }
        
        public void showCommands() {
            for (int i = 0; i < commands.length; i++) {
                if (commands[i] != null) {
                    System.out.println("Slot " + i + ": " + commands[i].getDescription());
                }
            }
        }
    }
    
    public static void main(String[] args) {
        // Strategy Pattern Example
        System.out.println("=== Strategy Pattern ===");
        PaymentStrategy creditCard = new CreditCardPayment("1234567890123456");
        PaymentStrategy paypal = new PayPalPayment("user@example.com");
        
        double amount = 100.0;
        System.out.println("Płatność: " + creditCard.getPaymentMethod());
        System.out.println("Opłata: $" + creditCard.calculateFee(amount));
        creditCard.processPayment(amount);
        
        System.out.println("\nPłatność: " + paypal.getPaymentMethod());
        System.out.println("Opłata: $" + paypal.calculateFee(amount));
        paypal.processPayment(amount);
        
        // Observer Pattern Example
        System.out.println("\n=== Observer Pattern ===");
        NewsAgency agency = new NewsAgency();
        NewsChannel cnn = new NewsChannel("CNN");
        NewsChannel bbc = new NewsChannel("BBC");
        
        agency.addObserver(cnn);
        agency.addObserver(bbc);
        
        agency.publishNews("Ważne wydarzenie w świecie technologii!");
        
        // Command Pattern Example
        System.out.println("\n=== Command Pattern ===");
        Light livingRoomLight = new Light();
        Command lightOn = new LightOnCommand(livingRoomLight);
        Command lightOff = new LightOffCommand(livingRoomLight);
        
        RemoteControl remote = new RemoteControl();
        remote.setCommand(0, lightOn);
        remote.setCommand(1, lightOff);
        
        remote.showCommands();
        remote.pressButton(0); // Włącz
        remote.pressButton(1); // Wyłącz
        remote.pressUndo();    // Cofnij (włącz)
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Diamond problem z default methods**

```java
public interface A {
    default void method() {
        System.out.println("A");
    }
}

public interface B {
    default void method() {
        System.out.println("B");
    }
}

// ŹLE - niejednoznaczność
public class C implements A, B {
    // Błąd kompilacji! Która implementacja method()?
}

// DOBRZE - jawne rozwiązanie konfliktu
public class C implements A, B {
    @Override
    public void method() {
        A.super.method(); // Wybieramy implementację z A
        // LUB
        // B.super.method(); // Wybieramy implementację z B
        // LUB
        // System.out.println("C"); // Własna implementacja
    }
}
```

**Pułapka 2: Nadużywanie interfejsów**

```java
// ŹLE - interfejs z jedną metodą bez sensu
public interface Getter {
    String get();
}

// ŹLE - interfejs jako marker bez metod (lepiej użyć adnotacji)
public interface Serializable {}

// DOBRZE - interfejs z logicznym zestawem metod
public interface Repository<T> {
    void save(T entity);
    T findById(String id);
    List<T> findAll();
    void delete(String id);
}
```

#### 💡 Wskazówki dla Juniorek

- **Interfejsy definiują kontrakt**, nie implementację
- **Używaj default methods** do ewolucji interfejsów
- **Functional interfaces** + lambda = potęga
- **Composition over inheritance** - interfejsy pomagają
- **Testuj przez interfejsy** - łatwiej mockować

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz interfejs `Sortable` z różnymi strategiami sortowania (bubble, quick, merge).

**Zadanie 2:** Zaprojektuj system notyfikacji z interfejsem `NotificationSender` i różnymi implementacjami.

**Zadanie 3:** Zaimplementuj prosty event bus używając interfejsów `EventListener` i `EventPublisher`.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między interfejsem a klasą abstrakcyjną?
2. Co to są default methods i kiedy ich używać?
3. Czym jest functional interface?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Interfejsy w Javie to nie tylko kontrakty - to fundament zaawansowanych wzorców architektonicznych, dependency injection, i functional programming. Przyjrzyjmy się zaawansowanym technikom i best practices.

##### Advanced Interface Design Patterns

```java
public class AdvancedInterfacePatterns {
    // Fluent Interface Pattern
    public interface QueryBuilder {
        QueryBuilder select(String... columns);
        QueryBuilder from(String table);
        QueryBuilder where(String condition);
        QueryBuilder and(String condition);
        QueryBuilder or(String condition);
        QueryBuilder orderBy(String column);
        QueryBuilder limit(int count);
        String build();
        
        // Factory method
        static QueryBuilder create() {
            return new SQLQueryBuilder();
        }
    }
    
    public static class SQLQueryBuilder implements QueryBuilder {
        private StringBuilder query = new StringBuilder();
        private boolean hasWhere = false;
        
        @Override
        public QueryBuilder select(String... columns) {
            query.append("SELECT ").append(String.join(", ", columns));
            return this;
        }
        
        @Override
        public QueryBuilder from(String table) {
            query.append(" FROM ").append(table);
            return this;
        }
        
        @Override
        public QueryBuilder where(String condition) {
            query.append(" WHERE ").append(condition);
            hasWhere = true;
            return this;
        }
        
        @Override
        public QueryBuilder and(String condition) {
            if (!hasWhere) {
                throw new IllegalStateException("Cannot use AND without WHERE");
            }
            query.append(" AND ").append(condition);
            return this;
        }
        
        @Override
        public QueryBuilder or(String condition) {
            if (!hasWhere) {
                throw new IllegalStateException("Cannot use OR without WHERE");
            }
            query.append(" OR ").append(condition);
            return this;
        }
        
        @Override
        public QueryBuilder orderBy(String column) {
            query.append(" ORDER BY ").append(column);
            return this;
        }
        
        @Override
        public QueryBuilder limit(int count) {
            query.append(" LIMIT ").append(count);
            return this;
        }
        
        @Override
        public String build() {
            return query.toString();
        }
    }
    
    // Type-safe Builder Pattern z interfejsami
    public interface UserBuilder {
        UserBuilderWithName name(String name);
    }
    
    public interface UserBuilderWithName {
        UserBuilderWithEmail email(String email);
    }
    
    public interface UserBuilderWithEmail {
        UserBuilderComplete age(int age);
        UserBuilderComplete city(String city);
        User build();
    }
    
    public interface UserBuilderComplete {
        UserBuilderComplete age(int age);
        UserBuilderComplete city(String city);
        User build();
    }
    
    public static class User {
        private final String name;
        private final String email;
        private final int age;
        private final String city;
        
        private User(String name, String email, int age, String city) {
            this.name = name;
            this.email = email;
            this.age = age;
            this.city = city;
        }
        
        public static UserBuilder builder() {
            return new UserBuilderImpl();
        }
        
        // Getters
        public String getName() { return name; }
        public String getEmail() { return email; }
        public int getAge() { return age; }
        public String getCity() { return city; }
        
        @Override
        public String toString() {
            return "User{name='" + name + "', email='" + email + 
                   "', age=" + age + ", city='" + city + "'}";
        }
        
        private static class UserBuilderImpl implements UserBuilder, UserBuilderWithName, 
                                                       UserBuilderWithEmail, UserBuilderComplete {
            private String name;
            private String email;
            private int age = 0;
            private String city = "";
            
            @Override
            public UserBuilderWithName name(String name) {
                this.name = name;
                return this;
            }
            
            @Override
            public UserBuilderWithEmail email(String email) {
                this.email = email;
                return this;
            }
            
            @Override
            public UserBuilderComplete age(int age) {
                this.age = age;
                return this;
            }
            
            @Override
            public UserBuilderComplete city(String city) {
                this.city = city;
                return this;
            }
            
            @Override
            public User build() {
                return new User(name, email, age, city);
            }
        }
    }
    
    // Visitor Pattern z interfejsami
    public interface Visitor<T> {
        T visitNumber(NumberExpression expr);
        T visitAddition(AdditionExpression expr);
        T visitMultiplication(MultiplicationExpression expr);
    }
    
    public interface Expression {
        <T> T accept(Visitor<T> visitor);
    }
    
    public static class NumberExpression implements Expression {
        private final double value;
        
        public NumberExpression(double value) {
            this.value = value;
        }
        
        public double getValue() { return value; }
        
        @Override
        public <T> T accept(Visitor<T> visitor) {
            return visitor.visitNumber(this);
        }
    }
    
    public static class AdditionExpression implements Expression {
        private final Expression left, right;
        
        public AdditionExpression(Expression left, Expression right) {
            this.left = left;
            this.right = right;
        }
        
        public Expression getLeft() { return left; }
        public Expression getRight() { return right; }
        
        @Override
        public <T> T accept(Visitor<T> visitor) {
            return visitor.visitAddition(this);
        }
    }
    
    public static class MultiplicationExpression implements Expression {
        private final Expression left, right;
        
        public MultiplicationExpression(Expression left, Expression right) {
            this.left = left;
            this.right = right;
        }
        
        public Expression getLeft() { return left; }
        public Expression getRight() { return right; }
        
        @Override
        public <T> T accept(Visitor<T> visitor) {
            return visitor.visitMultiplication(this);
        }
    }
    
    public static class EvaluationVisitor implements Visitor<Double> {
        @Override
        public Double visitNumber(NumberExpression expr) {
            return expr.getValue();
        }
        
        @Override
        public Double visitAddition(AdditionExpression expr) {
            return expr.getLeft().accept(this) + expr.getRight().accept(this);
        }
        
        @Override
        public Double visitMultiplication(MultiplicationExpression expr) {
            return expr.getLeft().accept(this) * expr.getRight().accept(this);
        }
    }
    
    public static class PrintVisitor implements Visitor<String> {
        @Override
        public String visitNumber(NumberExpression expr) {
            return String.valueOf(expr.getValue());
        }
        
        @Override
        public String visitAddition(AdditionExpression expr) {
            return "(" + expr.getLeft().accept(this) + " + " + expr.getRight().accept(this) + ")";
        }
        
        @Override
        public String visitMultiplication(MultiplicationExpression expr) {
            return "(" + expr.getLeft().accept(this) + " * " + expr.getRight().accept(this) + ")";
        }
    }
}
```

##### Dependency Injection z interfejsami

```java
public class DependencyInjectionPatterns {
    // Service interfaces
    public interface UserRepository {
        User findById(String id);
        void save(User user);
        List<User> findAll();
        void delete(String id);
    }
    
    public interface EmailService {
        void sendEmail(String to, String subject, String body);
        void sendWelcomeEmail(User user);
    }
    
    public interface Logger {
        void info(String message);
        void error(String message, Throwable throwable);
        void debug(String message);
    }
    
    // Implementations
    public static class DatabaseUserRepository implements UserRepository {
        private final Logger logger;
        private final Map<String, User> database = new HashMap<>();
        
        public DatabaseUserRepository(Logger logger) {
            this.logger = logger;
        }
        
        @Override
        public User findById(String id) {
            logger.debug("Finding user by id: " + id);
            return database.get(id);
        }
        
        @Override
        public void save(User user) {
            logger.info("Saving user: " + user.getName());
            database.put(user.getId(), user);
        }
        
        @Override
        public List<User> findAll() {
            logger.debug("Finding all users");
            return new ArrayList<>(database.values());
        }
        
        @Override
        public void delete(String id) {
            logger.info("Deleting user: " + id);
            database.remove(id);
        }
    }
    
    public static class SMTPEmailService implements EmailService {
        private final Logger logger;
        
        public SMTPEmailService(Logger logger) {
            this.logger = logger;
        }
        
        @Override
        public void sendEmail(String to, String subject, String body) {
            logger.info("Sending email to: " + to);
            System.out.println("SMTP: Sending email to " + to);
            System.out.println("Subject: " + subject);
            System.out.println("Body: " + body);
        }
        
        @Override
        public void sendWelcomeEmail(User user) {
            sendEmail(user.getEmail(), "Welcome!", "Welcome to our platform, " + user.getName() + "!");
        }
    }
    
    public static class ConsoleLogger implements Logger {
        @Override
        public void info(String message) {
            System.out.println("[INFO] " + message);
        }
        
        @Override
        public void error(String message, Throwable throwable) {
            System.out.println("[ERROR] " + message);
            if (throwable != null) {
                throwable.printStackTrace();
            }
        }
        
        @Override
        public void debug(String message) {
            System.out.println("[DEBUG] " + message);
        }
    }
    
    // Service layer
    public static class UserService {
        private final UserRepository userRepository;
        private final EmailService emailService;
        private final Logger logger;
        
        // Constructor injection
        public UserService(UserRepository userRepository, EmailService emailService, Logger logger) {
            this.userRepository = userRepository;
            this.emailService = emailService;
            this.logger = logger;
        }
        
        public User createUser(String name, String email) {
            try {
                logger.info("Creating new user: " + name);
                
                User user = new User(generateId(), name, email);
                userRepository.save(user);
                emailService.sendWelcomeEmail(user);
                
                logger.info("User created successfully: " + user.getId());
                return user;
            } catch (Exception e) {
                logger.error("Failed to create user: " + name, e);
                throw e;
            }
        }
        
        public User getUser(String id) {
            logger.debug("Getting user: " + id);
            User user = userRepository.findById(id);
            if (user == null) {
                logger.error("User not found: " + id, null);
                throw new RuntimeException("User not found: " + id);
            }
            return user;
        }
        
        public List<User> getAllUsers() {
            logger.debug("Getting all users");
            return userRepository.findAll();
        }
        
        public void deleteUser(String id) {
            logger.info("Deleting user: " + id);
            User user = getUser(id); // Sprawdza czy istnieje
            userRepository.delete(id);
            logger.info("User deleted: " + id);
        }
        
        private String generateId() {
            return "user_" + System.currentTimeMillis();
        }
    }
    
    // Simple DI Container
    public static class DIContainer {
        private final Map<Class<?>, Object> services = new HashMap<>();
        private final Map<Class<?>, Supplier<?>> factories = new HashMap<>();
        
        public <T> void registerSingleton(Class<T> serviceClass, T instance) {
            services.put(serviceClass, instance);
        }
        
        public <T> void registerFactory(Class<T> serviceClass, Supplier<T> factory) {
            factories.put(serviceClass, factory);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T get(Class<T> serviceClass) {
            // Check for singleton
            T service = (T) services.get(serviceClass);
            if (service != null) {
                return service;
            }
            
            // Check for factory
            Supplier<T> factory = (Supplier<T>) factories.get(serviceClass);
            if (factory != null) {
                return factory.get();
            }
            
            throw new RuntimeException("Service not registered: " + serviceClass.getName());
        }
        
        public void configure() {
            // Register singletons
            Logger logger = new ConsoleLogger();
            registerSingleton(Logger.class, logger);
            
            // Register factories
            registerFactory(UserRepository.class, () -> new DatabaseUserRepository(get(Logger.class)));
            registerFactory(EmailService.class, () -> new SMTPEmailService(get(Logger.class)));
            registerFactory(UserService.class, () -> new UserService(
                get(UserRepository.class),
                get(EmailService.class),
                get(Logger.class)
            ));
        }
    }
    
    // User entity
    public static class User {
        private final String id;
        private final String name;
        private final String email;
        
        public User(String id, String name, String email) {
            this.id = id;
            this.name = name;
            this.email = email;
        }
        
        public String getId() { return id; }
        public String getName() { return name; }
        public String getEmail() { return email; }
        
        @Override
        public String toString() {
            return "User{id='" + id + "', name='" + name + "', email='" + email + "'}";
        }
    }
}
```

##### Advanced Functional Interfaces

```java
public class AdvancedFunctionalInterfaces {
    // Custom functional interfaces for specific domains
    @FunctionalInterface
    public interface Transformer<T, R> {
        R transform(T input) throws Exception;
        
        default <V> Transformer<T, V> andThen(Transformer<R, V> after) {
            return input -> after.transform(this.transform(input));
        }
        
        default <V> Transformer<V, R> compose(Transformer<V, T> before) {
            return input -> this.transform(before.transform(input));
        }
        
        static <T> Transformer<T, T> identity() {
            return input -> input;
        }
        
        static <T, R> Transformer<T, R> constant(R value) {
            return input -> value;
        }
    }
    
    @FunctionalInterface
    public interface ThrowingFunction<T, R> {
        R apply(T input) throws Exception;
        
        default Function<T, Optional<R>> toOptional() {
            return input -> {
                try {
                    return Optional.of(apply(input));
                } catch (Exception e) {
                    return Optional.empty();
                }
            };
        }
        
        default Function<T, R> withDefault(R defaultValue) {
            return input -> {
                try {
                    return apply(input);
                } catch (Exception e) {
                    return defaultValue;
                }
            };
        }
        
        default Function<T, R> withExceptionHandler(Function<Exception, R> handler) {
            return input -> {
                try {
                    return apply(input);
                } catch (Exception e) {
                    return handler.apply(e);
                }
            };
        }
    }
    
    @FunctionalInterface
    public interface Retry<T> {
        T execute() throws Exception;
        
        static <T> T withRetry(Retry<T> operation, int maxAttempts, long delayMs) {
            Exception lastException = null;
            
            for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    return operation.execute();
                } catch (Exception e) {
                    lastException = e;
                    if (attempt < maxAttempts) {
                        try {
                            Thread.sleep(delayMs);
                        } catch (InterruptedException ie) {
                            Thread.currentThread().interrupt();
                            throw new RuntimeException("Interrupted during retry", ie);
                        }
                    }
                }
            }
            
            throw new RuntimeException("Operation failed after " + maxAttempts + " attempts", lastException);
        }
    }
    
    // Pipeline pattern z functional interfaces
    public static class Pipeline<T> {
        private final List<Function<T, T>> transformations = new ArrayList<>();
        
        public Pipeline<T> add(Function<T, T> transformation) {
            transformations.add(transformation);
            return this;
        }
        
        public Pipeline<T> addIf(boolean condition, Function<T, T> transformation) {
            if (condition) {
                transformations.add(transformation);
            }
            return this;
        }
        
        public Pipeline<T> filter(Predicate<T> predicate, Function<T, T> transformation) {
            transformations.add(input -> predicate.test(input) ? transformation.apply(input) : input);
            return this;
        }
        
        public T execute(T input) {
            T result = input;
            for (Function<T, T> transformation : transformations) {
                result = transformation.apply(result);
            }
            return result;
        }
        
        public List<T> execute(List<T> inputs) {
            return inputs.stream()
                        .map(this::execute)
                        .collect(Collectors.toList());
        }
        
        public static <T> Pipeline<T> create() {
            return new Pipeline<>();
        }
    }
    
    // Event-driven architecture z functional interfaces
    public static class EventBus {
        private final Map<Class<?>, List<Consumer<?>>> listeners = new HashMap<>();
        
        @SuppressWarnings("unchecked")
        public <T> void subscribe(Class<T> eventType, Consumer<T> listener) {
            listeners.computeIfAbsent(eventType, k -> new ArrayList<>()).add((Consumer<Object>) listener);
        }
        
        public <T> void unsubscribe(Class<T> eventType, Consumer<T> listener) {
            List<Consumer<?>> eventListeners = listeners.get(eventType);
            if (eventListeners != null) {
                eventListeners.remove(listener);
            }
        }
        
        @SuppressWarnings("unchecked")
        public <T> void publish(T event) {
            List<Consumer<?>> eventListeners = listeners.get(event.getClass());
            if (eventListeners != null) {
                for (Consumer<?> listener : eventListeners) {
                    try {
                        ((Consumer<Object>) listener).accept(event);
                    } catch (Exception e) {
                        System.err.println("Error in event listener: " + e.getMessage());
                    }
                }
            }
        }
        
        public <T> void publishAsync(T event) {
            CompletableFuture.runAsync(() -> publish(event));
        }
    }
    
    // Events
    public static class UserRegisteredEvent {
        private final String userId;
        private final String email;
        private final long timestamp;
        
        public UserRegisteredEvent(String userId, String email) {
            this.userId = userId;
            this.email = email;
            this.timestamp = System.currentTimeMillis();
        }
        
        public String getUserId() { return userId; }
        public String getEmail() { return email; }
        public long getTimestamp() { return timestamp; }
    }
    
    public static class OrderPlacedEvent {
        private final String orderId;
        private final String userId;
        private final double amount;
        
        public OrderPlacedEvent(String orderId, String userId, double amount) {
            this.orderId = orderId;
            this.userId = userId;
            this.amount = amount;
        }
        
        public String getOrderId() { return orderId; }
        public String getUserId() { return userId; }
        public double getAmount() { return amount; }
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj type-safe configuration system używając interfejsów z default methods i validation.

**Zadanie Zaawansowane 2:** Stwórz reactive streams implementation z functional interfaces i backpressure handling.

**Zadanie Zaawansowane 3:** Zaprojektuj plugin architecture z dynamic interface loading i lifecycle management.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak interfejsy wpływają na testability i maintainability kodu?
2. Jakie są trade-offs między default methods a abstract classes?
3. Jak functional interfaces zmieniły sposób programowania w Javie?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public interface Sortable<T extends Comparable<T>> {
    void sort(T[] array);
    String getAlgorithmName();
    
    static <T extends Comparable<T>> Sortable<T> bubbleSort() {
        return new BubbleSort<>();
    }
    
    static <T extends Comparable<T>> Sortable<T> quickSort() {
        return new QuickSort<>();
    }
    
    static <T extends Comparable<T>> Sortable<T> mergeSort() {
        return new MergeSort<>();
    }
}

public class BubbleSort<T extends Comparable<T>> implements Sortable<T> {
    @Override
    public void sort(T[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j].compareTo(array[j + 1]) > 0) {
                    T temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    
    @Override
    public String getAlgorithmName() {
        return "Bubble Sort";
    }
}

public class SortingService {
    public <T extends Comparable<T>> void sortAndPrint(T[] array, Sortable<T> sorter) {
        System.out.println("Sorting with: " + sorter.getAlgorithmName());
        System.out.println("Before: " + Arrays.toString(array));
        sorter.sort(array);
        System.out.println("After: " + Arrays.toString(array));
    }
}
```

**Zadanie 2:**
```java
public interface NotificationSender {
    boolean send(String recipient, String message);
    String getType();
    boolean isAvailable();
    
    default void sendWithRetry(String recipient, String message, int maxRetries) {
        for (int i = 0; i < maxRetries; i++) {
            if (send(recipient, message)) {
                return;
            }
            System.out.println("Retry " + (i + 1) + " failed for " + getType());
        }
        throw new RuntimeException("Failed to send notification after " + maxRetries + " retries");
    }
}

public class EmailNotificationSender implements NotificationSender {
    @Override
    public boolean send(String recipient, String message) {
        System.out.println("Sending email to: " + recipient);
        System.out.println("Message: " + message);
        return true;
    }
    
    @Override
    public String getType() {
        return "Email";
    }
    
    @Override
    public boolean isAvailable() {
        return true; // Sprawdź połączenie SMTP
    }
}

public class NotificationService {
    private final List<NotificationSender> senders;
    
    public NotificationService(List<NotificationSender> senders) {
        this.senders = senders;
    }
    
    public void sendNotification(String recipient, String message, String preferredType) {
        NotificationSender sender = senders.stream()
            .filter(s -> s.getType().equals(preferredType) && s.isAvailable())
            .findFirst()
            .orElse(senders.stream().filter(NotificationSender::isAvailable).findFirst().orElse(null));
        
        if (sender != null) {
            sender.send(recipient, message);
        } else {
            throw new RuntimeException("No available notification senders");
        }
    }
}
```

**Zadanie 3:**
```java
public interface EventListener<T> {
    void onEvent(T event);
    Class<T> getEventType();
    
    default boolean canHandle(Object event) {
        return getEventType().isInstance(event);
    }
}

public interface EventPublisher {
    <T> void subscribe(EventListener<T> listener);
    <T> void unsubscribe(EventListener<T> listener);
    void publish(Object event);
    
    default void publishAsync(Object event) {
        CompletableFuture.runAsync(() -> publish(event));
    }
}

public class SimpleEventBus implements EventPublisher {
    private final List<EventListener<?>> listeners = new ArrayList<>();
    
    @Override
    public <T> void subscribe(EventListener<T> listener) {
        listeners.add(listener);
    }
    
    @Override
    public <T> void unsubscribe(EventListener<T> listener) {
        listeners.remove(listener);
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public void publish(Object event) {
        for (EventListener<?> listener : listeners) {
            if (listener.canHandle(event)) {
                ((EventListener<Object>) listener).onEvent(event);
            }
        }
    }
}
```

**Pytania kontrolne:**
1. Interfejs może mieć tylko abstrakcyjne metody (+ default/static), klasa abstrakcyjna może mieć pola i konkretne metody. Klasa może implementować wiele interfejsów, ale dziedziczyć tylko z jednej klasy.
2. Default methods pozwalają na ewolucję interfejsów bez łamania backward compatibility. Używaj gdy chcesz dodać nową funkcjonalność do istniejącego interfejsu.
3. Functional interface ma dokładnie jedną abstrakcyjną metodę i może być używany z lambda expressions.

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Interfejsy pozwalają na dependency injection, łatwe mockowanie w testach, loose coupling między komponentami. Kod zależy od abstrakcji, nie od konkretnych implementacji.
2. Default methods pozwalają na ewolucję interfejsów, ale nie mogą mieć stanu. Abstract classes mogą mieć pola i konstruktory, ale ograniczają dziedziczenie.
3. Functional interfaces umożliwiły lambda expressions, method references, streams API. Zmieniły Javę z imperatywnej na bardziej funkcyjną.

---

### 📚 Co dalej?

*Fantastycznie! Teraz rozumiesz pełną moc interfejsów - od prostych kontraktów po zaawansowane wzorce architektoniczne. Interfejsy to fundament elastycznego, testowalnego kodu w Javie. W następnym rozdziale porozmawiamy o generykach - czyli jak tworzyć type-safe kod, który działa z różnymi typami!*

---

*💡 Pamiętaj: Interfejsy to nie tylko składnia - to sposób myślenia o architekturze. Program to abstrakcji, nie do konkretnych implementacji!*

## 17. Lambda: funkcje w wersji mini

*Cześć! Dziś porozmawiamy o lambdach - jednej z najważniejszych nowości, które zrewolucjonizowały Javę. Jeśli kiedykolwiek myślałaś "dlaczego muszę pisać tyle kodu, żeby zrobić coś tak prostego?", to lambdy są odpowiedzią na Twoje modlitwy. To jak przejście od pisania długich listów do wysyłania SMS-ów - ten sam przekaz, ale w znacznie krótszej formie!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest lambda?

Lambda to sposób na napisanie krótkiej, anonimowej funkcji bez całej ceremonii tworzenia klasy. To jak przepis na kawę: zamiast pisać całą książkę kucharską, po prostu mówisz "weź kawę, dodaj mleko, wymieszaj".

Przed lambdami, żeby posortować listę, musiałaś pisać coś takiego:

```java
// Stary sposób - dużo kodu dla prostej rzeczy
List<String> imiona = Arrays.asList("Anna", "Zofia", "Beata", "Ewa");

Collections.sort(imiona, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareTo(b);
    }
});
```

Z lambdami to samo robisz tak:

```java
// Nowy sposób - krótko i na temat
List<String> imiona = Arrays.asList("Anna", "Zofia", "Beata", "Ewa");
Collections.sort(imiona, (a, b) -> a.compareTo(b));

// Albo jeszcze krócej
imiona.sort(String::compareTo);
```

#### Składnia lambda - krok po kroku

Lambda ma prostą strukturę: `(parametry) -> { ciało funkcji }`

```java
// Podstawowa składnia
(String s) -> s.length()           // Jeden parametr
(a, b) -> a + b                    // Dwa parametry
() -> System.out.println("Cześć!") // Bez parametrów
x -> x * 2                         // Jeden parametr bez nawiasów

// Z blokiem kodu
(String s) -> {
    String upper = s.toUpperCase();
    return upper + "!";
}
```

#### Gdzie używać lambd?

Lambdy działają wszędzie tam, gdzie Java oczekuje functional interface (interfejs z jedną metodą abstrakcyjną):

```java
public class LambdaExamples {
    public static void main(String[] args) {
        List<String> miasta = Arrays.asList("Warszawa", "Kraków", "Gdańsk", "Wrocław");
        
        // Filtrowanie
        List<String> dlugieNazwy = miasta.stream()
            .filter(miasto -> miasto.length() > 6)
            .collect(Collectors.toList());
        
        // Mapowanie (transformacja)
        List<String> wielkieLitery = miasta.stream()
            .map(miasto -> miasto.toUpperCase())
            .collect(Collectors.toList());
        
        // Iterowanie
        miasta.forEach(miasto -> System.out.println("Miasto: " + miasto));
        
        // Sortowanie
        miasta.sort((a, b) -> a.length() - b.length());
        
        System.out.println("Długie nazwy: " + dlugieNazwy);
        System.out.println("Wielkie litery: " + wielkieLitery);
        System.out.println("Posortowane: " + miasta);
    }
}
```

#### Praktyczne przykłady z życia

**Przetwarzanie danych użytkowników:**

```java
public class UserProcessor {
    public static class User {
        private String name;
        private int age;
        private String city;
        private boolean active;
        
        public User(String name, int age, String city, boolean active) {
            this.name = name;
            this.age = age;
            this.city = city;
            this.active = active;
        }
        
        // Gettery
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getCity() { return city; }
        public boolean isActive() { return active; }
        
        @Override
        public String toString() {
            return name + " (" + age + ", " + city + ")";
        }
    }
    
    public static void main(String[] args) {
        List<User> users = Arrays.asList(
            new User("Anna", 25, "Warszawa", true),
            new User("Beata", 30, "Kraków", false),
            new User("Ewa", 22, "Gdańsk", true),
            new User("Zofia", 35, "Wrocław", true)
        );
        
        // Znajdź aktywnych użytkowników z Warszawy
        List<User> activeFromWarsaw = users.stream()
            .filter(user -> user.isActive())
            .filter(user -> user.getCity().equals("Warszawa"))
            .collect(Collectors.toList());
        
        // Pobierz imiona użytkowników starszych niż 25 lat
        List<String> namesOver25 = users.stream()
            .filter(user -> user.getAge() > 25)
            .map(user -> user.getName())
            .collect(Collectors.toList());
        
        // Sprawdź czy wszyscy użytkownicy są aktywni
        boolean allActive = users.stream()
            .allMatch(user -> user.isActive());
        
        // Znajdź najstarszego użytkownika
        Optional<User> oldest = users.stream()
            .max((u1, u2) -> Integer.compare(u1.getAge(), u2.getAge()));
        
        System.out.println("Aktywni z Warszawy: " + activeFromWarsaw);
        System.out.println("Imiona 25+: " + namesOver25);
        System.out.println("Wszyscy aktywni: " + allActive);
        oldest.ifPresent(user -> System.out.println("Najstarszy: " + user));
    }
}
```

**Obsługa zdarzeń w GUI:**

```java
// Zamiast tworzenia osobnych klas dla każdego przycisku
button1.addActionListener(e -> System.out.println("Kliknięto przycisk 1"));
button2.addActionListener(e -> saveData());
button3.addActionListener(e -> {
    if (validateForm()) {
        submitForm();
    } else {
        showError("Formularz zawiera błędy");
    }
});
```

**Walidacja danych:**

```java
public class ValidationExample {
    // Functional interface dla walidacji
    @FunctionalInterface
    interface Validator<T> {
        boolean isValid(T value);
    }
    
    public static void main(String[] args) {
        // Różne walidatory jako lambdy
        Validator<String> notEmpty = s -> s != null && !s.trim().isEmpty();
        Validator<String> minLength = s -> s != null && s.length() >= 3;
        Validator<Integer> positive = n -> n != null && n > 0;
        Validator<Integer> inRange = n -> n != null && n >= 18 && n <= 100;
        
        // Testowanie walidacji
        String name = "Anna";
        Integer age = 25;
        
        if (notEmpty.isValid(name) && minLength.isValid(name)) {
            System.out.println("Imię jest poprawne");
        }
        
        if (positive.isValid(age) && inRange.isValid(age)) {
            System.out.println("Wiek jest poprawny");
        }
        
        // Kombinowanie walidatorów
        List<String> emails = Arrays.asList("test@example.com", "", "invalid", "user@domain.org");
        
        emails.stream()
            .filter(email -> email.contains("@"))
            .filter(email -> email.contains("."))
            .forEach(email -> System.out.println("Poprawny email: " + email));
    }
}
```

#### Method References - jeszcze krócej!

Czasami lambda jest tak prosta, że można ją zastąpić method reference:

```java
// Lambda vs Method Reference
List<String> words = Arrays.asList("java", "lambda", "stream", "method");

// Lambda
words.forEach(word -> System.out.println(word));
// Method reference
words.forEach(System.out::println);

// Lambda
words.stream().map(word -> word.toUpperCase());
// Method reference
words.stream().map(String::toUpperCase);

// Lambda
words.stream().filter(word -> word.startsWith("j"));
// Method reference (nie zawsze możliwe)
// words.stream().filter(String::startsWith); // To nie zadziała!
```

#### Typy method references

```java
public class MethodReferences {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("java", "python", "kotlin", "scala");
        
        // 1. Reference do static method
        words.stream()
            .map(String::valueOf)  // String.valueOf(word)
            .forEach(System.out::println);
        
        // 2. Reference do instance method konkretnego obiektu
        String prefix = "Language: ";
        words.stream()
            .map(prefix::concat)   // prefix.concat(word)
            .forEach(System.out::println);
        
        // 3. Reference do instance method dowolnego obiektu danego typu
        words.stream()
            .map(String::toUpperCase)  // word.toUpperCase()
            .forEach(System.out::println);
        
        // 4. Reference do konstruktora
        words.stream()
            .map(StringBuilder::new)   // new StringBuilder(word)
            .forEach(sb -> System.out.println(sb.toString()));
    }
}
```

#### Streams API - naturalne środowisko lambd

```java
public class StreamsWithLambdas {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Łańcuch operacji z lambdami
        List<String> result = numbers.stream()
            .filter(n -> n % 2 == 0)           // Tylko parzyste
            .map(n -> n * n)                   // Podnieś do kwadratu
            .filter(n -> n > 10)               // Większe niż 10
            .map(n -> "Number: " + n)          // Konwertuj na String
            .collect(Collectors.toList());     // Zbierz do listy
        
        result.forEach(System.out::println);
        
        // Operacje redukcji
        int sum = numbers.stream()
            .filter(n -> n > 5)
            .mapToInt(Integer::intValue)
            .sum();
        
        OptionalDouble average = numbers.stream()
            .mapToInt(Integer::intValue)
            .average();
        
        Optional<Integer> max = numbers.stream()
            .max(Integer::compareTo);
        
        System.out.println("Suma liczb > 5: " + sum);
        System.out.println("Średnia: " + average.orElse(0.0));
        System.out.println("Maksimum: " + max.orElse(0));
        
        // Grupowanie
        Map<Boolean, List<Integer>> evenOdd = numbers.stream()
            .collect(Collectors.partitioningBy(n -> n % 2 == 0));
        
        System.out.println("Parzyste: " + evenOdd.get(true));
        System.out.println("Nieparzyste: " + evenOdd.get(false));
    }
}
```

#### Praktyczne wzorce z lambdami

**1. Factory pattern z lambdami:**

```java
public class LambdaFactory {
    @FunctionalInterface
    interface ShapeFactory {
        Shape create(double... params);
    }
    
    interface Shape {
        double area();
        String getType();
    }
    
    static class Circle implements Shape {
        private final double radius;
        
        Circle(double radius) { this.radius = radius; }
        
        @Override
        public double area() { return Math.PI * radius * radius; }
        
        @Override
        public String getType() { return "Circle"; }
    }
    
    static class Rectangle implements Shape {
        private final double width, height;
        
        Rectangle(double width, double height) {
            this.width = width;
            this.height = height;
        }
        
        @Override
        public double area() { return width * height; }
        
        @Override
        public String getType() { return "Rectangle"; }
    }
    
    public static void main(String[] args) {
        Map<String, ShapeFactory> factories = Map.of(
            "circle", params -> new Circle(params[0]),
            "rectangle", params -> new Rectangle(params[0], params[1])
        );
        
        // Tworzenie kształtów przez lambdy
        Shape circle = factories.get("circle").create(5.0);
        Shape rectangle = factories.get("rectangle").create(4.0, 6.0);
        
        System.out.println(circle.getType() + " area: " + circle.area());
        System.out.println(rectangle.getType() + " area: " + rectangle.area());
    }
}
```

**2. Command pattern z lambdami:**

```java
public class LambdaCommands {
    @FunctionalInterface
    interface Command {
        void execute();
    }
    
    static class Calculator {
        private double value = 0;
        
        void add(double x) { value += x; }
        void subtract(double x) { value -= x; }
        void multiply(double x) { value *= x; }
        void divide(double x) { if (x != 0) value /= x; }
        
        double getValue() { return value; }
        void setValue(double value) { this.value = value; }
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        calc.setValue(10);
        
        // Komendy jako lambdy
        List<Command> commands = Arrays.asList(
            () -> calc.add(5),
            () -> calc.multiply(2),
            () -> calc.subtract(3),
            () -> calc.divide(2)
        );
        
        System.out.println("Wartość początkowa: " + calc.getValue());
        
        // Wykonanie komend
        commands.forEach(command -> {
            command.execute();
            System.out.println("Po operacji: " + calc.getValue());
        });
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Zacznij od prostych lambd**: `x -> x * 2` zamiast skomplikowanych bloków
- **Używaj opisowych nazw parametrów**: `user -> user.getName()` zamiast `u -> u.getName()`
- **Nie bój się eksperymentować**: IDE podpowie Ci, gdzie możesz użyć lambd
- **Method references dla prostych przypadków**: `String::toUpperCase` zamiast `s -> s.toUpperCase()`
- **Streams + lambdy = potęga**: To najczęstsze zastosowanie

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz listę liczb i użyj lambd do:
- Znalezienia wszystkich liczb parzystych
- Pomnożenia każdej liczby przez 2
- Znalezienia największej liczby

**Zadanie 2:** Mając listę produktów (nazwa, cena), użyj lambd do:
- Znalezienia produktów droższych niż 100 zł
- Posortowania po cenie
- Obliczenia średniej ceny

**Zadanie 3:** Stwórz prosty kalkulator używając lambd dla różnych operacji (dodawanie, odejmowanie, mnożenie, dzielenie).

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest składnia podstawowej lambdy?
2. Czym różni się lambda od method reference?
3. Gdzie najczęściej używa się lambd w Javie?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza lambd

Lambdy to nie tylko syntactic sugar - to fundamentalna zmiana w sposobie myślenia o programowaniu w Javie. Wprowadzają elementy programowania funkcyjnego do tradycyjnie obiektowego języka.

##### Jak lambdy działają pod maską?

```java
public class LambdaInternals {
    public static void main(String[] args) {
        // Ta lambda...
        Runnable r1 = () -> System.out.println("Hello");
        
        // ...jest kompilowana do czegoś podobnego do:
        Runnable r2 = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello");
            }
        };
        
        // Ale nie do końca! Lambda używa invokedynamic
        // i jest bardziej efektywna niż klasa anonimowa
    }
}
```

**Invokedynamic i performance:**

Lambdy używają instrukcji `invokedynamic` wprowadzonej w Javie 7. To oznacza, że:
- Nie tworzą nowych plików `.class` dla każdej lambdy
- Są lazy-loaded - tworzone dopiero przy pierwszym użyciu
- JVM może je optymalizować lepiej niż klasy anonimowe
- Mają mniejszy memory footprint

##### Closures i przechwytywanie zmiennych

```java
public class ClosureExamples {
    private int instanceVar = 10;
    private static int staticVar = 20;
    
    public void demonstrateClosures() {
        int localVar = 30;
        final int finalVar = 40;
        
        // Lambda może przechwycić:
        Runnable lambda = () -> {
            // 1. Zmienne instancji
            System.out.println("Instance: " + instanceVar);
            
            // 2. Zmienne statyczne
            System.out.println("Static: " + staticVar);
            
            // 3. Zmienne lokalne (effectively final)
            System.out.println("Local: " + localVar);
            System.out.println("Final: " + finalVar);
            
            // 4. Może modyfikować zmienne instancji
            instanceVar = 15; // OK
            
            // 5. Ale NIE może modyfikować zmiennych lokalnych
            // localVar = 35; // Błąd kompilacji!
        };
        
        // localVar = 35; // To też spowodowałoby błąd w lambdzie!
        
        lambda.run();
    }
    
    // Workaround dla modyfikacji zmiennych lokalnych
    public void mutableClosureWorkaround() {
        AtomicInteger counter = new AtomicInteger(0);
        List<String> items = Arrays.asList("a", "b", "c");
        
        items.forEach(item -> {
            int current = counter.incrementAndGet();
            System.out.println(current + ": " + item);
        });
        
        System.out.println("Final count: " + counter.get());
    }
    
    // Demonstracja różnych typów closure
    public void closureTypes() {
        int localValue = 100;
        
        // Non-capturing lambda - nie przechwytuje żadnych zmiennych
        Supplier<String> nonCapturing = () -> "Constant value";
        
        // Capturing lambda - przechwytuje zmienne z otoczenia
        Supplier<String> capturing = () -> "Local value: " + localValue;
        
        // Self-contained lambda z własnym stanem
        Supplier<Integer> stateful = new Supplier<Integer>() {
            private int count = 0;
            
            @Override
            public Integer get() {
                return ++count;
            }
        };
        
        System.out.println(nonCapturing.get());
        System.out.println(capturing.get());
        System.out.println("Stateful: " + stateful.get() + ", " + stateful.get());
    }
}
```

##### Zaawansowane wzorce z lambdami

**1. Function Composition:**

```java
public class FunctionComposition {
    public static void main(String[] args) {
        Function<String, String> addPrefix = s -> "PREFIX_" + s;
        Function<String, String> addSuffix = s -> s + "_SUFFIX";
        Function<String, String> toUpper = String::toUpperCase;
        
        // Komponowanie funkcji
        Function<String, String> composed = addPrefix
            .andThen(toUpper)
            .andThen(addSuffix);
        
        String result = composed.apply("test");
        System.out.println(result); // PREFIX_TEST_SUFFIX
        
        // Alternatywnie - compose (odwrotna kolejność)
        Function<String, String> composed2 = addSuffix
            .compose(toUpper)
            .compose(addPrefix);
        
        String result2 = composed2.apply("test");
        System.out.println(result2); // PREFIX_TEST_SUFFIX
        
        // Predicate composition
        Predicate<String> notNull = Objects::nonNull;
        Predicate<String> notEmpty = s -> !s.isEmpty();
        Predicate<String> hasContent = notNull.and(notEmpty);
        
        System.out.println("Valid string: " + hasContent.test("hello")); // true
        System.out.println("Invalid string: " + hasContent.test("")); // false
    }
}
```

**2. Currying i Partial Application:**

```java
public class CurryingExample {
    // Funkcja trzech argumentów
    static Function<Integer, Function<Integer, Function<Integer, Integer>>> add3 = 
        a -> b -> c -> a + b + c;
    
    // Partial application
    static Function<Integer, Integer> add5And10 = add3.apply(5).apply(10);
    
    public static void main(String[] args) {
        // Pełne wywołanie
        int result1 = add3.apply(1).apply(2).apply(3); // 6
        
        // Partial application
        int result2 = add5And10.apply(7); // 22 (5 + 10 + 7)
        
        System.out.println("Result 1: " + result1);
        System.out.println("Result 2: " + result2);
        
        // Praktyczny przykład - konfiguracja walidatorów
        Function<Integer, Function<Integer, Predicate<Integer>>> rangeValidator = 
            min -> max -> value -> value >= min && value <= max;
        
        Predicate<Integer> ageValidator = rangeValidator.apply(18).apply(65);
        Predicate<Integer> percentageValidator = rangeValidator.apply(0).apply(100);
        
        System.out.println("Age 25 valid: " + ageValidator.test(25)); // true
        System.out.println("Percentage 150 valid: " + percentageValidator.test(150)); // false
    }
}
```

**3. Memoization z lambdami:**

```java
public class MemoizationExample {
    public static <T, R> Function<T, R> memoize(Function<T, R> function) {
        Map<T, R> cache = new ConcurrentHashMap<>();
        return input -> cache.computeIfAbsent(input, function);
    }
    
    // Przykład: kosztowna operacja
    static Function<Integer, BigInteger> fibonacci = MemoizationExample.memoize(n -> {
        System.out.println("Computing fibonacci(" + n + ")");
        if (n <= 1) return BigInteger.valueOf(n);
        return MemoizationExample.fibonacci.apply(n - 1)
            .add(MemoizationExample.fibonacci.apply(n - 2));
    });
    
    public static void main(String[] args) {
        System.out.println("First call:");
        System.out.println(fibonacci.apply(10));
        
        System.out.println("\nSecond call (cached):");
        System.out.println(fibonacci.apply(10));
        
        System.out.println("\nThird call (partially cached):");
        System.out.println(fibonacci.apply(12));
    }
}
```

**4. Event-driven programming z lambdami:**

```java
public class EventDrivenExample {
    public interface EventListener<T> {
        void handle(T event);
    }
    
    public static class EventBus<T> {
        private final List<EventListener<T>> listeners = new ArrayList<>();
        private final List<Function<T, T>> middlewares = new ArrayList<>();
        
        public void subscribe(EventListener<T> listener) {
            listeners.add(listener);
        }
        
        public void unsubscribe(EventListener<T> listener) {
            listeners.remove(listener);
        }
        
        public void addMiddleware(Function<T, T> middleware) {
            middlewares.add(middleware);
        }
        
        public void publish(T event) {
            // Zastosuj middleware
            T processedEvent = middlewares.stream()
                .reduce(Function.identity(), Function::andThen)
                .apply(event);
            
            // Powiadom słuchaczy
            listeners.forEach(listener -> {
                try {
                    listener.handle(processedEvent);
                } catch (Exception e) {
                    System.err.println("Error in event listener: " + e.getMessage());
                }
            });
        }
        
        // Fluent API dla subskrypcji
        public EventBus<T> on(EventListener<T> listener) {
            subscribe(listener);
            return this;
        }
    }
    
    public static class UserEvent {
        private final String type;
        private final String userId;
        private final Map<String, Object> data;
        
        public UserEvent(String type, String userId, Map<String, Object> data) {
            this.type = type;
            this.userId = userId;
            this.data = data;
        }
        
        public String getType() { return type; }
        public String getUserId() { return userId; }
        public Map<String, Object> getData() { return data; }
        
        @Override
        public String toString() {
            return "UserEvent{type='" + type + "', userId='" + userId + "'}";
        }
    }
    
    public static void main(String[] args) {
        EventBus<UserEvent> userEventBus = new EventBus<>();
        
        // Middleware dla logowania
        userEventBus.addMiddleware(event -> {
            System.out.println("Middleware: Processing " + event);
            return event;
        });
        
        // Subskrypcja z lambdami
        userEventBus
            .on(event -> {
                if ("USER_REGISTERED".equals(event.getType())) {
                    System.out.println("Sending welcome email to: " + event.getUserId());
                }
            })
            .on(event -> {
                if ("USER_LOGIN".equals(event.getType())) {
                    System.out.println("Logging user activity: " + event.getUserId());
                }
            })
            .on(event -> System.out.println("Audit log: " + event.getType() + " for " + event.getUserId()));
        
        // Publikowanie zdarzeń
        userEventBus.publish(new UserEvent("USER_REGISTERED", "user123", Map.of("email", "user@example.com")));
        userEventBus.publish(new UserEvent("USER_LOGIN", "user123", Map.of("ip", "192.168.1.1")));
    }
}
```

##### Efekty uboczne i pułapki

**1. Side effects w lambdach:**

```java
public class SideEffectsProblems {
    public static void main(String[] args) {
        List<String> items = Arrays.asList("a", "b", "c", "d");
        List<String> results = new ArrayList<>();
        
        // PROBLEM: Side effect w lambdzie
        items.stream()
            .filter(s -> s.length() > 0)
            .forEach(s -> results.add(s.toUpperCase())); // Side effect!
        
        // LEPIEJ: Funkcyjne podejście
        List<String> betterResults = items.stream()
            .filter(s -> s.length() > 0)
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        
        System.out.println("Side effect results: " + results);
        System.out.println("Functional results: " + betterResults);
        
        // PROBLEM: Modyfikacja zewnętrznego stanu
        AtomicInteger counter = new AtomicInteger(0);
        items.stream()
            .forEach(s -> counter.incrementAndGet()); // Side effect!
        
        // LEPIEJ: Użyj count()
        long count = items.stream().count();
        
        System.out.println("Counter: " + counter.get());
        System.out.println("Count: " + count);
    }
}
```

**2. Exception handling w lambdach:**

```java
public class ExceptionHandling {
    @FunctionalInterface
    interface ThrowingFunction<T, R> {
        R apply(T t) throws Exception;
    }
    
    public static <T, R> Function<T, R> unchecked(ThrowingFunction<T, R> f) {
        return t -> {
            try {
                return f.apply(t);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
    
    public static <T, R> Function<T, Optional<R>> safe(ThrowingFunction<T, R> f) {
        return t -> {
            try {
                return Optional.of(f.apply(t));
            } catch (Exception e) {
                return Optional.empty();
            }
        };
    }
    
    public static void main(String[] args) {
        List<String> urls = Arrays.asList("http://example.com", "invalid-url", "http://google.com");
        
        // Problem: checked exceptions w lambdach
        // urls.stream().map(url -> new URL(url)); // Nie kompiluje się!
        
        // Rozwiązanie 1: wrapper
        List<URL> urlObjects = urls.stream()
            .map(unchecked(URL::new))
            .collect(Collectors.toList());
        
        // Rozwiązanie 2: Optional dla error handling
        List<Optional<URL>> urlOptionals = urls.stream()
            .map(safe(URL::new))
            .collect(Collectors.toList());
        
        // Rozwiązanie 3: filter out errors
        List<URL> validUrls = urls.stream()
            .map(safe(URL::new))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
        
        System.out.println("All URLs (with exceptions): " + urlObjects.size());
        System.out.println("Optional URLs: " + urlOptionals);
        System.out.println("Valid URLs: " + validUrls);
    }
}
```

**3. Performance considerations:**

```java
public class LambdaPerformance {
    private static final int ITERATIONS = 1_000_000;
    
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.range(0, 1000)
            .boxed()
            .collect(Collectors.toList());
        
        // Test 1: Lambda vs Method Reference vs Anonymous Class
        measureTime("Lambda", () -> {
            numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * 2)
                .sum();
        });
        
        measureTime("Method Reference", () -> {
            numbers.stream()
                .filter(LambdaPerformance::isEven)
                .mapToInt(LambdaPerformance::doubleValue)
                .sum();
        });
        
        measureTime("Anonymous Class", () -> {
            numbers.stream()
                .filter(new Predicate<Integer>() {
                    @Override
                    public boolean test(Integer n) {
                        return n % 2 == 0;
                    }
                })
                .mapToInt(new ToIntFunction<Integer>() {
                    @Override
                    public int applyAsInt(Integer n) {
                        return n * 2;
                    }
                })
                .sum();
        });
        
        // Test 2: Primitive streams vs Object streams
        measureTime("Primitive Stream", () -> {
            IntStream.range(0, 1000)
                .filter(n -> n % 2 == 0)
                .map(n -> n * 2)
                .sum();
        });
        
        measureTime("Object Stream", () -> {
            IntStream.range(0, 1000)
                .boxed()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * 2)
                .sum();
        });
        
        // Test 3: Capturing vs non-capturing lambdas
        int multiplier = 2;
        measureTime("Capturing Lambda", () -> {
            numbers.stream()
                .mapToInt(n -> n * multiplier) // Captures 'multiplier'
                .sum();
        });
        
        measureTime("Non-capturing Lambda", () -> {
            numbers.stream()
                .mapToInt(n -> n * 2) // No capture
                .sum();
        });
    }
    
    private static void measureTime(String name, Runnable operation) {
        // Warm-up
        for (int i = 0; i < 10000; i++) {
            operation.run();
        }
        
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            operation.run();
        }
        long end = System.nanoTime();
        
        System.out.printf("%s: %.2f ms%n", name, (end - start) / 1_000_000.0);
    }
    
    private static boolean isEven(Integer n) {
        return n % 2 == 0;
    }
    
    private static int doubleValue(Integer n) {
        return n * 2;
    }
}
```

**4. Memory leaks z lambdami:**

```java
public class LambdaMemoryLeaks {
    private String heavyData = "Very heavy data...".repeat(10000);
    
    // PROBLEM: Lambda przechwytuje całą instancję
    public Supplier<String> createLeakySupplier() {
        return () -> "Some result"; // Przechwytuje 'this' niepotrzebnie!
    }
    
    // ROZWIĄZANIE: Static method lub explicit parameter
    public static Supplier<String> createNonLeakySupplier() {
        return () -> "Some result"; // Nie przechwytuje niczego
    }
    
    public Supplier<String> createSupplierWithParameter(String data) {
        return () -> data; // Przechwytuje tylko 'data', nie całe 'this'
    }
    
    // PROBLEM: Listener nie jest usuwany
    public void addListenerWithLeak(EventBus eventBus) {
        eventBus.subscribe(event -> {
            // Lambda przechwytuje 'this', więc obiekt nie może być GC
            System.out.println("Processing: " + event);
        });
    }
    
    // ROZWIĄZANIE: Explicit cleanup
    private EventListener listener;
    
    public void addListenerWithCleanup(EventBus eventBus) {
        listener = event -> System.out.println("Processing: " + event);
        eventBus.subscribe(listener);
    }
    
    public void cleanup(EventBus eventBus) {
        if (listener != null) {
            eventBus.unsubscribe(listener);
            listener = null;
        }
    }
    
    interface EventBus {
        void subscribe(EventListener listener);
        void unsubscribe(EventListener listener);
    }
    
    interface EventListener {
        void handle(Object event);
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj własny reactive streams framework używając lambd i kompozycji funkcji.

**Zadanie Zaawansowane 2:** Stwórz type-safe query builder z fluent API używając function composition.

**Zadanie Zaawansowane 3:** Zaprojektuj system middleware dla web applications używając lambd i partial application.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak lambdy wpływają na performance w porównaniu do klas anonimowych?
2. Jakie są ograniczenia closures w lambdach Java?
3. Jak radzić sobie z checked exceptions w lambdach?
4. Jakie są potencjalne źródła memory leaks z lambdami?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Liczby parzyste
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

// Pomnożenie przez 2
List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

// Największa liczba
Optional<Integer> max = numbers.stream()
    .max((a, b) -> Integer.compare(a, b));
// lub krócej:
Optional<Integer> max2 = numbers.stream()
    .max(Integer::compareTo);

System.out.println("Parzyste: " + evenNumbers);
System.out.println("Podwojone: " + doubled);
System.out.println("Maksimum: " + max.orElse(0));
```

**Zadanie 2:**
```java
public class Product {
    private String name;
    private double price;
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    
    @Override
    public String toString() {
        return name + " (" + price + " zł)";
    }
}

List<Product> products = Arrays.asList(
    new Product("Laptop", 2500.0),
    new Product("Mysz", 50.0),
    new Product("Klawiatura", 150.0),
    new Product("Monitor", 800.0)
);

// Produkty droższe niż 100 zł
List<Product> expensive = products.stream()
    .filter(p -> p.getPrice() > 100)
    .collect(Collectors.toList());

// Sortowanie po cenie
List<Product> sorted = products.stream()
    .sorted((p1, p2) -> Double.compare(p1.getPrice(), p2.getPrice()))
    .collect(Collectors.toList());

// Średnia cena
double averagePrice = products.stream()
    .mapToDouble(Product::getPrice)
    .average()
    .orElse(0.0);

System.out.println("Drogie produkty: " + expensive);
System.out.println("Posortowane: " + sorted);
System.out.println("Średnia cena: " + averagePrice + " zł");
```

**Zadanie 3:**
```java
public class LambdaCalculator {
    @FunctionalInterface
    interface Operation {
        double calculate(double a, double b);
    }
    
    private static final Map<String, Operation> operations = Map.of(
        "+", (a, b) -> a + b,
        "-", (a, b) -> a - b,
        "*", (a, b) -> a * b,
        "/", (a, b) -> b != 0 ? a / b : Double.NaN,
        "^", Math::pow,
        "%", (a, b) -> a % b
    );
    
    public static double calculate(double a, double b, String operator) {
        return operations.getOrDefault(operator, (x, y) -> Double.NaN)
                        .calculate(a, b);
    }
    
    public static void main(String[] args) {
        System.out.println("10 + 5 = " + calculate(10, 5, "+"));
        System.out.println("10 - 5 = " + calculate(10, 5, "-"));
        System.out.println("10 * 5 = " + calculate(10, 5, "*"));
        System.out.println("10 / 5 = " + calculate(10, 5, "/"));
        System.out.println("10 ^ 2 = " + calculate(10, 2, "^"));
        System.out.println("10 % 3 = " + calculate(10, 3, "%"));
    }
}
```

**Pytania kontrolne:**
1. `(parametry) -> wyrażenie` lub `(parametry) -> { blok kodu }`
2. Lambda to anonimowa funkcja, method reference to odwołanie do istniejącej metody (`String::toUpperCase`)
3. W streams API, event handling, functional interfaces, collections operations

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Lambdy są bardziej efektywne - używają invokedynamic, nie tworzą nowych klas, mają lepszy memory footprint i są optymalizowane przez JIT
2. Mogą przechwytywać tylko effectively final zmienne lokalne, nie mogą ich modyfikować, przechwytują całą instancję gdy używają this
3. Wrapper functions, Optional, biblioteki jak Vavr, lub własne functional interfaces z default methods
4. Przechwytywanie this niepotrzebnie, listeners nie usuwane, capturing lambdas w długo żyjących kolekcjach

---

### 📚 Co dalej?

*Fantastycznie! Teraz rozumiesz pełną moc lambd - od prostej składni po zaawansowane wzorce funkcyjne. Lambdy zmieniły sposób programowania w Javie, czyniąc kod bardziej zwięzłym i ekspresyjnym. W następnym rozdziale porozmawiamy o functional interfaces - teoretycznej podstawie, która sprawia, że lambdy w ogóle działają!*

---

*💡 Pamiętaj: Lambdy to nie tylko krótsza składnia - to nowy sposób myślenia o problemach. Zamiast "jak to zrobić krok po kroku", myśl "co chcę osiągnąć"!*

## 18. Functional interfaces: teoria spiskowa @FunctionalInterface

*Cześć! Dziś zagłębimy się w tajemnice functional interfaces - teoretyczną podstawę, która sprawia, że lambdy w ogóle działają. To jak poznanie przepisu na ciasto, które już jadłaś - nagle wszystko zaczyna mieć sens! Functional interfaces to most między tradycyjną Javą obiektową a nowoczesnymi elementami funkcyjnymi.*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest functional interface?

Functional interface to interfejs, który ma dokładnie jedną abstrakcyjną metodę. To wszystko! Brzmi prosto, prawda? Ale ta prostota kryje w sobie ogromną moc.

```java
// To jest functional interface
@FunctionalInterface
public interface Calculator {
    double calculate(double a, double b);
}

// To też jest functional interface (bez adnotacji)
public interface Printer {
    void print(String message);
}

// To NIE jest functional interface - za dużo metod
public interface MultiMethod {
    void method1();
    void method2(); // Za dużo!
}
```

Adnotacja `@FunctionalInterface` nie jest wymagana, ale to dobra praktyka - kompilator sprawdzi, czy rzeczywiście masz tylko jedną abstrakcyjną metodę.

#### Dlaczego to ważne?

Functional interfaces to klucz do lambd. Java może przekształcić lambdę w implementację functional interface, bo wie dokładnie, którą metodę ma zaimplementować.

```java
// Functional interface
@FunctionalInterface
interface StringProcessor {
    String process(String input);
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Stary sposób - klasa anonimowa
        StringProcessor upperCase1 = new StringProcessor() {
            @Override
            public String process(String input) {
                return input.toUpperCase();
            }
        };
        
        // Nowy sposób - lambda
        StringProcessor upperCase2 = input -> input.toUpperCase();
        
        // Jeszcze krócej - method reference
        StringProcessor upperCase3 = String::toUpperCase;
        
        // Wszystkie robią to samo!
        System.out.println(upperCase1.process("hello")); // HELLO
        System.out.println(upperCase2.process("hello")); // HELLO
        System.out.println(upperCase3.process("hello")); // HELLO
    }
}
```

#### Wbudowane functional interfaces

Java dostarcza gotowe functional interfaces w pakiecie `java.util.function`. Nie musisz tworzyć własnych dla typowych przypadków:

```java
import java.util.function.*;

public class BuiltInFunctionalInterfaces {
    public static void main(String[] args) {
        // Predicate<T> - zwraca boolean
        Predicate<String> isEmpty = String::isEmpty;
        Predicate<Integer> isEven = n -> n % 2 == 0;
        
        System.out.println(isEmpty.test("")); // true
        System.out.println(isEven.test(4));   // true
        
        // Function<T, R> - przekształca T w R
        Function<String, Integer> stringLength = String::length;
        Function<Integer, String> intToString = Object::toString;
        
        System.out.println(stringLength.apply("Hello")); // 5
        System.out.println(intToString.apply(42));       // "42"
        
        // Consumer<T> - przyjmuje T, nic nie zwraca
        Consumer<String> printer = System.out::println;
        Consumer<List<String>> listCleaner = List::clear;
        
        printer.accept("Hello World!");
        
        // Supplier<T> - nie przyjmuje nic, zwraca T
        Supplier<String> randomString = () -> "Random: " + Math.random();
        Supplier<List<String>> listFactory = ArrayList::new;
        
        System.out.println(randomString.get());
        List<String> newList = listFactory.get();
        
        // UnaryOperator<T> - Function<T, T>
        UnaryOperator<String> addPrefix = s -> "PREFIX_" + s;
        UnaryOperator<Integer> square = n -> n * n;
        
        System.out.println(addPrefix.apply("test")); // PREFIX_test
        System.out.println(square.apply(5));         // 25
        
        // BinaryOperator<T> - BiFunction<T, T, T>
        BinaryOperator<Integer> add = (a, b) -> a + b;
        BinaryOperator<String> concat = (a, b) -> a + b;
        
        System.out.println(add.apply(3, 4));           // 7
        System.out.println(concat.apply("Hello", " World")); // Hello World
    }
}
```

#### Praktyczne zastosowania

**1. Walidacja danych:**

```java
public class ValidationExample {
    // Własny functional interface dla walidacji
    @FunctionalInterface
    interface Validator<T> {
        boolean isValid(T value);
        
        // Default method dla łączenia walidatorów
        default Validator<T> and(Validator<T> other) {
            return value -> this.isValid(value) && other.isValid(value);
        }
        
        default Validator<T> or(Validator<T> other) {
            return value -> this.isValid(value) || other.isValid(value);
        }
    }
    
    public static void main(String[] args) {
        // Różne walidatory
        Validator<String> notNull = value -> value != null;
        Validator<String> notEmpty = value -> !value.isEmpty();
        Validator<String> minLength = value -> value.length() >= 3;
        Validator<String> hasAtSign = value -> value.contains("@");
        
        // Kombinowanie walidatorów
        Validator<String> basicStringValidator = notNull.and(notEmpty).and(minLength);
        Validator<String> emailValidator = basicStringValidator.and(hasAtSign);
        
        // Testowanie
        String[] testStrings = {null, "", "ab", "abc", "test@example.com"};
        
        for (String test : testStrings) {
            System.out.println("'" + test + "' - basic: " + 
                safeValidate(basicStringValidator, test) + 
                ", email: " + safeValidate(emailValidator, test));
        }
    }
    
    private static <T> boolean safeValidate(Validator<T> validator, T value) {
        try {
            return validator.isValid(value);
        } catch (Exception e) {
            return false;
        }
    }
}
```

**2. Event handling:**

```java
public class EventHandlingExample {
    @FunctionalInterface
    interface EventHandler<T> {
        void handle(T event);
    }
    
    public static class Event {
        private final String type;
        private final String message;
        private final long timestamp;
        
        public Event(String type, String message) {
            this.type = type;
            this.message = message;
            this.timestamp = System.currentTimeMillis();
        }
        
        public String getType() { return type; }
        public String getMessage() { return message; }
        public long getTimestamp() { return timestamp; }
    }
    
    public static class EventProcessor {
        private final Map<String, List<EventHandler<Event>>> handlers = new HashMap<>();
        
        public void subscribe(String eventType, EventHandler<Event> handler) {
            handlers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(handler);
        }
        
        public void publish(Event event) {
            List<EventHandler<Event>> eventHandlers = handlers.get(event.getType());
            if (eventHandlers != null) {
                eventHandlers.forEach(handler -> handler.handle(event));
            }
        }
    }
    
    public static void main(String[] args) {
        EventProcessor processor = new EventProcessor();
        
        // Subskrypcja z lambdami
        processor.subscribe("USER_LOGIN", event -> 
            System.out.println("Logging: " + event.getMessage()));
        
        processor.subscribe("USER_LOGIN", event -> 
            System.out.println("Analytics: User logged in at " + event.getTimestamp()));
        
        processor.subscribe("ERROR", event -> 
            System.err.println("ERROR: " + event.getMessage()));
        
        // Publikowanie zdarzeń
        processor.publish(new Event("USER_LOGIN", "User john.doe logged in"));
        processor.publish(new Event("ERROR", "Database connection failed"));
    }
}
```

**3. Strategy pattern z functional interfaces:**

```java
public class StrategyPatternExample {
    @FunctionalInterface
    interface DiscountStrategy {
        double calculateDiscount(double price, int quantity);
    }
    
    public static class Product {
        private final String name;
        private final double price;
        
        public Product(String name, double price) {
            this.name = name;
            this.price = price;
        }
        
        public String getName() { return name; }
        public double getPrice() { return price; }
    }
    
    public static class ShoppingCart {
        private final List<Product> products = new ArrayList<>();
        private DiscountStrategy discountStrategy = (price, qty) -> 0; // No discount by default
        
        public void addProduct(Product product) {
            products.add(product);
        }
        
        public void setDiscountStrategy(DiscountStrategy strategy) {
            this.discountStrategy = strategy;
        }
        
        public double calculateTotal() {
            double total = products.stream()
                .mapToDouble(Product::getPrice)
                .sum();
            
            double discount = discountStrategy.calculateDiscount(total, products.size());
            return total - discount;
        }
    }
    
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        cart.addProduct(new Product("Laptop", 2000));
        cart.addProduct(new Product("Mouse", 50));
        cart.addProduct(new Product("Keyboard", 100));
        
        System.out.println("No discount: " + cart.calculateTotal());
        
        // 10% discount for orders over 1000
        cart.setDiscountStrategy((price, qty) -> price > 1000 ? price * 0.1 : 0);
        System.out.println("10% discount: " + cart.calculateTotal());
        
        // 5% discount per item (max 20%)
        cart.setDiscountStrategy((price, qty) -> Math.min(price * 0.05 * qty, price * 0.2));
        System.out.println("Per item discount: " + cart.calculateTotal());
        
        // Fixed 100 discount for 3+ items
        cart.setDiscountStrategy((price, qty) -> qty >= 3 ? 100 : 0);
        System.out.println("Fixed discount: " + cart.calculateTotal());
    }
}
```

#### Tworzenie własnych functional interfaces

```java
public class CustomFunctionalInterfaces {
    // Functional interface dla operacji z dwoma argumentami i wyjątkiem
    @FunctionalInterface
    interface ThrowingBiFunction<T, U, R> {
        R apply(T t, U u) throws Exception;
    }
    
    // Functional interface dla operacji z trzema argumentami
    @FunctionalInterface
    interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }
    
    // Functional interface dla operacji bez argumentów z wyjątkiem
    @FunctionalInterface
    interface ThrowingSupplier<T> {
        T get() throws Exception;
    }
    
    public static void main(String[] args) {
        // Użycie ThrowingBiFunction
        ThrowingBiFunction<String, String, Integer> stringToInt = (s1, s2) -> {
            return Integer.parseInt(s1) + Integer.parseInt(s2);
        };
        
        try {
            int result = stringToInt.apply("10", "20");
            System.out.println("Result: " + result); // 30
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
        }
        
        // Użycie TriFunction
        TriFunction<String, String, String, String> fullNameFormatter = 
            (first, middle, last) -> first + " " + middle + " " + last;
        
        String fullName = fullNameFormatter.apply("Anna", "Maria", "Kowalska");
        System.out.println("Full name: " + fullName);
        
        // Użycie ThrowingSupplier
        ThrowingSupplier<String> fileReader = () -> {
            // Symulacja czytania pliku
            if (Math.random() > 0.5) {
                throw new IOException("File not found");
            }
            return "File content";
        };
        
        try {
            String content = fileReader.get();
            System.out.println("Content: " + content);
        } catch (Exception e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
    }
}
```

#### Kombinowanie functional interfaces

```java
public class CombiningFunctionalInterfaces {
    public static void main(String[] args) {
        // Kombinowanie Predicate
        Predicate<String> notNull = Objects::nonNull;
        Predicate<String> notEmpty = s -> !s.isEmpty();
        Predicate<String> hasContent = notNull.and(notEmpty);
        
        // Kombinowanie Function
        Function<String, String> trim = String::trim;
        Function<String, String> upperCase = String::toUpperCase;
        Function<String, String> addPrefix = s -> "PROCESSED: " + s;
        
        Function<String, String> pipeline = trim
            .andThen(upperCase)
            .andThen(addPrefix);
        
        // Testowanie
        List<String> testData = Arrays.asList("  hello  ", "", null, "world");
        
        testData.stream()
            .filter(hasContent)
            .map(pipeline)
            .forEach(System.out::println);
        
        // Kombinowanie Consumer
        Consumer<String> print = System.out::println;
        Consumer<String> log = s -> System.err.println("LOG: " + s);
        Consumer<String> combined = print.andThen(log);
        
        combined.accept("Test message");
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Używaj @FunctionalInterface**: Kompilator sprawdzi poprawność
- **Poznaj wbudowane interfejsy**: Predicate, Function, Consumer, Supplier
- **Kombinuj proste interfejsy**: Zamiast tworzyć skomplikowane
- **Default methods są OK**: Mogą być w functional interface
- **Jedna abstrakcyjna metoda**: To jedyny wymóg

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz functional interface `Converter<T, R>` i użyj go do konwersji różnych typów danych.

**Zadanie 2:** Zaimplementuj system filtrów używając Predicate i kombinowania walidatorów.

**Zadanie 3:** Stwórz prosty kalkulator używając różnych functional interfaces dla operacji matematycznych.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Co to jest functional interface i jakie ma wymagania?
2. Jakie są najważniejsze wbudowane functional interfaces?
3. Czy functional interface może mieć default methods?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza functional interfaces

Functional interfaces to nie tylko składnia - to fundamentalna zmiana w architekturze Javy, wprowadzająca elementy programowania funkcyjnego do tradycyjnie obiektowego języka.

##### Type inference i target typing

```java
public class TypeInferenceExample {
    public static void main(String[] args) {
        // Kompilator dedukuje typ na podstawie kontekstu
        List<String> strings = Arrays.asList("a", "b", "c");
        
        // Target type: Predicate<String>
        strings.stream().filter(s -> s.length() > 1);
        
        // Target type: Function<String, Integer>
        strings.stream().map(s -> s.length());
        
        // Target type: Consumer<String>
        strings.forEach(s -> System.out.println(s));
        
        // Ambiguity resolution
        processString(s -> s.toUpperCase()); // Function<String, String>
        // processString((Function<String, String>) s -> s.toUpperCase()); // Explicit cast if needed
    }
    
    static void processString(Function<String, String> processor) {
        System.out.println("Processing with Function");
    }
    
    static void processString(UnaryOperator<String> processor) {
        System.out.println("Processing with UnaryOperator");
    }
}
```

##### Zaawansowane wzorce z functional interfaces

**1. Monad-like patterns:**

```java
public class MonadPatterns {
    // Optional-like monad
    public static class Result<T> {
        private final T value;
        private final Exception error;
        
        private Result(T value, Exception error) {
            this.value = value;
            this.error = error;
        }
        
        public static <T> Result<T> success(T value) {
            return new Result<>(value, null);
        }
        
        public static <T> Result<T> failure(Exception error) {
            return new Result<>(null, error);
        }
        
        public <R> Result<R> map(Function<T, R> mapper) {
            if (error != null) {
                return Result.failure(error);
            }
            try {
                return Result.success(mapper.apply(value));
            } catch (Exception e) {
                return Result.failure(e);
            }
        }
        
        public <R> Result<R> flatMap(Function<T, Result<R>> mapper) {
            if (error != null) {
                return Result.failure(error);
            }
            try {
                return mapper.apply(value);
            } catch (Exception e) {
                return Result.failure(e);
            }
        }
        
        public T orElse(T defaultValue) {
            return error != null ? defaultValue : value;
        }
        
        public void ifSuccess(Consumer<T> consumer) {
            if (error == null) {
                consumer.accept(value);
            }
        }
        
        public void ifFailure(Consumer<Exception> consumer) {
            if (error != null) {
                consumer.accept(error);
            }
        }
    }
    
    // Usage example
    public static void main(String[] args) {
        Result<String> result = parseAndProcess("123")
            .map(Integer::parseInt)
            .map(i -> i * 2)
            .map(Object::toString)
            .map(s -> "Result: " + s);
        
        result.ifSuccess(System.out::println);
        result.ifFailure(e -> System.err.println("Error: " + e.getMessage()));
    }
    
    private static Result<String> parseAndProcess(String input) {
        if (input == null || input.isEmpty()) {
            return Result.failure(new IllegalArgumentException("Input cannot be null or empty"));
        }
        return Result.success(input);
    }
}
```

**2. Functional composition patterns:**

```java
public class FunctionalComposition {
    // Composable validation
    public static class Validation<T> {
        private final List<Function<T, Optional<String>>> validators = new ArrayList<>();
        
        public Validation<T> addRule(Function<T, Optional<String>> validator) {
            validators.add(validator);
            return this;
        }
        
        public Validation<T> addRule(Predicate<T> predicate, String errorMessage) {
            return addRule(value -> predicate.test(value) ? Optional.empty() : Optional.of(errorMessage));
        }
        
        public List<String> validate(T value) {
            return validators.stream()
                .map(validator -> validator.apply(value))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
        }
        
        public boolean isValid(T value) {
            return validate(value).isEmpty();
        }
    }
    
    // Pipeline pattern
    public static class Pipeline<T> {
        private final List<Function<T, T>> transformations = new ArrayList<>();
        
        public Pipeline<T> add(Function<T, T> transformation) {
            transformations.add(transformation);
            return this;
        }
        
        public Pipeline<T> addIf(Predicate<T> condition, Function<T, T> transformation) {
            return add(value -> condition.test(value) ? transformation.apply(value) : value);
        }
        
        public T execute(T input) {
            return transformations.stream()
                .reduce(Function.identity(), Function::andThen)
                .apply(input);
        }
        
        public List<T> execute(List<T> inputs) {
            return inputs.stream()
                .map(this::execute)
                .collect(Collectors.toList());
        }
    }
    
    public static void main(String[] args) {
        // Validation example
        Validation<String> emailValidation = new Validation<String>()
            .addRule(Objects::nonNull, "Email cannot be null")
            .addRule(s -> !s.trim().isEmpty(), "Email cannot be empty")
            .addRule(s -> s.contains("@"), "Email must contain @")
            .addRule(s -> s.contains("."), "Email must contain .")
            .addRule(s -> s.length() <= 100, "Email too long");
        
        String[] emails = {"test@example.com", "", "invalid", null, "very.long.email.address.that.exceeds.the.maximum.length.limit@example.com"};
        
        for (String email : emails) {
            List<String> errors = emailValidation.validate(email);
            System.out.println("Email: " + email + " - " + 
                (errors.isEmpty() ? "Valid" : "Errors: " + errors));
        }
        
        // Pipeline example
        Pipeline<String> textProcessor = new Pipeline<String>()
            .add(String::trim)
            .add(String::toLowerCase)
            .addIf(s -> s.length() > 10, s -> s.substring(0, 10))
            .add(s -> s.replace(" ", "_"));
        
        List<String> texts = Arrays.asList("  Hello World  ", "JAVA PROGRAMMING", "short");
        List<String> processed = textProcessor.execute(texts);
        
        System.out.println("Original: " + texts);
        System.out.println("Processed: " + processed);
    }
}
```

**3. Event-driven architecture z functional interfaces:**

```java
public class EventDrivenArchitecture {
    // Event interface
    public interface Event {
        String getType();
        long getTimestamp();
        Map<String, Object> getData();
    }
    
    // Generic event implementation
    public static class GenericEvent implements Event {
        private final String type;
        private final long timestamp;
        private final Map<String, Object> data;
        
        public GenericEvent(String type, Map<String, Object> data) {
            this.type = type;
            this.timestamp = System.currentTimeMillis();
            this.data = new HashMap<>(data);
        }
        
        @Override
        public String getType() { return type; }
        
        @Override
        public long getTimestamp() { return timestamp; }
        
        @Override
        public Map<String, Object> getData() { return Collections.unmodifiableMap(data); }
    }
    
    // Event bus with functional interfaces
    public static class EventBus {
        private final Map<String, List<Consumer<Event>>> listeners = new ConcurrentHashMap<>();
        private final List<Function<Event, Event>> middlewares = new ArrayList<>();
        private final ExecutorService executor = Executors.newCachedThreadPool();
        
        // Subscribe to events
        public EventBus subscribe(String eventType, Consumer<Event> listener) {
            listeners.computeIfAbsent(eventType, k -> new ArrayList<>()).add(listener);
            return this;
        }
        
        // Subscribe with filter
        public EventBus subscribe(String eventType, Predicate<Event> filter, Consumer<Event> listener) {
            return subscribe(eventType, event -> {
                if (filter.test(event)) {
                    listener.accept(event);
                }
            });
        }
        
        // Add middleware
        public EventBus addMiddleware(Function<Event, Event> middleware) {
            middlewares.add(middleware);
            return this;
        }
        
        // Publish event synchronously
        public void publish(Event event) {
            Event processedEvent = applyMiddlewares(event);
            List<Consumer<Event>> eventListeners = listeners.get(processedEvent.getType());
            
            if (eventListeners != null) {
                eventListeners.forEach(listener -> {
                    try {
                        listener.accept(processedEvent);
                    } catch (Exception e) {
                        System.err.println("Error in event listener: " + e.getMessage());
                    }
                });
            }
        }
        
        // Publish event asynchronously
        public CompletableFuture<Void> publishAsync(Event event) {
            return CompletableFuture.runAsync(() -> publish(event), executor);
        }
        
        private Event applyMiddlewares(Event event) {
            return middlewares.stream()
                .reduce(Function.identity(), Function::andThen)
                .apply(event);
        }
        
        public void shutdown() {
            executor.shutdown();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        EventBus eventBus = new EventBus();
        
        // Add logging middleware
        eventBus.addMiddleware(event -> {
            System.out.println("Middleware: Processing event " + event.getType());
            return event;
        });
        
        // Add enrichment middleware
        eventBus.addMiddleware(event -> {
            Map<String, Object> enrichedData = new HashMap<>(event.getData());
            enrichedData.put("processed_at", System.currentTimeMillis());
            return new GenericEvent(event.getType(), enrichedData);
        });
        
        // Subscribe to user events
        eventBus.subscribe("user.created", event -> 
            System.out.println("Sending welcome email to: " + event.getData().get("email")));
        
        eventBus.subscribe("user.created", event -> 
            System.out.println("Creating user profile for: " + event.getData().get("userId")));
        
        // Subscribe to order events with filter
        eventBus.subscribe("order.placed", 
            event -> (Double) event.getData().get("amount") > 1000,
            event -> System.out.println("High-value order alert: " + event.getData().get("amount")));
        
        // Subscribe to all events
        eventBus.subscribe("*", event -> 
            System.out.println("Audit log: " + event.getType() + " at " + event.getTimestamp()));
        
        // Publish events
        eventBus.publish(new GenericEvent("user.created", Map.of(
            "userId", "123",
            "email", "user@example.com"
        )));
        
        eventBus.publishAsync(new GenericEvent("order.placed", Map.of(
            "orderId", "456",
            "amount", 1500.0
        ))).join();
        
        Thread.sleep(100); // Wait for async processing
        eventBus.shutdown();
    }
}
```

##### Performance i memory considerations

```java
public class PerformanceConsiderations {
    private static final int ITERATIONS = 1_000_000;
    
    // Functional interface vs method call performance
    @FunctionalInterface
    interface IntOperation {
        int apply(int x);
    }
    
    public static void main(String[] args) {
        // Test 1: Lambda vs method reference vs direct call
        measurePerformance("Direct method call", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += square(i);
            }
            return sum;
        });
        
        IntOperation squareLambda = x -> x * x;
        measurePerformance("Lambda", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += squareLambda.apply(i);
            }
            return sum;
        });
        
        IntOperation squareMethodRef = PerformanceConsiderations::square;
        measurePerformance("Method reference", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += squareMethodRef.apply(i);
            }
            return sum;
        });
        
        // Test 2: Capturing vs non-capturing lambdas
        int multiplier = 2;
        IntOperation capturingLambda = x -> x * multiplier; // Captures 'multiplier'
        IntOperation nonCapturingLambda = x -> x * 2;       // No capture
        
        measurePerformance("Capturing lambda", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += capturingLambda.apply(i);
            }
            return sum;
        });
        
        measurePerformance("Non-capturing lambda", () -> {
            int sum = 0;
            for (int i = 0; i < ITERATIONS; i++) {
                sum += nonCapturingLambda.apply(i);
            }
            return sum;
        });
        
        // Test 3: Memory allocation
        System.out.println("\nMemory allocation test:");
        testMemoryAllocation();
    }
    
    private static int square(int x) {
        return x * x;
    }
    
    private static void measurePerformance(String name, Supplier<Integer> operation) {
        // Warm-up
        for (int i = 0; i < 10; i++) {
            operation.get();
        }
        
        long start = System.nanoTime();
        int result = operation.get();
        long end = System.nanoTime();
        
        System.out.printf("%-20s: %6.2f ms (result: %d)%n", 
            name, (end - start) / 1_000_000.0, result);
    }
    
    private static void testMemoryAllocation() {
        Runtime runtime = Runtime.getRuntime();
        
        // Test lambda creation in loop
        runtime.gc();
        long memBefore = runtime.totalMemory() - runtime.freeMemory();
        
        List<Function<Integer, Integer>> lambdas = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            final int multiplier = i;
            lambdas.add(x -> x * multiplier); // Each creates new lambda instance
        }
        
        long memAfter = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used by 10k capturing lambdas: " + 
            (memAfter - memBefore) / 1024 + " KB");
        
        // Test non-capturing lambda reuse
        runtime.gc();
        memBefore = runtime.totalMemory() - runtime.freeMemory();
        
        List<Function<Integer, Integer>> nonCapturingLambdas = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            nonCapturingLambdas.add(x -> x * 2); // Same lambda instance reused
        }
        
        memAfter = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used by 10k non-capturing lambdas: " + 
            (memAfter - memBefore) / 1024 + " KB");
    }
}
```

##### Zaawansowane functional interfaces

```java
public class AdvancedFunctionalInterfaces {
    // Functional interface z multiple type parameters
    @FunctionalInterface
    interface QuadFunction<T, U, V, W, R> {
        R apply(T t, U u, V v, W w);
    }
    
    // Functional interface z exception handling
    @FunctionalInterface
    interface CheckedFunction<T, R> {
        R apply(T t) throws Exception;
        
        // Default method dla error handling
        default Function<T, Optional<R>> safe() {
            return t -> {
                try {
                    return Optional.of(apply(t));
                } catch (Exception e) {
                    return Optional.empty();
                }
            };
        }
        
        // Default method dla unchecked wrapper
        default Function<T, R> unchecked() {
            return t -> {
                try {
                    return apply(t);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            };
        }
    }
    
    // Functional interface z fluent API
    @FunctionalInterface
    interface FluentProcessor<T> {
        T process(T input);
        
        default FluentProcessor<T> andThen(FluentProcessor<T> after) {
            return input -> after.process(this.process(input));
        }
        
        default FluentProcessor<T> compose(FluentProcessor<T> before) {
            return input -> this.process(before.process(input));
        }
        
        default FluentProcessor<T> when(Predicate<T> condition) {
            return input -> condition.test(input) ? this.process(input) : input;
        }
    }
    
    // Memoized function interface
    @FunctionalInterface
    interface MemoizedFunction<T, R> extends Function<T, R> {
        static <T, R> MemoizedFunction<T, R> of(Function<T, R> function) {
            Map<T, R> cache = new ConcurrentHashMap<>();
            return input -> cache.computeIfAbsent(input, function);
        }
        
        default void clearCache() {
            // Implementation would need access to cache
        }
    }
    
    public static void main(String[] args) {
        // QuadFunction example
        QuadFunction<String, String, String, String, String> fullAddress = 
            (street, city, state, zip) -> street + ", " + city + ", " + state + " " + zip;
        
        String address = fullAddress.apply("123 Main St", "Anytown", "CA", "12345");
        System.out.println("Address: " + address);
        
        // CheckedFunction example
        CheckedFunction<String, Integer> parseInt = Integer::parseInt;
        
        Function<String, Optional<Integer>> safeParseInt = parseInt.safe();
        Function<String, Integer> uncheckedParseInt = parseInt.unchecked();
        
        System.out.println("Safe parse '123': " + safeParseInt.apply("123"));
        System.out.println("Safe parse 'abc': " + safeParseInt.apply("abc"));
        
        // FluentProcessor example
        FluentProcessor<String> trimmer = String::trim;
        FluentProcessor<String> upperCase = String::toUpperCase;
        FluentProcessor<String> addPrefix = s -> "PROCESSED: " + s;
        
        FluentProcessor<String> pipeline = trimmer
            .andThen(upperCase)
            .when(s -> s.length() > 5)
            .andThen(addPrefix);
        
        System.out.println("Pipeline result: " + pipeline.process("  hello world  "));
        
        // MemoizedFunction example
        MemoizedFunction<Integer, Integer> fibonacci = MemoizedFunction.of(n -> {
            System.out.println("Computing fibonacci(" + n + ")");
            if (n <= 1) return n;
            return fibonacci.apply(n - 1) + fibonacci.apply(n - 2);
        });
        
        System.out.println("Fibonacci(10): " + fibonacci.apply(10));
        System.out.println("Fibonacci(10) again: " + fibonacci.apply(10)); // Cached
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj własny reactive streams framework używając functional interfaces.

**Zadanie Zaawansowane 2:** Stwórz type-safe query builder używając functional interfaces i method chaining.

**Zadanie Zaawansowane 3:** Zaprojektuj middleware system dla web applications używając functional composition.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak functional interfaces wpływają na performance aplikacji?
2. Jaka jest różnica między capturing a non-capturing lambdami?
3. Jak zaimplementować własny functional interface z zaawansowanymi operacjami?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
@FunctionalInterface
public interface Converter<T, R> {
    R convert(T input);
}

public class ConverterExample {
    public static void main(String[] args) {
        // String to Integer
        Converter<String, Integer> stringToInt = Integer::parseInt;
        
        // Integer to String
        Converter<Integer, String> intToString = Object::toString;
        
        // String to uppercase
        Converter<String, String> toUpperCase = String::toUpperCase;
        
        // Double to formatted string
        Converter<Double, String> formatDouble = d -> String.format("%.2f", d);
        
        System.out.println(stringToInt.convert("123"));
        System.out.println(intToString.convert(456));
        System.out.println(toUpperCase.convert("hello"));
        System.out.println(formatDouble.convert(3.14159));
    }
}
```

**Zadanie 2:**
```java
public class FilterSystem {
    public static <T> Predicate<T> and(Predicate<T>... predicates) {
        return Arrays.stream(predicates)
            .reduce(Predicate::and)
            .orElse(x -> true);
    }
    
    public static <T> Predicate<T> or(Predicate<T>... predicates) {
        return Arrays.stream(predicates)
            .reduce(Predicate::or)
            .orElse(x -> false);
    }
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> greaterThan5 = n -> n > 5;
        Predicate<Integer> lessThan10 = n -> n < 10;
        
        // Even numbers greater than 5
        List<Integer> filtered1 = numbers.stream()
            .filter(and(isEven, greaterThan5))
            .collect(Collectors.toList());
        
        // Numbers that are even OR greater than 8
        List<Integer> filtered2 = numbers.stream()
            .filter(or(isEven, n -> n > 8))
            .collect(Collectors.toList());
        
        System.out.println("Even and > 5: " + filtered1);
        System.out.println("Even or > 8: " + filtered2);
    }
}
```

**Zadanie 3:**
```java
public class FunctionalCalculator {
    @FunctionalInterface
    interface MathOperation {
        double calculate(double a, double b);
    }
    
    private static final Map<String, MathOperation> operations = Map.of(
        "+", (a, b) -> a + b,
        "-", (a, b) -> a - b,
        "*", (a, b) -> a * b,
        "/", (a, b) -> b != 0 ? a / b : Double.NaN,
        "^", Math::pow,
        "%", (a, b) -> a % b
    );
    
    public static double calculate(double a, double b, String operator) {
        return operations.getOrDefault(operator, (x, y) -> Double.NaN)
                        .calculate(a, b);
    }
    
    public static void main(String[] args) {
        System.out.println("10 + 5 = " + calculate(10, 5, "+"));
        System.out.println("10 - 5 = " + calculate(10, 5, "-"));
        System.out.println("10 * 5 = " + calculate(10, 5, "*"));
        System.out.println("10 / 5 = " + calculate(10, 5, "/"));
        System.out.println("10 ^ 2 = " + calculate(10, 2, "^"));
    }
}
```

**Pytania kontrolne:**
1. Interfejs z dokładnie jedną abstrakcyjną metodą, może mieć default i static methods
2. Predicate<T>, Function<T,R>, Consumer<T>, Supplier<T>, UnaryOperator<T>, BinaryOperator<T>
3. Tak, default i static methods nie liczą się do limitu jednej abstrakcyjnej metody

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Functional interfaces są optymalizowane przez JVM, non-capturing lambdy są reused, capturing lambdy mogą mieć overhead
2. Capturing lambdy przechwytują zmienne z otoczenia i tworzą nowe instancje, non-capturing są reused
3. Używając default methods, static methods, i kompozycji z innymi functional interfaces

---

### 📚 Co dalej?

*Fantastycznie! Teraz rozumiesz teoretyczne podstawy lambd i functional interfaces. To fundament nowoczesnego programowania w Javie - od prostych operacji po zaawansowane wzorce architektoniczne. W następnym rozdziale porozmawiamy o klasach wewnętrznych i anonimowych - starszych mechanizmach, które warto znać dla pełnego obrazu!*

---

*💡 Pamiętaj: Functional interfaces to most między światem obiektowym a funkcyjnym. Używaj ich świadomie - nie każdy problem wymaga functional approach!*


## 19. Klasy wewnętrzne i anonimowe (Inner classes)

*Cześć! Dziś porozmawiamy o klasach wewnętrznych - mechanizmie, który istniał w Javie długo przed lambdami i nadal ma swoje miejsce. To jak matrioszka - klasy w klasach, każda ze swoim przeznaczeniem. Choć lambdy zastąpiły wiele zastosowań klas anonimowych, warto znać te mechanizmy, bo spotkasz je w starszym kodzie i czasami są nadal najlepszym rozwiązaniem!*

---

### 🌱 Część dla Juniorek

#### Co to są klasy wewnętrzne?

Klasa wewnętrzna to klasa zdefiniowana wewnątrz innej klasy. Java ma cztery typy klas wewnętrznych:

1. **Non-static nested classes (inner classes)** - mają dostęp do wszystkich członków klasy zewnętrznej
2. **Static nested classes** - nie mają dostępu do non-static członków klasy zewnętrznej  
3. **Local classes** - zdefiniowane wewnątrz metody
4. **Anonymous classes** - klasy bez nazwy, tworzone "w locie"

```java
public class OuterClass {
    private String outerField = "Outer field";
    private static String staticOuterField = "Static outer field";
    
    // 1. Non-static inner class
    public class InnerClass {
        public void display() {
            System.out.println("Dostęp do: " + outerField); // OK
            System.out.println("Dostęp do: " + staticOuterField); // OK
        }
    }
    
    // 2. Static nested class
    public static class StaticNestedClass {
        public void display() {
            // System.out.println(outerField); // BŁĄD! Brak dostępu
            System.out.println("Dostęp do: " + staticOuterField); // OK
        }
    }
    
    public void methodWithLocalClass() {
        final String localVar = "Local variable";
        
        // 3. Local class
        class LocalClass {
            public void display() {
                System.out.println("Dostęp do: " + outerField); // OK
                System.out.println("Dostęp do: " + localVar); // OK (effectively final)
            }
        }
        
        LocalClass local = new LocalClass();
        local.display();
    }
    
    public void methodWithAnonymousClass() {
        // 4. Anonymous class
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous class: " + outerField);
            }
        };
        
        runnable.run();
    }
}
```

#### Praktyczne przykłady

**1. Iterator pattern z inner class:**

```java
public class MyList<T> {
    private Object[] elements = new Object[10];
    private int size = 0;
    
    public void add(T element) {
        if (size < elements.length) {
            elements[size++] = element;
        }
    }
    
    @SuppressWarnings("unchecked")
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return (T) elements[index];
    }
    
    public int size() {
        return size;
    }
    
    // Inner class implementing Iterator
    public class MyIterator {
        private int currentIndex = 0;
        
        public boolean hasNext() {
            return currentIndex < size;
        }
        
        @SuppressWarnings("unchecked")
        public T next() {
            if (!hasNext()) {
                throw new RuntimeException("No more elements");
            }
            return (T) elements[currentIndex++];
        }
        
        // Ma dostęp do prywatnych pól klasy zewnętrznej
        public void remove() {
            if (currentIndex <= 0) {
                throw new RuntimeException("Nothing to remove");
            }
            
            // Przesunięcie elementów
            for (int i = currentIndex - 1; i < size - 1; i++) {
                elements[i] = elements[i + 1];
            }
            size--;
            currentIndex--;
        }
    }
    
    public MyIterator iterator() {
        return new MyIterator();
    }
    
    public static void main(String[] args) {
        MyList<String> list = new MyList<>();
        list.add("Anna");
        list.add("Beata");
        list.add("Ewa");
        
        MyList<String>.MyIterator iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

**2. Event handling z anonymous classes:**

```java
public class EventHandlingExample {
    public interface ClickListener {
        void onClick();
    }
    
    public interface KeyListener {
        void onKeyPressed(String key);
    }
    
    public static class Button {
        private String text;
        private ClickListener clickListener;
        
        public Button(String text) {
            this.text = text;
        }
        
        public void setClickListener(ClickListener listener) {
            this.clickListener = listener;
        }
        
        public void click() {
            System.out.println("Button '" + text + "' clicked!");
            if (clickListener != null) {
                clickListener.onClick();
            }
        }
    }
    
    public static void main(String[] args) {
        Button saveButton = new Button("Save");
        Button cancelButton = new Button("Cancel");
        
        // Anonymous class dla save button
        saveButton.setClickListener(new ClickListener() {
            @Override
            public void onClick() {
                System.out.println("Saving data...");
                // Logika zapisywania
            }
        });
        
        // Anonymous class dla cancel button
        cancelButton.setClickListener(new ClickListener() {
            @Override
            public void onClick() {
                System.out.println("Operation cancelled");
                // Logika anulowania
            }
        });
        
        // Testowanie
        saveButton.click();
        cancelButton.click();
        
        // Porównanie z lambdą (krócej!)
        Button deleteButton = new Button("Delete");
        deleteButton.setClickListener(() -> System.out.println("Deleting..."));
        deleteButton.click();
    }
}
```

**3. Builder pattern z static nested class:**

```java
public class User {
    private final String firstName;
    private final String lastName;
    private final String email;
    private final int age;
    private final String city;
    
    // Prywatny konstruktor
    private User(Builder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.email = builder.email;
        this.age = builder.age;
        this.city = builder.city;
    }
    
    // Static nested class Builder
    public static class Builder {
        // Wymagane pola
        private final String firstName;
        private final String lastName;
        
        // Opcjonalne pola z domyślnymi wartościami
        private String email = "";
        private int age = 0;
        private String city = "";
        
        public Builder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }
        
        public Builder email(String email) {
            this.email = email;
            return this;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder city(String city) {
            this.city = city;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
    
    // Gettery
    public String getFirstName() { return firstName; }
    public String getLastName() { return lastName; }
    public String getEmail() { return email; }
    public int getAge() { return age; }
    public String getCity() { return city; }
    
    @Override
    public String toString() {
        return "User{" +
                "firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", age=" + age +
                ", city='" + city + '\'' +
                '}';
    }
    
    public static void main(String[] args) {
        // Użycie Builder pattern
        User user1 = new User.Builder("Anna", "Kowalska")
                .email("anna@example.com")
                .age(25)
                .city("Warszawa")
                .build();
        
        User user2 = new User.Builder("Beata", "Nowak")
                .email("beata@example.com")
                .build(); // Tylko wymagane pola + email
        
        System.out.println(user1);
        System.out.println(user2);
    }
}
```

**4. Local classes dla specjalizowanych operacji:**

```java
public class DataProcessor {
    public void processData(List<String> data, String operation) {
        switch (operation.toLowerCase()) {
            case "sort":
                // Local class dla sortowania
                class SortProcessor {
                    public List<String> process() {
                        return data.stream()
                                .sorted()
                                .collect(Collectors.toList());
                    }
                }
                
                SortProcessor sorter = new SortProcessor();
                List<String> sorted = sorter.process();
                System.out.println("Sorted: " + sorted);
                break;
                
            case "filter":
                // Local class dla filtrowania
                class FilterProcessor {
                    private final int minLength = 3; // Może mieć własne pola
                    
                    public List<String> process() {
                        return data.stream()
                                .filter(s -> s.length() >= minLength)
                                .collect(Collectors.toList());
                    }
                }
                
                FilterProcessor filter = new FilterProcessor();
                List<String> filtered = filter.process();
                System.out.println("Filtered: " + filtered);
                break;
                
            case "transform":
                final String prefix = "PROCESSED_"; // Effectively final dla local class
                
                // Local class z dostępem do local variables
                class TransformProcessor {
                    public List<String> process() {
                        return data.stream()
                                .map(s -> prefix + s.toUpperCase())
                                .collect(Collectors.toList());
                    }
                }
                
                TransformProcessor transformer = new TransformProcessor();
                List<String> transformed = transformer.process();
                System.out.println("Transformed: " + transformed);
                break;
        }
    }
    
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor();
        List<String> data = Arrays.asList("java", "python", "c++", "go", "rust");
        
        processor.processData(data, "sort");
        processor.processData(data, "filter");
        processor.processData(data, "transform");
    }
}
```

#### Kiedy używać których klas?

**Non-static inner classes:**
- Gdy inner class potrzebuje dostępu do instance members outer class
- Iterator patterns, event handlers z dostępem do stanu

**Static nested classes:**
- Builder pattern, helper classes
- Gdy nie potrzebujesz dostępu do instance members outer class

**Local classes:**
- Gdy potrzebujesz klasy tylko w jednej metodzie
- Specjalizowane operacje z dostępem do local variables

**Anonymous classes:**
- Implementacja prostych interfejsów "w locie"
- Event handling (choć lambdy są teraz lepsze)

#### 💡 Wskazówki dla Juniorek

- **Inner classes mają dostęp do prywatnych członków** outer class
- **Static nested classes** nie mogą dostać się do non-static members
- **Local classes** mogą używać effectively final local variables
- **Anonymous classes** są dobre dla prostych implementacji
- **Lambdy zastąpiły większość anonymous classes** dla functional interfaces

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz klasę `Calculator` z inner class `Operation` implementującą różne operacje matematyczne.

**Zadanie 2:** Zaimplementuj prostą strukturę danych `Stack` z własnym iteratorem używając inner class.

**Zadanie 3:** Stwórz system obsługi zdarzeń używając anonymous classes i porównaj z lambdami.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między inner class a static nested class?
2. Kiedy używać local classes?
3. Czy anonymous class może implementować wiele interfejsów?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza klas wewnętrznych

Klasy wewnętrzne to nie tylko składnia - to mechanizm enkapsulacji i organizacji kodu, który ma swoje miejsce nawet w erze lambd i nowoczesnej Javy.

##### Memory model i performance implications

```java
public class MemoryAnalysis {
    private String outerField = "Outer";
    
    // Non-static inner class - trzyma referencję do outer instance
    public class InnerClass {
        private String innerField = "Inner";
        
        public void printFields() {
            System.out.println(outerField + " " + innerField);
            // Kompilator generuje: MemoryAnalysis.this.outerField
        }
    }
    
    // Static nested class - nie trzyma referencji do outer instance
    public static class StaticNestedClass {
        private String nestedField = "Nested";
        
        public void printField() {
            System.out.println(nestedField);
            // Brak dostępu do outerField bez explicit reference
        }
    }
    
    public void demonstrateMemoryUsage() {
        // Inner class instance zawsze trzyma referencję do outer instance
        InnerClass inner = new InnerClass();
        
        // To może prowadzić do memory leaks!
        List<InnerClass> innerInstances = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            innerInstances.add(new InnerClass());
            // Każda instancja trzyma referencję do 'this' (MemoryAnalysis)
        }
        
        // Static nested class nie ma tego problemu
        List<StaticNestedClass> nestedInstances = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            nestedInstances.add(new StaticNestedClass());
            // Brak referencji do outer instance
        }
    }
    
    // Demonstracja synthetic methods
    private void privateMethod() {
        System.out.println("Private method called");
    }
    
    public class AccessingInner {
        public void callPrivateMethod() {
            privateMethod(); // Kompilator generuje synthetic accessor method
        }
    }
}
```

##### Zaawansowane wzorce z inner classes

**1. State pattern z inner classes:**

```java
public class StateMachine {
    private State currentState;
    private String data = "";
    
    public StateMachine() {
        currentState = new IdleState();
    }
    
    public void process(String input) {
        currentState.handle(input);
    }
    
    public void setState(State state) {
        this.currentState = state;
    }
    
    public String getData() {
        return data;
    }
    
    public void setData(String data) {
        this.data = data;
    }
    
    // Abstract state class
    public abstract class State {
        public abstract void handle(String input);
        
        protected void changeState(State newState) {
            System.out.println("Changing state from " + this.getClass().getSimpleName() + 
                             " to " + newState.getClass().getSimpleName());
            setState(newState);
        }
    }
    
    // Concrete states as inner classes
    public class IdleState extends State {
        @Override
        public void handle(String input) {
            if ("start".equals(input)) {
                setData("Processing started");
                changeState(new ProcessingState());
            } else {
                System.out.println("Idle: Ignoring input '" + input + "'");
            }
        }
    }
    
    public class ProcessingState extends State {
        @Override
        public void handle(String input) {
            if ("complete".equals(input)) {
                setData(getData() + " - Completed");
                changeState(new CompletedState());
            } else if ("error".equals(input)) {
                setData(getData() + " - Error occurred");
                changeState(new ErrorState());
            } else {
                setData(getData() + " - Processing: " + input);
            }
        }
    }
    
    public class CompletedState extends State {
        @Override
        public void handle(String input) {
            if ("reset".equals(input)) {
                setData("");
                changeState(new IdleState());
            } else {
                System.out.println("Completed: Cannot process '" + input + "'");
            }
        }
    }
    
    public class ErrorState extends State {
        @Override
        public void handle(String input) {
            if ("reset".equals(input)) {
                setData("");
                changeState(new IdleState());
            } else {
                System.out.println("Error: Cannot process '" + input + "' until reset");
            }
        }
    }
    
    public static void main(String[] args) {
        StateMachine machine = new StateMachine();
        
        machine.process("start");
        System.out.println("Data: " + machine.getData());
        
        machine.process("data1");
        System.out.println("Data: " + machine.getData());
        
        machine.process("complete");
        System.out.println("Data: " + machine.getData());
        
        machine.process("reset");
        System.out.println("Data: " + machine.getData());
    }
}
```

**2. Complex Builder pattern z validation:**

```java
public class ComplexConfiguration {
    private final String host;
    private final int port;
    private final String username;
    private final String password;
    private final boolean sslEnabled;
    private final int timeout;
    private final int retryCount;
    private final Map<String, String> properties;
    
    private ComplexConfiguration(Builder builder) {
        this.host = builder.host;
        this.port = builder.port;
        this.username = builder.username;
        this.password = builder.password;
        this.sslEnabled = builder.sslEnabled;
        this.timeout = builder.timeout;
        this.retryCount = builder.retryCount;
        this.properties = Collections.unmodifiableMap(new HashMap<>(builder.properties));
    }
    
    public static class Builder {
        // Required fields
        private final String host;
        private final int port;
        
        // Optional fields with defaults
        private String username = "";
        private String password = "";
        private boolean sslEnabled = false;
        private int timeout = 5000;
        private int retryCount = 3;
        private Map<String, String> properties = new HashMap<>();
        
        public Builder(String host, int port) {
            this.host = Objects.requireNonNull(host, "Host cannot be null");
            if (port <= 0 || port > 65535) {
                throw new IllegalArgumentException("Port must be between 1 and 65535");
            }
            this.port = port;
        }
        
        public Builder username(String username) {
            this.username = Objects.requireNonNull(username, "Username cannot be null");
            return this;
        }
        
        public Builder password(String password) {
            this.password = Objects.requireNonNull(password, "Password cannot be null");
            return this;
        }
        
        public Builder ssl(boolean enabled) {
            this.sslEnabled = enabled;
            return this;
        }
        
        public Builder timeout(int timeout) {
            if (timeout <= 0) {
                throw new IllegalArgumentException("Timeout must be positive");
            }
            this.timeout = timeout;
            return this;
        }
        
        public Builder retryCount(int retryCount) {
            if (retryCount < 0) {
                throw new IllegalArgumentException("Retry count cannot be negative");
            }
            this.retryCount = retryCount;
            return this;
        }
        
        public Builder property(String key, String value) {
            this.properties.put(
                Objects.requireNonNull(key, "Property key cannot be null"),
                Objects.requireNonNull(value, "Property value cannot be null")
            );
            return this;
        }
        
        public Builder properties(Map<String, String> properties) {
            this.properties.putAll(Objects.requireNonNull(properties, "Properties cannot be null"));
            return this;
        }
        
        // Validation inner class
        private class Validator {
            public void validate() {
                if (sslEnabled && port == 80) {
                    throw new IllegalStateException("SSL cannot be enabled on port 80");
                }
                
                if (!username.isEmpty() && password.isEmpty()) {
                    throw new IllegalStateException("Password required when username is provided");
                }
                
                if (timeout > 60000) {
                    System.out.println("Warning: Timeout > 60s may cause issues");
                }
                
                if (retryCount > 10) {
                    System.out.println("Warning: High retry count may impact performance");
                }
            }
        }
        
        public ComplexConfiguration build() {
            new Validator().validate();
            return new ComplexConfiguration(this);
        }
    }
    
    // Getters
    public String getHost() { return host; }
    public int getPort() { return port; }
    public String getUsername() { return username; }
    public boolean isSslEnabled() { return sslEnabled; }
    public int getTimeout() { return timeout; }
    public int getRetryCount() { return retryCount; }
    public Map<String, String> getProperties() { return properties; }
    
    @Override
    public String toString() {
        return "Configuration{" +
                "host='" + host + '\'' +
                ", port=" + port +
                ", username='" + username + '\'' +
                ", ssl=" + sslEnabled +
                ", timeout=" + timeout +
                ", retryCount=" + retryCount +
                ", properties=" + properties +
                '}';
    }
    
    public static void main(String[] args) {
        try {
            ComplexConfiguration config = new ComplexConfiguration.Builder("localhost", 8080)
                    .username("admin")
                    .password("secret")
                    .ssl(true)
                    .timeout(10000)
                    .retryCount(5)
                    .property("charset", "UTF-8")
                    .property("compression", "gzip")
                    .build();
            
            System.out.println(config);
        } catch (Exception e) {
            System.err.println("Configuration error: " + e.getMessage());
        }
    }
}
```

**3. Advanced Iterator pattern z multiple traversal strategies:**

```java
public class AdvancedTree<T> {
    private Node<T> root;
    
    private static class Node<T> {
        T data;
        Node<T> left, right;
        
        Node(T data) {
            this.data = data;
        }
    }
    
    public void insert(T data) {
        root = insertRec(root, data);
    }
    
    @SuppressWarnings("unchecked")
    private Node<T> insertRec(Node<T> root, T data) {
        if (root == null) {
            return new Node<>(data);
        }
        
        if (((Comparable<T>) data).compareTo(root.data) < 0) {
            root.left = insertRec(root.left, data);
        } else {
            root.right = insertRec(root.right, data);
        }
        
        return root;
    }
    
    // Abstract iterator base class
    public abstract class TreeIterator {
        protected Stack<Node<T>> stack = new Stack<>();
        
        public abstract boolean hasNext();
        public abstract T next();
        
        protected void pushLeft(Node<T> node) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
        }
    }
    
    // In-order iterator (left, root, right)
    public class InOrderIterator extends TreeIterator {
        public InOrderIterator() {
            pushLeft(root);
        }
        
        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            Node<T> node = stack.pop();
            T result = node.data;
            
            if (node.right != null) {
                pushLeft(node.right);
            }
            
            return result;
        }
    }
    
    // Pre-order iterator (root, left, right)
    public class PreOrderIterator extends TreeIterator {
        public PreOrderIterator() {
            if (root != null) {
                stack.push(root);
            }
        }
        
        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            Node<T> node = stack.pop();
            T result = node.data;
            
            // Push right first, then left (stack is LIFO)
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
            
            return result;
        }
    }
    
    // Level-order iterator (breadth-first)
    public class LevelOrderIterator {
        private Queue<Node<T>> queue = new LinkedList<>();
        
        public LevelOrderIterator() {
            if (root != null) {
                queue.offer(root);
            }
        }
        
        public boolean hasNext() {
            return !queue.isEmpty();
        }
        
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            Node<T> node = queue.poll();
            T result = node.data;
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
            
            return result;
        }
    }
    
    // Factory methods for iterators
    public InOrderIterator inOrderIterator() {
        return new InOrderIterator();
    }
    
    public PreOrderIterator preOrderIterator() {
        return new PreOrderIterator();
    }
    
    public LevelOrderIterator levelOrderIterator() {
        return new LevelOrderIterator();
    }
    
    public static void main(String[] args) {
        AdvancedTree<Integer> tree = new AdvancedTree<>();
        int[] values = {5, 3, 7, 2, 4, 6, 8};
        
        for (int value : values) {
            tree.insert(value);
        }
        
        System.out.print("In-order: ");
        AdvancedTree<Integer>.InOrderIterator inOrder = tree.inOrderIterator();
        while (inOrder.hasNext()) {
            System.out.print(inOrder.next() + " ");
        }
        System.out.println();
        
        System.out.print("Pre-order: ");
        AdvancedTree<Integer>.PreOrderIterator preOrder = tree.preOrderIterator();
        while (preOrder.hasNext()) {
            System.out.print(preOrder.next() + " ");
        }
        System.out.println();
        
        System.out.print("Level-order: ");
        AdvancedTree<Integer>.LevelOrderIterator levelOrder = tree.levelOrderIterator();
        while (levelOrder.hasNext()) {
            System.out.print(levelOrder.next() + " ");
        }
        System.out.println();
    }
}
```

##### Anonymous classes vs Lambdas - kiedy co używać?

```java
public class AnonymousVsLambda {
    interface SingleMethod {
        void doSomething();
    }
    
    interface MultipleDefaultMethods {
        void primaryMethod();
        
        default void secondaryMethod() {
            System.out.println("Default implementation");
        }
        
        default void anotherMethod() {
            System.out.println("Another default");
        }
    }
    
    abstract class AbstractClass {
        abstract void abstractMethod();
        
        void concreteMethod() {
            System.out.println("Concrete method");
        }
    }
    
    public static void main(String[] args) {
        // Lambda - idealne dla functional interfaces
        SingleMethod lambda = () -> System.out.println("Lambda implementation");
        
        // Anonymous class - gdy potrzebujesz więcej kontroli
        SingleMethod anonymous = new SingleMethod() {
            private int counter = 0; // Może mieć własne pola
            
            @Override
            public void doSomething() {
                counter++;
                System.out.println("Anonymous implementation, call #" + counter);
            }
        };
        
        // Anonymous class - gdy implementujesz abstract class
        AbstractClass abstractImpl = new AbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Abstract method implementation");
                concreteMethod(); // Może wywoływać metody z klasy bazowej
            }
        };
        
        // Anonymous class - gdy potrzebujesz przesłonić default methods
        MultipleDefaultMethods multiImpl = new MultipleDefaultMethods() {
            @Override
            public void primaryMethod() {
                System.out.println("Primary method");
            }
            
            @Override
            public void secondaryMethod() {
                System.out.println("Overridden secondary method");
            }
        };
        
        // Performance comparison
        measurePerformance("Lambda", () -> {
            for (int i = 0; i < 1_000_000; i++) {
                SingleMethod l = () -> {};
                l.doSomething();
            }
        });
        
        measurePerformance("Anonymous class", () -> {
            for (int i = 0; i < 1_000_000; i++) {
                SingleMethod a = new SingleMethod() {
                    @Override
                    public void doSomething() {}
                };
                a.doSomething();
            }
        });
    }
    
    private static void measurePerformance(String name, Runnable operation) {
        long start = System.nanoTime();
        operation.run();
        long end = System.nanoTime();
        System.out.printf("%s: %.2f ms%n", name, (end - start) / 1_000_000.0);
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj thread-safe cache z inner classes dla różnych strategii eviction.

**Zadanie Zaawansowane 2:** Stwórz parser expression z visitor pattern używając inner classes.

**Zadanie Zaawansowane 3:** Zaprojektuj event sourcing system z inner classes dla różnych typów eventów.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jakie są implikacje memory model dla inner classes?
2. Kiedy anonymous classes są lepsze od lambd?
3. Jak synthetic methods wpływają na performance?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public class Calculator {
    private double result = 0;
    
    public abstract class Operation {
        protected abstract double execute(double a, double b);
        
        public Calculator apply(double a, double b) {
            result = execute(a, b);
            return Calculator.this;
        }
        
        public double getResult() {
            return result;
        }
    }
    
    public Operation add() {
        return new Operation() {
            @Override
            protected double execute(double a, double b) {
                return a + b;
            }
        };
    }
    
    public Operation multiply() {
        return new Operation() {
            @Override
            protected double execute(double a, double b) {
                return a * b;
            }
        };
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        double result = calc.add().apply(5, 3).getResult();
        System.out.println("Result: " + result); // 8.0
    }
}
```

**Pytania kontrolne:**
1. Inner class ma dostęp do wszystkich członków outer class, static nested class tylko do static członków
2. Gdy potrzebujesz klasy tylko w jednej metodzie z dostępem do local variables
3. Nie, anonymous class może implementować tylko jeden interfejs lub rozszerzać jedną klasę

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Inner classes trzymają implicit reference do outer instance, co może prowadzić do memory leaks
2. Gdy potrzebujesz state, implementujesz abstract class, lub przesłaniasz default methods
3. Synthetic methods są generowane przez kompilator dla dostępu do private members, mogą wpływać na performance

---
