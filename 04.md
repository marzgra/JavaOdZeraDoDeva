# IV. Zaawansowane techniki i JVM pod maską

*Witaj w czwartej części naszego przewodnika! Tutaj zanurzymy się głęboko w świat Javy - od mechanizmów JVM i zarządzania pamięcią po zaawansowane techniki wielowątkowości. To jak przejście od prowadzenia samochodu do jego projektowania - zrozumiesz, co dzieje się pod maską i jak wycisnąć z Javy maksimum możliwości.*

---

## 20. JVM i Garbage Collector: co siedzi pod maską

*Cześć! Dziś zagłębimy się w serce Javy - JVM i Garbage Collector. To jak poznanie silnika samochodu, którym jeździsz codziennie. Większość czasu nie musisz o tym myśleć, ale gdy coś pójdzie nie tak, ta wiedza może uratować Ci projekt. Przygotuj się na fascynującą podróż pod maską!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest JVM?

JVM (Java Virtual Machine) to "komputer w komputerze" - wirtualna maszyna, która uruchamia Twój kod Java. To dzięki niej możesz napisać program raz i uruchomić go na Windows, Linux, Mac - wszędzie tam, gdzie jest JVM.

```java
// Twój kod Java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// 1. javac kompiluje do bytecode (.class)
// 2. JVM interpretuje/kompiluje bytecode do kodu maszynowego
// 3. System operacyjny wykonuje kod maszynowy
```

#### Jak działa JVM - uproszczony model

JVM składa się z kilku głównych części:

1. **Class Loader** - ładuje klasy do pamięci
2. **Memory Areas** - różne obszary pamięci (Heap, Stack, Method Area)
3. **Execution Engine** - wykonuje kod (interpreter + JIT compiler)
4. **Garbage Collector** - sprząta nieużywaną pamięć

```java
public class JVMBasics {
    private static String staticField = "Static data"; // Method Area
    private String instanceField = "Instance data";    // Heap
    
    public void demonstrateMemoryAreas() {
        int localVar = 42;              // Stack
        String localString = "Local";   // Stack (referencja) + Heap (obiekt)
        
        // Tworzenie obiektów - idą na Heap
        List<String> list = new ArrayList<>();
        list.add("Element 1");
        list.add("Element 2");
        
        // Wywołanie metody - nowa ramka na Stack
        processData(list);
    }
    
    private void processData(List<String> data) {
        // Nowa ramka na Stack dla tej metody
        for (String item : data) {
            System.out.println(item);
        }
        // Po zakończeniu metody ramka znika ze Stack
    }
    
    public static void main(String[] args) {
        JVMBasics demo = new JVMBasics(); // Obiekt na Heap
        demo.demonstrateMemoryAreas();   // Wywołanie na Stack
    }
}
```

#### Co to jest Garbage Collector?

Garbage Collector (GC) to automatyczny sprzątacz pamięci. W językach jak C++ musisz ręcznie zwalniać pamięć - w Javie GC robi to za Ciebie.

```java
public class GarbageCollectionDemo {
    public static void main(String[] args) {
        // Tworzenie obiektów
        for (int i = 0; i < 1000; i++) {
            String temp = "String " + i;
            List<Integer> tempList = new ArrayList<>();
            tempList.add(i);
            
            // Po zakończeniu iteracji 'temp' i 'tempList' 
            // stają się nieosiągalne i mogą być usunięte przez GC
        }
        
        // Możesz poprosić o GC (ale to tylko sugestia!)
        System.gc();
        
        // Sprawdzenie pamięci
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        
        System.out.println("Total memory: " + totalMemory / 1024 / 1024 + " MB");
        System.out.println("Used memory: " + usedMemory / 1024 / 1024 + " MB");
        System.out.println("Free memory: " + freeMemory / 1024 / 1024 + " MB");
    }
}
```

#### Podstawowe typy Garbage Collectorów

Java ma różne typy GC, każdy z innymi charakterystykami:

**Serial GC** - prosty, jednowątkowy (małe aplikacje)
**Parallel GC** - wielowątkowy (domyślny w starszych wersjach)
**G1 GC** - niskoopoznieniowy (domyślny od Java 9)
**ZGC/Shenandoah** - ultra-niskoopoznieniowe (duże aplikacje)

```java
public class GCTypeDemo {
    public static void main(String[] args) {
        // Sprawdzenie aktualnego GC
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        
        System.out.println("Active Garbage Collectors:");
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            System.out.println("- " + gcBean.getName());
            System.out.println("  Collections: " + gcBean.getCollectionCount());
            System.out.println("  Time: " + gcBean.getCollectionTime() + " ms");
        }
        
        // Informacje o pamięci
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        
        System.out.println("\nHeap Memory:");
        System.out.println("Used: " + heapUsage.getUsed() / 1024 / 1024 + " MB");
        System.out.println("Max: " + heapUsage.getMax() / 1024 / 1024 + " MB");
    }
}
```

#### Praktyczne przykłady problemów z pamięcią

**1. Memory leak przez static collections:**

```java
public class MemoryLeakExample {
    // PROBLEM: Static collection nigdy nie jest czyszczona
    private static List<String> cache = new ArrayList<>();
    
    public void addToCache(String data) {
        cache.add(data); // Dane się gromadzą i nigdy nie są usuwane!
    }
    
    // ROZWIĄZANIE: Ograniczony cache
    private static final int MAX_CACHE_SIZE = 1000;
    private static List<String> limitedCache = new ArrayList<>();
    
    public void addToLimitedCache(String data) {
        if (limitedCache.size() >= MAX_CACHE_SIZE) {
            limitedCache.remove(0); // Usuń najstarszy element
        }
        limitedCache.add(data);
    }
    
    // LEPSZE ROZWIĄZANIE: Użyj LinkedHashMap z LRU
    private static final Map<String, String> lruCache = new LinkedHashMap<String, String>(16, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
            return size() > MAX_CACHE_SIZE;
        }
    };
}
```

**2. Problemy z finalize():**

```java
public class FinalizeProblems {
    // PROBLEM: finalize() spowalnia GC
    @Override
    protected void finalize() throws Throwable {
        System.out.println("Finalizing..."); // Nie rób tego!
        super.finalize();
    }
    
    // ROZWIĄZANIE: Explicit cleanup
    public void cleanup() {
        // Zwolnij zasoby jawnie
        System.out.println("Explicit cleanup");
    }
    
    public static void main(String[] args) {
        FinalizeProblems obj = new FinalizeProblems();
        // Zawsze wywołuj cleanup() jawnie
        obj.cleanup();
        
        // Lub użyj try-with-resources dla AutoCloseable
    }
}
```

**3. Monitoring GC w praktyce:**

```java
public class GCMonitoring {
    public static void main(String[] args) {
        // Symulacja obciążenia pamięci
        List<byte[]> memoryHog = new ArrayList<>();
        
        long startTime = System.currentTimeMillis();
        
        try {
            for (int i = 0; i < 1000; i++) {
                // Alokacja 1MB
                byte[] data = new byte[1024 * 1024];
                memoryHog.add(data);
                
                if (i % 100 == 0) {
                    printMemoryStats();
                }
                
                // Czasami zwolnij część pamięci
                if (i % 200 == 0 && memoryHog.size() > 100) {
                    memoryHog.subList(0, 50).clear();
                }
            }
        } catch (OutOfMemoryError e) {
            System.out.println("Out of memory at iteration: " + memoryHog.size());
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("Total time: " + (endTime - startTime) + " ms");
    }
    
    private static void printMemoryStats() {
        Runtime runtime = Runtime.getRuntime();
        long total = runtime.totalMemory();
        long free = runtime.freeMemory();
        long used = total - free;
        
        System.out.printf("Memory: %d MB used, %d MB free, %d MB total%n",
            used / 1024 / 1024, free / 1024 / 1024, total / 1024 / 1024);
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **GC działa automatycznie** - nie wywołuj System.gc() bez potrzeby
- **Unikaj memory leaks** - szczególnie w static collections
- **Monitoruj pamięć** - używaj narzędzi jak VisualVM
- **Nie używaj finalize()** - jest deprecated i problematyczny
- **Zrozum różnice między Stack a Heap** - to podstawa

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz program, który monitoruje użycie pamięci podczas tworzenia i usuwania obiektów.

**Zadanie 2:** Stwórz przykład memory leak i pokaż, jak go naprawić.

**Zadanie 3:** Porównaj performance różnych sposobów tworzenia Stringów (literal vs new String()).

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między Stack a Heap?
2. Co to jest Garbage Collector i kiedy działa?
3. Dlaczego nie powinno się używać System.gc()?

---

### 🚀 Część dla Seniorek

#### Głęboka analiza JVM i GC

JVM to nie tylko "maszyna wirtualna" - to zaawansowany runtime z sofistykowanymi algorytmami optymalizacji, które mogą sprawić, że Twój kod będzie działał szybciej niż natywny C++.

##### Architektura JVM w szczegółach

```java
public class JVMArchitectureDeep {
    // Method Area (Metaspace od Java 8)
    private static final String CONSTANT = "Stored in Method Area";
    
    // Heap - podzielony na generacje
    private List<String> youngGeneration = new ArrayList<>(); // Eden + Survivor spaces
    private Map<String, Object> oldGeneration = new HashMap<>(); // Tenured space
    
    public void demonstrateMemoryLayout() {
        // Stack frame dla tej metody
        int localPrimitive = 42;                    // Stack
        Object localReference = new Object();       // Reference na Stack, Object na Heap
        
        // Young Generation (Eden space)
        for (int i = 0; i < 1000; i++) {
            String temp = "Temporary " + i;         // Krótko żyjące obiekty
            youngGeneration.add(temp);
        }
        
        // Obiekty, które przeżyją kilka GC, przejdą do Old Generation
        oldGeneration.put("long-lived", "This will survive multiple GC cycles");
        
        // Direct Memory (poza Heap) - używane przez NIO
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
        
        // Code Cache - skompilowany kod JIT
        performHotMethod(); // Po wielu wywołaniach zostanie skompilowany przez JIT
    }
    
    // Metoda, która będzie "hot" i skompilowana przez JIT
    private void performHotMethod() {
        for (int i = 0; i < 10000; i++) {
            Math.sqrt(i);
        }
    }
}
```

##### Zaawansowane algorytmy GC

```java
public class AdvancedGCAnalysis {
    
    // G1 GC - Region-based collector
    public static class G1GCDemo {
        public static void demonstrateG1Behavior() {
            // G1 dzieli heap na regiony (~1-32MB każdy)
            // Concurrent marking + evacuation
            
            List<byte[]> regions = new ArrayList<>();
            
            // Symulacja mixed collections w G1
            for (int i = 0; i < 100; i++) {
                // Alokacja w różnych regionach
                byte[] region = new byte[2 * 1024 * 1024]; // 2MB
                regions.add(region);
                
                // G1 będzie zbierać regiony z najmniejszą ilością żywych obiektów
                if (i % 10 == 0) {
                    // Symulacja "garbage first" - usuń regiony z dużą ilością śmieci
                    regions.subList(0, Math.min(5, regions.size())).clear();
                }
                
                if (i % 20 == 0) {
                    printG1Stats();
                }
            }
        }
        
        private static void printG1Stats() {
            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
            
            // G1 specific metrics
            List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
            for (GarbageCollectorMXBean gcBean : gcBeans) {
                if (gcBean.getName().contains("G1")) {
                    System.out.printf("G1 %s: %d collections, %d ms total%n",
                        gcBean.getName(), gcBean.getCollectionCount(), gcBean.getCollectionTime());
                }
            }
        }
    }
    
    // ZGC - Ultra-low latency collector
    public static class ZGCDemo {
        public static void demonstrateZGCBehavior() {
            // ZGC używa colored pointers i concurrent operations
            // Pause times < 10ms niezależnie od heap size
            
            System.out.println("ZGC Demo - concurrent collection");
            
            // Massive allocation test
            List<Object[]> massiveData = new ArrayList<>();
            
            long startTime = System.currentTimeMillis();
            
            for (int i = 0; i < 10000; i++) {
                Object[] chunk = new Object[1000];
                for (int j = 0; j < 1000; j++) {
                    chunk[j] = "Data " + i + ":" + j;
                }
                massiveData.add(chunk);
                
                // ZGC powinno zbierać śmieci concurrent bez długich pauz
                if (i % 1000 == 0) {
                    long currentTime = System.currentTimeMillis();
                    System.out.printf("Allocated %d chunks in %d ms%n", 
                        i, currentTime - startTime);
                }
            }
        }
    }
}
```

##### JIT Compiler i optymalizacje

```java
public class JITOptimizations {
    private static final int ITERATIONS = 100_000;
    
    // Metoda, która będzie zoptymalizowana przez JIT
    public static long hotMethod(int n) {
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += i * i; // JIT może to wektoryzować
        }
        return sum;
    }
    
    // Metoda z branch prediction
    public static int branchPredictionDemo(int[] data) {
        int sum = 0;
        for (int value : data) {
            if (value > 50) { // JIT nauczy się przewidywać ten branch
                sum += value;
            }
        }
        return sum;
    }
    
    // Inlining demonstration
    private static int simpleMethod(int x) {
        return x * 2; // Ta metoda zostanie zinlinowana
    }
    
    public static void demonstrateInlining() {
        int sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += simpleMethod(i); // Wywołanie zostanie zastąpione przez x * 2
        }
        System.out.println("Sum: " + sum);
    }
    
    // Escape analysis
    public static void escapeAnalysisDemo() {
        for (int i = 0; i < ITERATIONS; i++) {
            Point p = new Point(i, i * 2); // Może zostać zalokowane na stack!
            int distance = p.distanceFromOrigin();
            // p nie "ucieka" z metody, więc może być stack-allocated
        }
    }
    
    private static class Point {
        private final int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        int distanceFromOrigin() {
            return (int) Math.sqrt(x * x + y * y);
        }
    }
    
    public static void main(String[] args) {
        // Warm-up JIT
        for (int i = 0; i < 10000; i++) {
            hotMethod(100);
        }
        
        // Measure performance after JIT compilation
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            hotMethod(100);
        }
        long end = System.nanoTime();
        
        System.out.printf("Hot method (JIT compiled): %.2f ms%n", 
            (end - start) / 1_000_000.0);
        
        demonstrateInlining();
        escapeAnalysisDemo();
    }
}
```

##### Memory leak detection i analysis

```java
public class MemoryLeakDetection {
    
    // Leak #1: Static collections
    private static final Map<String, Object> GLOBAL_CACHE = new HashMap<>();
    
    // Leak #2: Listeners not removed
    private static final List<EventListener> LISTENERS = new ArrayList<>();
    
    // Leak #3: ThreadLocal not cleaned
    private static final ThreadLocal<List<String>> THREAD_LOCAL_DATA = new ThreadLocal<>();
    
    public interface EventListener {
        void onEvent(String event);
    }
    
    public static class LeakyClass {
        private final String data;
        
        public LeakyClass(String data) {
            this.data = data;
            // Leak: dodaje się do static collection
            GLOBAL_CACHE.put(data, this);
        }
        
        public void addListener(EventListener listener) {
            // Leak: listener nigdy nie jest usuwany
            LISTENERS.add(listener);
        }
        
        public void processInThread() {
            // Leak: ThreadLocal nie jest czyszczony
            List<String> threadData = THREAD_LOCAL_DATA.get();
            if (threadData == null) {
                threadData = new ArrayList<>();
                THREAD_LOCAL_DATA.set(threadData);
            }
            threadData.add(data);
            // Brak THREAD_LOCAL_DATA.remove()!
        }
    }
    
    // Proper cleanup patterns
    public static class ProperCleanup {
        private final Map<String, Object> cache = new WeakHashMap<>(); // Weak references
        private final List<WeakReference<EventListener>> listeners = new ArrayList<>();
        
        public void addToCache(String key, Object value) {
            cache.put(key, value); // WeakHashMap automatycznie czyści
        }
        
        public void addListener(EventListener listener) {
            listeners.add(new WeakReference<>(listener)); // Weak reference
            cleanupDeadListeners();
        }
        
        private void cleanupDeadListeners() {
            listeners.removeIf(ref -> ref.get() == null);
        }
        
        public void processInThread() {
            try {
                List<String> threadData = THREAD_LOCAL_DATA.get();
                if (threadData == null) {
                    threadData = new ArrayList<>();
                    THREAD_LOCAL_DATA.set(threadData);
                }
                threadData.add("processed");
            } finally {
                THREAD_LOCAL_DATA.remove(); // Zawsze czyść!
            }
        }
    }
    
    // Memory leak detection tools
    public static void detectLeaks() {
        Runtime runtime = Runtime.getRuntime();
        
        long initialMemory = runtime.totalMemory() - runtime.freeMemory();
        
        // Symulacja leak
        for (int i = 0; i < 10000; i++) {
            new LeakyClass("Data " + i);
        }
        
        // Force GC
        System.gc();
        System.gc(); // Dwa razy dla pewności
        
        try {
            Thread.sleep(100); // Daj czas GC
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        long finalMemory = runtime.totalMemory() - runtime.freeMemory();
        long leaked = finalMemory - initialMemory;
        
        System.out.printf("Potential memory leak: %d KB%n", leaked / 1024);
        System.out.printf("Global cache size: %d%n", GLOBAL_CACHE.size());
        System.out.printf("Listeners count: %d%n", LISTENERS.size());
    }
}
```

##### GC Tuning w praktyce

```java
public class GCTuning {
    
    public static void demonstrateGCTuning() {
        System.out.println("=== GC Tuning Recommendations ===");
        
        // Analiza heap usage patterns
        analyzeHeapUsage();
        
        // Recommendations based on application type
        recommendGCForApplicationType();
        
        // Common GC flags
        printCommonGCFlags();
    }
    
    private static void analyzeHeapUsage() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        
        long used = heapUsage.getUsed();
        long max = heapUsage.getMax();
        double utilization = (double) used / max * 100;
        
        System.out.printf("Heap utilization: %.1f%% (%d MB / %d MB)%n",
            utilization, used / 1024 / 1024, max / 1024 / 1024);
        
        if (utilization > 80) {
            System.out.println("⚠️  High heap utilization - consider increasing heap size");
        } else if (utilization < 30) {
            System.out.println("💡 Low heap utilization - consider decreasing heap size");
        }
        
        // Analyze GC frequency
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            long collections = gcBean.getCollectionCount();
            long time = gcBean.getCollectionTime();
            
            if (collections > 0) {
                double avgTime = (double) time / collections;
                System.out.printf("%s: %d collections, avg %.1f ms%n",
                    gcBean.getName(), collections, avgTime);
                
                if (avgTime > 100) {
                    System.out.println("⚠️  Long GC pauses detected");
                }
            }
        }
    }
    
    private static void recommendGCForApplicationType() {
        System.out.println("\n=== GC Recommendations by Application Type ===");
        
        System.out.println("🖥️  Desktop Applications:");
        System.out.println("   - Use Parallel GC or G1GC");
        System.out.println("   - Flags: -XX:+UseG1GC -XX:MaxGCPauseMillis=200");
        
        System.out.println("\n🌐 Web Applications:");
        System.out.println("   - Use G1GC for low latency");
        System.out.println("   - Flags: -XX:+UseG1GC -XX:MaxGCPauseMillis=100");
        
        System.out.println("\n📊 Big Data/Analytics:");
        System.out.println("   - Use Parallel GC for throughput");
        System.out.println("   - Flags: -XX:+UseParallelGC -XX:ParallelGCThreads=8");
        
        System.out.println("\n⚡ Ultra-Low Latency:");
        System.out.println("   - Use ZGC or Shenandoah");
        System.out.println("   - Flags: -XX:+UseZGC or -XX:+UseShenandoahGC");
    }
    
    private static void printCommonGCFlags() {
        System.out.println("\n=== Common GC Tuning Flags ===");
        
        String[][] flags = {
            {"-Xms", "Initial heap size", "-Xms2g"},
            {"-Xmx", "Maximum heap size", "-Xmx8g"},
            {"-XX:NewRatio", "Old/Young generation ratio", "-XX:NewRatio=3"},
            {"-XX:MaxGCPauseMillis", "Target pause time (G1)", "-XX:MaxGCPauseMillis=200"},
            {"-XX:G1HeapRegionSize", "G1 region size", "-XX:G1HeapRegionSize=16m"},
            {"-XX:+UseStringDeduplication", "String deduplication (G1)", "-XX:+UseStringDeduplication"},
            {"-XX:+PrintGC", "Enable GC logging", "-XX:+PrintGC"},
            {"-XX:+PrintGCDetails", "Detailed GC logging", "-XX:+PrintGCDetails"},
            {"-XX:+PrintGCTimeStamps", "GC timestamps", "-XX:+PrintGCTimeStamps"}
        };
        
        for (String[] flag : flags) {
            System.out.printf("%-25s %-30s %s%n", flag[0], flag[1], flag[2]);
        }
    }
    
    public static void main(String[] args) {
        demonstrateGCTuning();
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj własny memory profiler używając JMX beans.

**Zadanie Zaawansowane 2:** Stwórz benchmark porównujący różne GC algorithms dla różnych workloadów.

**Zadanie Zaawansowane 3:** Zaprojektuj system monitoringu GC dla aplikacji produkcyjnej.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak JIT compiler optymalizuje kod i jakie są główne techniki?
2. Jakie są różnice między G1, ZGC i Shenandoah GC?
3. Jak wykrywać i debugować memory leaks w aplikacjach produkcyjnych?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Pytania kontrolne:**
1. Stack przechowuje zmienne lokalne i wywołania metod (szybki, automatycznie zarządzany), Heap przechowuje obiekty (wolniejszy, zarządzany przez GC)
2. GC automatycznie usuwa nieosiągalne obiekty z Heap, działa gdy pamięć się kończy lub w regularnych odstępach
3. System.gc() to tylko sugestia, GC może ją zignorować, a wywoływanie może pogorszyć performance

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. JIT używa inlining, escape analysis, loop optimization, vectorization, branch prediction - optymalizuje hot spots w runtime
2. G1 - region-based, target pause time; ZGC - colored pointers, ultra-low latency; Shenandoah - concurrent evacuation
3. Heap dumps, memory profilers (VisualVM, JProfiler), JMX monitoring, weak references, proper cleanup patterns

---

*💡 Pamiętaj: JVM to nie czarna magia - to zaawansowana technologia, którą można zrozumieć i kontrolować. Znajomość JVM czyni z Ciebie lepszą programistkę!*



## 21. Zarządzanie pamięcią w praktyce (Heap vs Stack vs Metaspace)

*Cześć! Dziś porozmawiamy o tym, gdzie właściwie trafiają Twoje dane w JVM. To jak poznanie architektury domu - musisz wiedzieć, co gdzie się znajduje, żeby efektywnie z tego korzystać. Heap, Stack, Metaspace - każdy ma swoje przeznaczenie i swoje sekrety!*

---

### 🌱 Część dla Juniorek

#### Mapa pamięci JVM - gdzie co mieszka?

Wyobraź sobie JVM jako wielopiętrowy dom. Każde piętro ma swoje przeznaczenie:

- **Stack** - to Twoje biurko, gdzie trzymasz aktualne zadania
- **Heap** - to magazyn, gdzie przechowujesz wszystkie rzeczy
- **Metaspace** - to biblioteka z instrukcjami obsługi

```java
public class MemoryAreasDemo {
    // Static variables - Metaspace
    private static String companyName = "TechCorp";
    private static final int MAX_EMPLOYEES = 1000;
    
    // Instance variables - Heap
    private String employeeName;
    private int employeeId;
    private List<String> projects;
    
    public MemoryAreasDemo(String name, int id) {
        this.employeeName = name;     // Heap
        this.employeeId = id;         // Heap
        this.projects = new ArrayList<>(); // Heap
    }
    
    public void doWork() {
        // Local variables - Stack
        String currentTask = "Coding";
        int hoursWorked = 8;
        boolean isCompleted = false;
        
        // Method call - nowa ramka na Stack
        String result = processTask(currentTask, hoursWorked);
        
        // Po zakończeniu metody wszystkie zmienne lokalne znikają ze Stack
        System.out.println("Task result: " + result);
    }
    
    private String processTask(String task, int hours) {
        // Kolejna ramka na Stack
        String status = "In Progress";
        
        if (hours >= 8) {
            status = "Completed";
        }
        
        return task + " - " + status;
        // Ramka znika ze Stack po return
    }
    
    public static void main(String[] args) {
        // Obiekt na Heap, referencja na Stack
        MemoryAreasDemo employee = new MemoryAreasDemo("Anna", 123);
        employee.doWork();
    }
}
```

#### Stack - szybkie i automatyczne

Stack to miejsce, gdzie JVM trzyma:
- Zmienne lokalne metod
- Parametry metod
- Adresy powrotu z metod
- Częściowe wyniki obliczeń

```java
public class StackDemo {
    public void demonstrateStack() {
        int a = 10;        // Na Stack
        int b = 20;        // Na Stack
        int sum = add(a, b); // Wywołanie metody - nowa ramka na Stack
        
        System.out.println("Sum: " + sum);
        // Po zakończeniu metody cała ramka znika ze Stack
    }
    
    private int add(int x, int y) {
        // Nowa ramka na Stack z parametrami x, y
        int result = x + y;  // result też na Stack
        return result;       // Ramka znika, zwracana jest wartość
    }
    
    public void stackOverflowExample() {
        // UWAGA: To spowoduje StackOverflowError!
        // stackOverflowExample(); // Nieskończona rekursja
        
        // Bezpieczna rekursja z warunkiem stopu
        safeRecursion(5);
    }
    
    private void safeRecursion(int n) {
        if (n <= 0) {
            return; // Warunek stopu
        }
        
        System.out.println("Recursion level: " + n);
        safeRecursion(n - 1); // Każde wywołanie to nowa ramka na Stack
    }
    
    public static void main(String[] args) {
        StackDemo demo = new StackDemo();
        demo.demonstrateStack();
        demo.stackOverflowExample();
    }
}
```

#### Heap - magazyn obiektów

Heap to miejsce, gdzie żyją wszystkie obiekty. Jest podzielony na obszary:

```java
public class HeapDemo {
    // Instance fields - będą na Heap
    private String name;
    private List<String> items;
    
    public HeapDemo(String name) {
        this.name = name;                    // String object na Heap
        this.items = new ArrayList<>();     // ArrayList object na Heap
    }
    
    public void demonstrateHeapUsage() {
        // Young Generation - nowe obiekty
        for (int i = 0; i < 1000; i++) {
            String temp = "Temporary " + i;  // Krótko żyjące obiekty
            items.add(temp);
        }
        
        // Obiekty, które przeżyją, przejdą do Old Generation
        String permanent = "This will live long";
        items.add(permanent);
        
        // Duże obiekty mogą iść bezpośrednio do Old Generation
        byte[] bigArray = new byte[1024 * 1024]; // 1MB array
        
        // Sprawdzenie pamięci
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        
        System.out.printf("Heap usage: %d MB / %d MB%n", 
            usedMemory / 1024 / 1024, totalMemory / 1024 / 1024);
    }
    
    public void demonstrateGenerations() {
        List<Object> youngObjects = new ArrayList<>();
        List<Object> oldObjects = new ArrayList<>();
        
        // Symulacja Young Generation
        for (int i = 0; i < 10000; i++) {
            Object youngObj = new Object();
            youngObjects.add(youngObj);
            
            // Co jakiś czas "promuj" obiekty do Old Generation
            if (i % 1000 == 0) {
                oldObjects.addAll(youngObjects.subList(0, 100));
            }
        }
        
        System.out.println("Young objects: " + youngObjects.size());
        System.out.println("Old objects: " + oldObjects.size());
    }
    
    public static void main(String[] args) {
        HeapDemo demo = new HeapDemo("HeapTest");
        demo.demonstrateHeapUsage();
        demo.demonstrateGenerations();
    }
}
```

#### Metaspace - biblioteka klas

Od Java 8, Metaspace zastąpił PermGen. To miejsce, gdzie JVM trzyma:
- Metadane klas
- Bytecode metod
- Constant pool
- Informacje o metodach i polach

```java
public class MetaspaceDemo {
    // Static fields - metadane w Metaspace
    private static final String COMPANY = "TechCorp";
    private static int instanceCount = 0;
    
    // Instance fields - metadane w Metaspace, wartości na Heap
    private String name;
    private int id;
    
    public MetaspaceDemo(String name) {
        this.name = name;
        this.id = ++instanceCount;
    }
    
    // Method bytecode - w Metaspace
    public void displayInfo() {
        System.out.println("Employee: " + name + " (ID: " + id + ")");
        System.out.println("Company: " + COMPANY);
    }
    
    // Static method - bytecode w Metaspace
    public static void showMetaspaceInfo() {
        // Informacje o Metaspace
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        
        // Metaspace usage
        List<MemoryPoolMXBean> memoryPools = ManagementFactory.getMemoryPoolMXBeans();
        for (MemoryPoolMXBean pool : memoryPools) {
            if (pool.getName().contains("Metaspace")) {
                MemoryUsage usage = pool.getUsage();
                System.out.printf("Metaspace: %d MB used, %d MB max%n",
                    usage.getUsed() / 1024 / 1024,
                    usage.getMax() / 1024 / 1024);
            }
        }
        
        // Class loading statistics
        ClassLoadingMXBean classBean = ManagementFactory.getClassLoadingMXBean();
        System.out.println("Loaded classes: " + classBean.getLoadedClassCount());
        System.out.println("Total loaded: " + classBean.getTotalLoadedClassCount());
        System.out.println("Unloaded classes: " + classBean.getUnloadedClassCount());
    }
    
    public static void main(String[] args) {
        // Tworzenie obiektów - metadane w Metaspace, instancje na Heap
        MetaspaceDemo emp1 = new MetaspaceDemo("Anna");
        MetaspaceDemo emp2 = new MetaspaceDemo("Beata");
        
        emp1.displayInfo();
        emp2.displayInfo();
        
        showMetaspaceInfo();
    }
}
```

#### Praktyczne przykłady zarządzania pamięcią

**1. Optymalizacja użycia Stack:**

```java
public class StackOptimization {
    // PROBLEM: Głęboka rekursja może spowodować StackOverflowError
    public static long factorialRecursive(int n) {
        if (n <= 1) return 1;
        return n * factorialRecursive(n - 1); // Każde wywołanie = nowa ramka
    }
    
    // ROZWIĄZANIE: Iteracyjna wersja używa mniej Stack
    public static long factorialIterative(int n) {
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i; // Tylko jedna ramka na Stack
        }
        return result;
    }
    
    // ROZWIĄZANIE: Tail recursion optimization (ręczna)
    public static long factorialTailRecursive(int n) {
        return factorialHelper(n, 1);
    }
    
    private static long factorialHelper(int n, long accumulator) {
        if (n <= 1) return accumulator;
        return factorialHelper(n - 1, n * accumulator);
    }
    
    public static void main(String[] args) {
        int n = 20;
        
        System.out.println("Recursive: " + factorialRecursive(n));
        System.out.println("Iterative: " + factorialIterative(n));
        System.out.println("Tail recursive: " + factorialTailRecursive(n));
        
        // Test stack usage
        try {
            factorialRecursive(100000); // Może spowodować StackOverflowError
        } catch (StackOverflowError e) {
            System.out.println("Stack overflow with recursive version");
        }
        
        System.out.println("Iterative with large n: " + factorialIterative(20));
    }
}
```

**2. Optymalizacja użycia Heap:**

```java
public class HeapOptimization {
    // PROBLEM: Tworzenie wielu małych obiektów
    public static String concatenateStrings(String[] strings) {
        String result = "";
        for (String s : strings) {
            result += s; // Każda operacja tworzy nowy String object!
        }
        return result;
    }
    
    // ROZWIĄZANIE: StringBuilder używa mniej pamięci
    public static String concatenateStringsOptimized(String[] strings) {
        StringBuilder sb = new StringBuilder();
        for (String s : strings) {
            sb.append(s); // Modyfikuje istniejący buffer
        }
        return sb.toString();
    }
    
    // PROBLEM: Przechowywanie dużych kolekcji
    public static class DataProcessor {
        private List<String> allData = new ArrayList<>(); // Może rosnąć bez kontroli
        
        public void processData(String[] newData) {
            for (String item : newData) {
                allData.add(item.toUpperCase());
            }
        }
        
        public int getDataSize() {
            return allData.size();
        }
    }
    
    // ROZWIĄZANIE: Ograniczony cache z LRU
    public static class OptimizedDataProcessor {
        private static final int MAX_CACHE_SIZE = 1000;
        private Map<String, String> cache = new LinkedHashMap<String, String>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > MAX_CACHE_SIZE;
            }
        };
        
        public void processData(String[] newData) {
            for (String item : newData) {
                cache.put(item, item.toUpperCase());
            }
        }
        
        public int getCacheSize() {
            return cache.size();
        }
    }
    
    public static void main(String[] args) {
        String[] testData = {"Hello", " ", "World", "!", " ", "Java", " ", "Memory"};
        
        // Test string concatenation
        long start = System.nanoTime();
        String result1 = concatenateStrings(testData);
        long end = System.nanoTime();
        System.out.printf("String concatenation: %s (%.2f ms)%n", 
            result1, (end - start) / 1_000_000.0);
        
        start = System.nanoTime();
        String result2 = concatenateStringsOptimized(testData);
        end = System.nanoTime();
        System.out.printf("StringBuilder: %s (%.2f ms)%n", 
            result2, (end - start) / 1_000_000.0);
        
        // Test data processing
        DataProcessor processor1 = new DataProcessor();
        OptimizedDataProcessor processor2 = new OptimizedDataProcessor();
        
        // Symulacja dużej ilości danych
        for (int i = 0; i < 10000; i++) {
            String[] batch = {"data" + i, "item" + i, "value" + i};
            processor1.processData(batch);
            processor2.processData(batch);
        }
        
        System.out.println("Regular processor size: " + processor1.getDataSize());
        System.out.println("Optimized processor size: " + processor2.getCacheSize());
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Stack jest szybki ale ograniczony** - unikaj głębokiej rekursji
- **Heap jest większy ale wolniejszy** - uważaj na memory leaks
- **Metaspace rośnie z liczbą klas** - nie ładuj klas dynamicznie bez potrzeby
- **Monitoruj użycie pamięci** - używaj narzędzi jak JVisualVM
- **Optymalizuj String operations** - używaj StringBuilder dla konkatenacji

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz program, który pokazuje różnicę w użyciu pamięci między String concatenation a StringBuilder.

**Zadanie 2:** Stwórz przykład, który demonstruje StackOverflowError i pokaż, jak go uniknąć.

**Zadanie 3:** Zaimplementuj prosty cache z ograniczeniem rozmiaru, który automatycznie usuwa najstarsze elementy.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Gdzie są przechowywane zmienne lokalne metod?
2. Jaka jest różnica między Heap a Metaspace?
3. Co może spowodować StackOverflowError?

---

### 🚀 Część dla Seniorek

#### Głęboka analiza obszarów pamięci

Zarządzanie pamięcią w JVM to nie tylko podział na Stack/Heap/Metaspace - to złożony system z wieloma optymalizacjami i pułapkami.

##### Szczegółowa anatomia Heap

```java
public class HeapAnatomy {
    
    // Demonstracja różnych obszarów Heap
    public static class HeapRegionDemo {
        private static final int SMALL_OBJECT_SIZE = 100;
        private static final int LARGE_OBJECT_SIZE = 1024 * 1024; // 1MB
        
        public static void demonstrateEdenSpace() {
            System.out.println("=== Eden Space Demo ===");
            List<Object> edenObjects = new ArrayList<>();
            
            // Małe, krótko żyjące obiekty - trafiają do Eden
            for (int i = 0; i < 10000; i++) {
                byte[] smallObject = new byte[SMALL_OBJECT_SIZE];
                edenObjects.add(smallObject);
                
                if (i % 1000 == 0) {
                    printMemoryUsage("Eden allocation " + i);
                }
            }
            
            // Wyczyść referencje - obiekty staną się eligible for GC
            edenObjects.clear();
            System.gc(); // Sugestia GC
            printMemoryUsage("After Eden cleanup");
        }
        
        public static void demonstrateSurvivorSpaces() {
            System.out.println("\n=== Survivor Spaces Demo ===");
            List<Object> survivors = new ArrayList<>();
            
            // Obiekty, które przeżyją kilka cykli GC
            for (int cycle = 0; cycle < 5; cycle++) {
                List<Object> tempObjects = new ArrayList<>();
                
                // Twórz obiekty w Eden
                for (int i = 0; i < 1000; i++) {
                    Object obj = new byte[SMALL_OBJECT_SIZE];
                    tempObjects.add(obj);
                }
                
                // Niektóre obiekty "przeżyją" - dodaj do survivors
                if (cycle % 2 == 0) {
                    survivors.addAll(tempObjects.subList(0, 100));
                }
                
                // Wyczyść temp objects - spowoduje minor GC
                tempObjects.clear();
                System.gc();
                
                printMemoryUsage("Cycle " + cycle);
            }
            
            System.out.println("Survivors count: " + survivors.size());
        }
        
        public static void demonstrateOldGeneration() {
            System.out.println("\n=== Old Generation Demo ===");
            List<Object> oldObjects = new ArrayList<>();
            
            // Duże obiekty mogą iść bezpośrednio do Old Gen
            for (int i = 0; i < 10; i++) {
                byte[] largeObject = new byte[LARGE_OBJECT_SIZE];
                oldObjects.add(largeObject);
                printMemoryUsage("Large object " + i);
            }
            
            // Długo żyjące obiekty też trafiają do Old Gen
            Map<String, Object> longLivedCache = new HashMap<>();
            for (int i = 0; i < 10000; i++) {
                longLivedCache.put("key" + i, new Object());
            }
            
            printMemoryUsage("Long-lived objects");
            
            // Major GC cleanup
            oldObjects.clear();
            longLivedCache.clear();
            System.gc();
            printMemoryUsage("After Old Gen cleanup");
        }
        
        private static void printMemoryUsage(String phase) {
            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
            MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
            
            System.out.printf("%s: %d MB used / %d MB max%n",
                phase,
                heapUsage.getUsed() / 1024 / 1024,
                heapUsage.getMax() / 1024 / 1024);
        }
    }
    
    public static void main(String[] args) {
        HeapRegionDemo.demonstrateEdenSpace();
        HeapRegionDemo.demonstrateSurvivorSpaces();
        HeapRegionDemo.demonstrateOldGeneration();
    }
}
```

##### Stack Frame Analysis

```java
public class StackFrameAnalysis {
    
    // Analiza zawartości Stack Frame
    public static class StackFrameDemo {
        private int instanceVar = 42;
        
        public void analyzeStackFrame(int param1, String param2) {
            // Local variables
            int localInt = 100;
            String localString = "local";
            Object localObject = new Object();
            
            // Nested method call
            int result = nestedMethod(localInt, param1);
            
            // Lambda - może przechwycić zmienne z Stack Frame
            Runnable lambda = () -> {
                System.out.println("Lambda accessing: " + localString);
                System.out.println("Instance var: " + instanceVar);
            };
            
            lambda.run();
            
            System.out.println("Method result: " + result);
        }
        
        private int nestedMethod(int a, int b) {
            // Nowy Stack Frame
            int localSum = a + b;
            
            // Jeszcze głębsze zagnieżdżenie
            return deeperMethod(localSum);
        }
        
        private int deeperMethod(int value) {
            // Kolejny Stack Frame
            int multiplied = value * 2;
            
            // Analiza aktualnego stack trace
            StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
            System.out.println("Current stack depth: " + stackTrace.length);
            
            for (int i = 0; i < Math.min(5, stackTrace.length); i++) {
                StackTraceElement element = stackTrace[i];
                System.out.printf("  %d: %s.%s (line %d)%n",
                    i, element.getClassName(), element.getMethodName(), element.getLineNumber());
            }
            
            return multiplied;
        }
    }
    
    // Stack overflow prevention
    public static class StackOverflowPrevention {
        private static final int MAX_RECURSION_DEPTH = 1000;
        
        public static long fibonacci(int n) {
            return fibonacciWithDepthCheck(n, 0);
        }
        
        private static long fibonacciWithDepthCheck(int n, int depth) {
            if (depth > MAX_RECURSION_DEPTH) {
                throw new IllegalArgumentException("Recursion too deep: " + depth);
            }
            
            if (n <= 1) return n;
            return fibonacciWithDepthCheck(n - 1, depth + 1) + 
                   fibonacciWithDepthCheck(n - 2, depth + 1);
        }
        
        // Iterative version - constant stack usage
        public static long fibonacciIterative(int n) {
            if (n <= 1) return n;
            
            long prev = 0, curr = 1;
            for (int i = 2; i <= n; i++) {
                long next = prev + curr;
                prev = curr;
                curr = next;
            }
            return curr;
        }
        
        // Memoized version - controlled stack usage
        private static Map<Integer, Long> fibCache = new HashMap<>();
        
        public static long fibonacciMemoized(int n) {
            if (n <= 1) return n;
            
            return fibCache.computeIfAbsent(n, k -> 
                fibonacciMemoized(k - 1) + fibonacciMemoized(k - 2));
        }
    }
    
    public static void main(String[] args) {
        StackFrameDemo demo = new StackFrameDemo();
        demo.analyzeStackFrame(10, "test");
        
        // Test different fibonacci implementations
        int n = 40;
        
        long start = System.nanoTime();
        long result1 = StackOverflowPrevention.fibonacciIterative(n);
        long end = System.nanoTime();
        System.out.printf("Iterative fibonacci(%d) = %d (%.2f ms)%n", 
            n, result1, (end - start) / 1_000_000.0);
        
        start = System.nanoTime();
        long result2 = StackOverflowPrevention.fibonacciMemoized(n);
        end = System.nanoTime();
        System.out.printf("Memoized fibonacci(%d) = %d (%.2f ms)%n", 
            n, result2, (end - start) / 1_000_000.0);
    }
}
```

##### Metaspace Deep Dive

```java
public class MetaspaceDeepDive {
    
    // Class loading impact on Metaspace
    public static class DynamicClassLoading {
        
        public static void demonstrateClassLoading() {
            System.out.println("=== Dynamic Class Loading Demo ===");
            
            ClassLoadingMXBean classBean = ManagementFactory.getClassLoadingMXBean();
            
            System.out.println("Initial classes loaded: " + classBean.getLoadedClassCount());
            
            // Symulacja ładowania wielu klas
            List<Class<?>> loadedClasses = new ArrayList<>();
            
            try {
                // Ładowanie klas z różnych pakietów
                String[] classNames = {
                    "java.util.concurrent.ConcurrentHashMap",
                    "java.util.concurrent.ThreadPoolExecutor",
                    "java.util.concurrent.CompletableFuture",
                    "java.util.stream.Collectors",
                    "java.time.LocalDateTime",
                    "java.time.format.DateTimeFormatter"
                };
                
                for (String className : classNames) {
                    Class<?> clazz = Class.forName(className);
                    loadedClasses.add(clazz);
                    System.out.println("Loaded: " + className);
                }
                
                System.out.println("Classes after loading: " + classBean.getLoadedClassCount());
                
                // Analiza Metaspace usage
                analyzeMetaspaceUsage();
                
            } catch (ClassNotFoundException e) {
                System.err.println("Class not found: " + e.getMessage());
            }
        }
        
        private static void analyzeMetaspaceUsage() {
            List<MemoryPoolMXBean> memoryPools = ManagementFactory.getMemoryPoolMXBeans();
            
            for (MemoryPoolMXBean pool : memoryPools) {
                if (pool.getName().contains("Metaspace") || 
                    pool.getName().contains("Compressed Class Space")) {
                    
                    MemoryUsage usage = pool.getUsage();
                    System.out.printf("%s: %d KB used, %d KB committed%n",
                        pool.getName(),
                        usage.getUsed() / 1024,
                        usage.getCommitted() / 1024);
                }
            }
        }
    }
    
    // Constant Pool analysis
    public static class ConstantPoolDemo {
        // String literals - w Constant Pool
        private static final String LITERAL1 = "Hello";
        private static final String LITERAL2 = "World";
        private static final String LITERAL3 = "Hello"; // Ta sama instancja co LITERAL1
        
        public static void demonstrateStringPool() {
            System.out.println("\n=== String Pool Demo ===");
            
            // String literals są internowane automatycznie
            String s1 = "Hello";
            String s2 = "Hello";
            String s3 = new String("Hello");
            String s4 = s3.intern();
            
            System.out.println("s1 == s2: " + (s1 == s2)); // true - ten sam obiekt z pool
            System.out.println("s1 == s3: " + (s1 == s3)); // false - s3 to nowy obiekt
            System.out.println("s1 == s4: " + (s1 == s4)); // true - intern() zwraca z pool
            
            // Analiza String Pool
            analyzeStringPool();
        }
        
        private static void analyzeStringPool() {
            // String Pool statistics (Java 8+)
            List<MemoryPoolMXBean> pools = ManagementFactory.getMemoryPoolMXBeans();
            
            for (MemoryPoolMXBean pool : pools) {
                if (pool.getName().contains("String")) {
                    MemoryUsage usage = pool.getUsage();
                    if (usage != null) {
                        System.out.printf("String Pool: %d KB used%n", 
                            usage.getUsed() / 1024);
                    }
                }
            }
        }
    }
    
    // Method Area analysis
    public static class MethodAreaDemo {
        
        public static void demonstrateMethodArea() {
            System.out.println("\n=== Method Area Demo ===");
            
            // Reflection - dostęp do metadanych w Method Area
            Class<?> clazz = MethodAreaDemo.class;
            
            System.out.println("Class name: " + clazz.getName());
            System.out.println("Methods count: " + clazz.getDeclaredMethods().length);
            System.out.println("Fields count: " + clazz.getDeclaredFields().length);
            
            // Analiza bytecode
            analyzeBytecode(clazz);
        }
        
        private static void analyzeBytecode(Class<?> clazz) {
            Method[] methods = clazz.getDeclaredMethods();
            
            for (Method method : methods) {
                System.out.printf("Method: %s%n", method.getName());
                System.out.printf("  Parameters: %d%n", method.getParameterCount());
                System.out.printf("  Return type: %s%n", method.getReturnType().getSimpleName());
                
                // Annotations - też w Method Area
                if (method.getAnnotations().length > 0) {
                    System.out.printf("  Annotations: %d%n", method.getAnnotations().length);
                }
            }
        }
    }
    
    public static void main(String[] args) {
        DynamicClassLoading.demonstrateClassLoading();
        ConstantPoolDemo.demonstrateStringPool();
        MethodAreaDemo.demonstrateMethodArea();
    }
}
```

##### Memory Optimization Strategies

```java
public class MemoryOptimizationStrategies {
    
    // Object pooling for expensive objects
    public static class ObjectPoolDemo {
        private static final Queue<StringBuilder> stringBuilderPool = 
            new ConcurrentLinkedQueue<>();
        private static final int MAX_POOL_SIZE = 10;
        
        public static StringBuilder borrowStringBuilder() {
            StringBuilder sb = stringBuilderPool.poll();
            if (sb == null) {
                sb = new StringBuilder();
            } else {
                sb.setLength(0); // Reset
            }
            return sb;
        }
        
        public static void returnStringBuilder(StringBuilder sb) {
            if (stringBuilderPool.size() < MAX_POOL_SIZE) {
                stringBuilderPool.offer(sb);
            }
        }
        
        public static String processStrings(String[] strings) {
            StringBuilder sb = borrowStringBuilder();
            try {
                for (String s : strings) {
                    sb.append(s).append(" ");
                }
                return sb.toString().trim();
            } finally {
                returnStringBuilder(sb);
            }
        }
    }
    
    // Flyweight pattern for memory efficiency
    public static class FlyweightDemo {
        // Shared intrinsic state
        private static final Map<String, Color> colorCache = new HashMap<>();
        
        public static class Color {
            private final String name;
            private final int rgb;
            
            private Color(String name, int rgb) {
                this.name = name;
                this.rgb = rgb;
            }
            
            public static Color getColor(String name, int rgb) {
                String key = name + "_" + rgb;
                return colorCache.computeIfAbsent(key, k -> new Color(name, rgb));
            }
            
            public void render(int x, int y, int size) {
                // Extrinsic state passed as parameters
                System.out.printf("Rendering %s color at (%d,%d) size %d%n", 
                    name, x, y, size);
            }
        }
        
        public static void demonstrateFlyweight() {
            // Multiple objects sharing the same Color instances
            Color red1 = Color.getColor("Red", 0xFF0000);
            Color red2 = Color.getColor("Red", 0xFF0000);
            Color blue = Color.getColor("Blue", 0x0000FF);
            
            System.out.println("red1 == red2: " + (red1 == red2)); // true - same instance
            
            // Render with different extrinsic state
            red1.render(10, 20, 5);
            red2.render(30, 40, 10);
            blue.render(50, 60, 15);
            
            System.out.println("Color cache size: " + colorCache.size());
        }
    }
    
    // Memory-efficient data structures
    public static class EfficientDataStructures {
        
        // Primitive collections to avoid boxing
        public static void demonstratePrimitiveCollections() {
            // Regular ArrayList with Integer boxing
            List<Integer> boxedList = new ArrayList<>();
            for (int i = 0; i < 1000; i++) {
                boxedList.add(i); // Boxing int to Integer
            }
            
            // Primitive array - no boxing
            int[] primitiveArray = new int[1000];
            for (int i = 0; i < 1000; i++) {
                primitiveArray[i] = i; // No boxing
            }
            
            // Memory usage comparison
            Runtime runtime = Runtime.getRuntime();
            
            long beforeBoxed = runtime.totalMemory() - runtime.freeMemory();
            List<Integer> moreBoxed = new ArrayList<>();
            for (int i = 0; i < 100000; i++) {
                moreBoxed.add(i);
            }
            long afterBoxed = runtime.totalMemory() - runtime.freeMemory();
            
            System.gc();
            
            long beforePrimitive = runtime.totalMemory() - runtime.freeMemory();
            int[] morePrimitive = new int[100000];
            for (int i = 0; i < 100000; i++) {
                morePrimitive[i] = i;
            }
            long afterPrimitive = runtime.totalMemory() - runtime.freeMemory();
            
            System.out.printf("Boxed collection memory: %d KB%n", 
                (afterBoxed - beforeBoxed) / 1024);
            System.out.printf("Primitive array memory: %d KB%n", 
                (afterPrimitive - beforePrimitive) / 1024);
        }
        
        // Compact data structures
        public static class CompactUser {
            // Bit packing for boolean flags
            private byte flags; // 8 boolean flags in 1 byte
            private short age;  // Instead of int if range allows
            private String name; // Interned if repeated
            
            public CompactUser(String name, int age) {
                this.name = name.intern(); // Use string pool
                this.age = (short) age;
                this.flags = 0;
            }
            
            public void setFlag(int position, boolean value) {
                if (value) {
                    flags |= (1 << position);
                } else {
                    flags &= ~(1 << position);
                }
            }
            
            public boolean getFlag(int position) {
                return (flags & (1 << position)) != 0;
            }
            
            // Getters
            public String getName() { return name; }
            public int getAge() { return age; }
        }
    }
    
    public static void main(String[] args) {
        // Test object pooling
        String[] testStrings = {"Hello", "World", "Java", "Memory"};
        String result = ObjectPoolDemo.processStrings(testStrings);
        System.out.println("Pooled result: " + result);
        
        // Test flyweight pattern
        FlyweightDemo.demonstrateFlyweight();
        
        // Test efficient data structures
        EfficientDataStructures.demonstratePrimitiveCollections();
        
        // Test compact user
        EfficientDataStructures.CompactUser user = 
            new EfficientDataStructures.CompactUser("Anna", 25);
        user.setFlag(0, true);  // active
        user.setFlag(1, false); // not premium
        
        System.out.printf("User: %s, age: %d, active: %b%n",
            user.getName(), user.getAge(), user.getFlag(0));
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj własny object pool z automatycznym zarządzaniem rozmiarem.

**Zadanie Zaawansowane 2:** Stwórz memory profiler, który analizuje użycie różnych obszarów pamięci.

**Zadanie Zaawansowane 3:** Zaprojektuj cache-aware data structure, która optymalizuje locality of reference.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak działa String interning i kiedy go używać?
2. Jakie są różnice między Minor GC a Major GC?
3. Jak zoptymalizować aplikację pod kątem cache locality?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Pytania kontrolne:**
1. Zmienne lokalne są przechowywane na Stack w ramkach metod
2. Heap przechowuje obiekty i jest zarządzany przez GC, Metaspace przechowuje metadane klas i bytecode
3. StackOverflowError może spowodować zbyt głęboka rekursja lub zbyt duże zmienne lokalne

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. String interning przechowuje unikalne String literals w pool, używać dla często powtarzających się stringów
2. Minor GC czyści Young Generation (szybki), Major GC czyści Old Generation (wolniejszy)
3. Optymalizacja cache locality: grupowanie powiązanych danych, sekwencyjny dostęp, unikanie pointer chasing

---

*💡 Pamiętaj: Efektywne zarządzanie pamięcią to nie tylko unikanie memory leaks - to zrozumienie, jak JVM organizuje dane i jak z tego korzystać!*


## 22. Class Loading — jak JVM ładuje klasy i dlaczego to ważne

*Cześć! Dziś poznamy mechanizm, który sprawia, że Twój kod w ogóle może działać - Class Loading. To jak system logistyczny, który dostarcza "instrukcje obsługi" dla każdej klasy w odpowiednim momencie.*

---

### 🌱 Część dla Juniorek

#### Jak działa ładowanie klas?

```java
public class ClassLoadingBasics {
    static {
        System.out.println("ClassLoadingBasics class loaded!");
    }
    
    public static void demonstrateClassLoading() {
        System.out.println("Method called - class already loaded");
        
        // Lazy loading - klasa ładowana dopiero przy pierwszym użyciu
        try {
            Class<?> clazz = Class.forName("java.util.ArrayList");
            System.out.println("Loaded: " + clazz.getName());
        } catch (ClassNotFoundException e) {
            System.err.println("Class not found: " + e.getMessage());
        }
    }
    
    public static void main(String[] args) {
        demonstrateClassLoading();
    }
}
```

#### 💡 Wskazówki dla Juniorek
- Klasy są ładowane lazy - dopiero gdy są potrzebne
- Static bloki wykonują się przy ładowaniu klasy
- ClassNotFoundException = klasa nie została znaleziona w classpath

---

### 🚀 Część dla Seniorek

#### Hierarchia ClassLoaderów i delegation model

```java
public class ClassLoaderHierarchy {
    public static void analyzeClassLoaders() {
        ClassLoader current = ClassLoaderHierarchy.class.getClassLoader();
        
        while (current != null) {
            System.out.println("ClassLoader: " + current.getClass().getName());
            current = current.getParent();
        }
        System.out.println("Bootstrap ClassLoader (null)");
    }
    
    // Custom ClassLoader
    public static class CustomClassLoader extends ClassLoader {
        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            // Custom loading logic
            byte[] classData = loadClassData(name);
            return defineClass(name, classData, 0, classData.length);
        }
        
        private byte[] loadClassData(String name) {
            // Simplified - normally load from file/network
            return new byte[0];
        }
    }
}
```

---

## 23. Inline caching i inne triki JVM pod maską, volatile

*JVM to nie tylko interpreter - to zaawansowany system optymalizacji, który może sprawić, że Twój kod będzie szybszy niż C++!*

---

### 🌱 Część dla Juniorek

#### Co to jest volatile?

```java
public class VolatileDemo {
    private volatile boolean running = true;
    private int counter = 0;
    
    public void stopRunning() {
        running = false; // volatile zapewnia visibility
    }
    
    public void incrementCounter() {
        counter++; // NIE jest thread-safe mimo volatile running!
    }
    
    public static void main(String[] args) throws InterruptedException {
        VolatileDemo demo = new VolatileDemo();
        
        Thread worker = new Thread(() -> {
            while (demo.running) {
                demo.incrementCounter();
            }
            System.out.println("Worker stopped, counter: " + demo.counter);
        });
        
        worker.start();
        Thread.sleep(1000);
        demo.stopRunning();
        worker.join();
    }
}
```

#### 💡 Wskazówki dla Juniorek
- `volatile` zapewnia visibility między wątkami
- `volatile` NIE zapewnia atomicity
- Używaj `volatile` dla flag i prostych wartości

---

### 🚀 Część dla Seniorek

#### JIT Compiler i zaawansowane optymalizacje

```java
public class JITOptimizations {
    private static final int ITERATIONS = 100_000;
    
    // Method inlining
    private static int add(int a, int b) {
        return a + b; // Zostanie zinlinowane
    }
    
    // Loop optimization
    public static long optimizedLoop() {
        long sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += add(i, i * 2); // JIT zoptymalizuje
        }
        return sum;
    }
    
    // Escape analysis
    public static void escapeAnalysis() {
        for (int i = 0; i < ITERATIONS; i++) {
            Point p = new Point(i, i); // Może być stack-allocated!
            int dist = p.distance();
        }
    }
    
    private static class Point {
        int x, y;
        Point(int x, int y) { this.x = x; this.y = y; }
        int distance() { return x + y; }
    }
}
```

---

## 24. Java Memory Model (JMM) i zasady synchronizacji

*JMM definiuje reguły gry dla wielowątkowych aplikacji. To konstytucja świata concurrency w Javie!*

---

### 🌱 Część dla Juniorek

#### Podstawy synchronizacji

```java
public class SynchronizationBasics {
    private int counter = 0;
    private final Object lock = new Object();
    
    // Synchronized method
    public synchronized void incrementSync() {
        counter++;
    }
    
    // Synchronized block
    public void incrementBlock() {
        synchronized(lock) {
            counter++;
        }
    }
    
    public int getCounter() {
        return counter;
    }
}
```

---

### 🚀 Część dla Seniorek

#### Memory barriers i happens-before

```java
public class MemoryModelDemo {
    private volatile boolean flag = false;
    private int data = 0;
    
    // Writer thread
    public void writer() {
        data = 42;        // 1
        flag = true;      // 2 - volatile write
    }
    
    // Reader thread
    public void reader() {
        if (flag) {       // 3 - volatile read
            int value = data; // 4 - guaranteed to see 42
            System.out.println("Data: " + value);
        }
    }
    
    // Happens-before relationship: 1 -> 2 -> 3 -> 4
}
```

---

## 25. Wątki i synchronizacja: Thread, Runnable, synchronized

*Wielowątkowość to jak prowadzenie orkiestry - każdy muzyk gra swoją partię, ale wszystko musi grać razem!*

---

### 🌱 Część dla Juniorek

#### Podstawy wątków

```java
public class ThreadBasics {
    // Sposób 1: Extend Thread
    static class MyThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread: " + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
    
    // Sposób 2: Implement Runnable (lepszy)
    static class MyRunnable implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 5; i++) {
                System.out.println("Runnable: " + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        // Uruchomienie wątków
        MyThread thread1 = new MyThread();
        Thread thread2 = new Thread(new MyRunnable());
        
        thread1.start();
        thread2.start();
        
        // Czekanie na zakończenie
        thread1.join();
        thread2.join();
        
        System.out.println("All threads finished");
    }
}
```

---

### 🚀 Część dla Seniorek

#### Zaawansowana synchronizacja

```java
public class AdvancedSynchronization {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Map<String, String> cache = new HashMap<>();
    
    public String read(String key) {
        rwLock.readLock().lock();
        try {
            return cache.get(key);
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    public void write(String key, String value) {
        rwLock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            rwLock.writeLock().unlock();
        }
    }
    
    // Lock-free approach
    private final AtomicReference<String> atomicValue = new AtomicReference<>();
    
    public boolean compareAndSet(String expected, String update) {
        return atomicValue.compareAndSet(expected, update);
    }
}
```

---

## 26. Concurrency I: ExecutorService, czyli jak mieć pomocników

*ExecutorService to jak agencja pracy tymczasowej - zlecasz zadania, a oni się martwią o szczegóły!*

---

### 🌱 Część dla Juniorek

#### Podstawy ExecutorService

```java
public class ExecutorServiceBasics {
    public static void main(String[] args) throws InterruptedException {
        // Thread pool z 3 wątkami
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Zlecanie zadań
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " on " + 
                    Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        // Zamknięcie executor
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
    }
}
```

---

### 🚀 Część dla Seniorek

#### Zaawansowane wzorce z ExecutorService

```java
public class AdvancedExecutorPatterns {
    private final ExecutorService executor = Executors.newCachedThreadPool();
    
    // Producer-Consumer pattern
    public void producerConsumerPattern() {
        BlockingQueue<String> queue = new LinkedBlockingQueue<>();
        
        // Producer
        executor.submit(() -> {
            for (int i = 0; i < 100; i++) {
                try {
                    queue.put("Item " + i);
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        
        // Consumers
        for (int i = 0; i < 3; i++) {
            executor.submit(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        String item = queue.take();
                        System.out.println("Consumed: " + item);
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            });
        }
    }
}
```

---

## 27. Concurrency II: CompletableFuture, czyli zadania równoległe i przyszłość

*CompletableFuture to jak system rezerwacji - zamawiasz coś na przyszłość i możesz robić inne rzeczy, aż będzie gotowe!*

---

### 🌱 Część dla Juniorek

#### Podstawy CompletableFuture

```java
public class CompletableFutureBasics {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // Asynchroniczne zadanie
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000);
                return "Hello from future!";
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return "Interrupted";
            }
        });
        
        // Robienie innych rzeczy
        System.out.println("Doing other work...");
        
        // Pobranie wyniku
        String result = future.get();
        System.out.println("Result: " + result);
        
        // Łączenie zadań
        CompletableFuture<String> chainedFuture = CompletableFuture
            .supplyAsync(() -> "Hello")
            .thenApply(s -> s + " World")
            .thenApply(String::toUpperCase);
        
        System.out.println("Chained result: " + chainedFuture.get());
    }
}
```

---

### 🚀 Część dla Seniorek

#### Zaawansowane wzorce CompletableFuture

```java
public class AdvancedCompletableFuture {
    private final ExecutorService executor = ForkJoinPool.commonPool();
    
    // Parallel processing with combining
    public CompletableFuture<String> parallelProcessing() {
        CompletableFuture<String> future1 = CompletableFuture
            .supplyAsync(() -> fetchDataFromService1(), executor);
        
        CompletableFuture<String> future2 = CompletableFuture
            .supplyAsync(() -> fetchDataFromService2(), executor);
        
        CompletableFuture<Integer> future3 = CompletableFuture
            .supplyAsync(() -> calculateSomething(), executor);
        
        return future1.thenCombine(future2, (data1, data2) -> data1 + data2)
                     .thenCombine(future3, (combined, calc) -> 
                         combined + " (calculated: " + calc + ")");
    }
    
    // Error handling
    public CompletableFuture<String> withErrorHandling() {
        return CompletableFuture
            .supplyAsync(() -> {
                if (Math.random() > 0.5) {
                    throw new RuntimeException("Random failure");
                }
                return "Success";
            })
            .exceptionally(throwable -> "Fallback: " + throwable.getMessage())
            .thenApply(result -> "Final: " + result);
    }
    
    private String fetchDataFromService1() {
        try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        return "Data1";
    }
    
    private String fetchDataFromService2() {
        try { Thread.sleep(1500); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        return "Data2";
    }
    
    private Integer calculateSomething() {
        try { Thread.sleep(800); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        return 42;
    }
}
```

---

*💡 Pamiętaj: Concurrency to nie tylko o performance - to o responsywność i user experience. Dobrze zaprojektowana aplikacja wielowątkowa to jak dobrze zorganizowany zespół!*

