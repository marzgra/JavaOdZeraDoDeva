
# I. Podstawy Javy i Å›rodowiska uruchomieniowego

## 1. Zmienne, czyli szufladki na dane (w tym var â€” czy warto?)

*CzeÅ›Ä‡! Siadaj wygodnie z kawÄ…, bo dziÅ› rozmawiamy o zmiennych w Javie. To jeden z tych fundamentalnych tematÃ³w, ktÃ³re na poczÄ…tku mogÄ… wydawaÄ‡ siÄ™ oczywiste, ale kryjÄ… w sobie wiÄ™cej niuansÃ³w, niÅ¼ mogÅ‚oby siÄ™ wydawaÄ‡. ObiecujÄ™ Ci, Å¼e po tym rozdziale bÄ™dziesz wiedzieÄ‡ nie tylko jak deklarowaÄ‡ zmienne, ale teÅ¼ dlaczego Java jest tak rygorystyczna w tej kwestii!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest zmienna?

WyobraÅº sobie, Å¼e TwÃ³j kod to wielka szafa z szufladkami. KaÅ¼da szufladka ma swojÄ… etykietkÄ™ (nazwÄ™ zmiennej) i moÅ¼e przechowywaÄ‡ okreÅ›lony typ rzeczy (typ danych). Kiedy chcesz coÅ› schowaÄ‡ lub znaleÅºÄ‡, patrzysz na etykietkÄ™ i wiesz, czego siÄ™ spodziewaÄ‡.

W Javie zmienna to po prostu nazwane miejsce w pamiÄ™ci, gdzie moÅ¼esz przechowaÄ‡ dane. Ale uwaga - Java jest bardzo pedantyczna! Musisz z gÃ³ry powiedzieÄ‡, jakiego typu dane bÄ™dziesz tam trzymaÄ‡, i nie moÅ¼esz tego zmieniÄ‡ w trakcie dziaÅ‚ania programu.

```java
// Deklaracja zmiennej - mÃ³wisz Javie: "Przygotuj mi szufladkÄ™ na liczbÄ™ caÅ‚kowitÄ…"
int wiek;

// Inicjalizacja - wkÅ‚adasz coÅ› do szufladki
wiek = 25;

// MoÅ¼esz teÅ¼ zrobiÄ‡ to jednoczeÅ›nie
int wzrost = 165;
String imie = "Anna";
boolean czyProgramistka = true;
```

#### Dlaczego to waÅ¼ne?

Zmienne to podstawa kaÅ¼dego programu. Zmienne nadajÄ… nazwÄ™ Twoim danym i sprawiajÄ…, Å¼e kod staje siÄ™ czytelny i zrozumiaÅ‚y.

Dodatkowo, Java sprawdza w czasie kompilacji, czy uÅ¼ywasz zmiennych poprawnie. To znaczy, Å¼e jeÅ›li sprÃ³bujesz przypisaÄ‡ tekst do zmiennej liczbowej, kompilator CiÄ™ powstrzyma (tak na prawdÄ™ to najczÄ™Å›ciej juÅ¼ IDE wykryje tÄ™ nieprawidÅ‚owoÅ›Ä‡). ChoÄ‡ moÅ¼e wydawaÄ‡ siÄ™ to uciÄ…Å¼liwe, w rzeczywistoÅ›ci chroni CiÄ™ przed wieloma bÅ‚Ä™dami!

#### Jak to dziaÅ‚a w praktyce?

Zobaczmy rÃ³Å¼ne sposoby deklarowania zmiennych:

```java
public class ZmienneExample {
    // Zmienne instancji/obietu (pola klasy) - dostÄ™pne w caÅ‚ej klasie
    private String nazwisko = "Kowalska";
    private int rokUrodzenia;

    // Zmienne klasy/statyczne - dostÄ™p bez tworzenia instancji (np. Math.PI)
    public static final String START_VALUE = "Moja staÅ‚a";
    
    public void metodaExample() {
        // Zmienne lokalne - dostÄ™pne tylko w tej metodzie
        int aktualnyRok = 2024;
        int wiek = aktualnyRok - rokUrodzenia;
        
        // RÃ³Å¼ne typy zmiennych
        double pensja = 8500.50;
        char pierwszaLitera = 'A';
        boolean czyZatrudniona = true;
        
        // StaÅ‚e - wartoÅ›ci, ktÃ³re siÄ™ nie zmieniajÄ… - sÅ‚owo kluczowe final
        final double PI = 3.14159;
        final String NAZWA_FIRMY = "TechCorp";
        
        System.out.println("Wiek: " + wiek);
        System.out.println("Pensja: " + pensja);
    }
}
```

#### A co z tym sÅ‚ynnym `var`?

Od Javy 10 mamy nowe sÅ‚owo kluczowe `var`, ktÃ³re pozwala kompilatorowi samemu wydedukowaÄ‡ typ zmiennej. To jak powiedzenie: "Java, sama siÄ™ domyÅ›l, co tu powinno byÄ‡!".
Niby fajna sprawa, ale czasami moÅ¼e utrudniÄ‡ czytelnoÅ›Ä‡ kodu, gdy wynik metody jest przypisany do zmiennej var, a nazwa ani metody ani zmiennej nie wskazuje jednoznacznie na typ.

```java
// Zamiast pisaÄ‡:
String imie = "Katarzyna";
List<String> listaImion = new ArrayList<String>();

// MoÅ¼esz napisaÄ‡:
var imie = "Katarzyna";  // Java wie, Å¼e to String
var listaImion = new ArrayList<String>();  // Java wie, Å¼e to List<String>

// Ale uwaga! To nie zadziaÅ‚a:
var cos;  // BÅ‚Ä…d! Java nie wie, jakiego typu ma byÄ‡ 'cos'
var nic = null;  // BÅ‚Ä…d! Nie moÅ¼na wydedukowaÄ‡ typu z null
var result = getCalculationResult(a, b); // co tu siÄ™ kryje? dowiesz siÄ™ dopiero sprawdzajÄ…c sygnaturÄ™ metody Â¯\_(ãƒ„)_/Â¯
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **Nazywaj zmienne opisowo**: `wiek` zamiast `w`, `nazwiskoUzytkownika` zamiast `nu`
- **UÅ¼ywaj konwencji camelCase**: `pierwszeImie`, `dataUrodzenia`, `czyAktywny`
- **StaÅ‚e pisz WIELKIMI_LITERAMI**: `MAX_ROZMIAR`, `DOMYSLNA_WARTOSC`
- **Inicjalizuj zmienne**: Nie zostawiaj zmiennych bez wartoÅ›ci, jeÅ›li nie musisz
- **`var` uÅ¼ywaj ostroÅ¼nie**: Tylko wtedy, gdy typ jest oczywisty z kontekstu

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** StwÃ³rz klasÄ™ `Osoba` z polami opisujÄ…cymi osobÄ™ (imiÄ™, nazwisko, wiek, miasto). UÅ¼yj odpowiednich typÃ³w danych.

```java
public class Osoba {
    // UzupeÅ‚nij pola klasy
    
    public void przedstawSie() {
        // Wypisz informacje o osobie
    }
}
```

**Zadanie 2:** Napisz metodÄ™, ktÃ³ra obliczy BMI na podstawie wzrostu i wagi. UÅ¼yj zmiennych lokalnych do przechowania wynikÃ³w poÅ›rednich.

**Zadanie 3:** Eksperymentuj z `var`. StwÃ³rz kilka zmiennych uÅ¼ywajÄ…c `var` i sprawdÅº, jakie typy Java im przypisze. SprÃ³buj teÅ¼ sytuacji, gdzie `var` nie zadziaÅ‚a.

#### â“ Pytania Kontrolne - Poziom Junior

1. Jaka jest rÃ³Å¼nica miÄ™dzy deklaracjÄ… a inicjalizacjÄ… zmiennej?
2. Dlaczego nie moÅ¼na zmieniÄ‡ typu zmiennej po jej deklaracji?
3. Kiedy warto uÅ¼ywaÄ‡ `var`, a kiedy lepiej jawnie okreÅ›liÄ‡ typ?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

Zmienne w Javie to znacznie wiÄ™cej niÅ¼ tylko "szufladki na dane". To fundamentalny element systemu typÃ³w Javy, ktÃ³ry wpÅ‚ywa na bezpieczeÅ„stwo, wydajnoÅ›Ä‡ i czytelnoÅ›Ä‡ kodu. Przyjrzyjmy siÄ™ temu z perspektywy architektury jÄ™zyka.

Java implementuje statyczny system typÃ³w z silnym typowaniem. Oznacza to, Å¼e kaÅ¼da zmienna ma okreÅ›lony typ w czasie kompilacji, a kompilator sprawdza zgodnoÅ›Ä‡ typÃ³w. To podejÅ›cie eliminuje caÅ‚Ä… klasÄ™ bÅ‚Ä™dÃ³w runtime'owych zwiÄ…zanych z nieprawidÅ‚owym uÅ¼yciem typÃ³w.

```java
public class ZaawansowaneZmienne {
    // Zmienne instancji vs zmienne klasowe
    private static final String WERSJA = "1.0";  // zmienna klasowa
    private String nazwa;  // zmienna instancji
    
    // RÃ³Å¼ne poziomy dostÄ™pu
    public String publicznaZmienna;
    protected String chronionaZmienna;
    String pakietowaZmienna;  // package-private
    private String prywatnaZmienna;
    
    public void demonstracjaZasiegow() {
        // Zmienne lokalne przesÅ‚aniajÄ… pola klasy
        String nazwa = "lokalna";  // przesÅ‚ania pole 'nazwa'
        System.out.println(nazwa);  // wypisze "lokalna"
        System.out.println(this.nazwa);  // wypisze wartoÅ›Ä‡ pola
        
        // ZasiÄ™g zmiennych w blokach
        if (true) {
            int lokalnaWBloku = 42;
            // lokalnaWBloku jest dostÄ™pna tylko w tym bloku
        }
        // lokalnaWBloku nie jest juÅ¼ dostÄ™pna
        
        // Zmienne w pÄ™tlach
        for (int i = 0; i < 10; i++) {
            // 'i' jest dostÄ™pne tylko w tej pÄ™tli
        }
        // 'i' nie jest juÅ¼ dostÄ™pne
    }
}
```

#### PuÅ‚apki i niuanse

##### Problem z `var` i czytelnoÅ›Ä‡ kodu

ChociaÅ¼ `var` moÅ¼e uproÅ›ciÄ‡ kod, moÅ¼e teÅ¼ go zaciemniÄ‡. RozwaÅ¼my przykÅ‚ady:

```java
// Dobry przykÅ‚ad uÅ¼ycia var - typ jest oczywisty
var lista = new ArrayList<String>();
var mapa = new HashMap<String, Integer>();
var plik = new File("dane.txt");

// Problematyczny przykÅ‚ad - typ nie jest oczywisty
var wynik = obliczCosTrudnego();  // Jaki typ zwraca ta metoda?
var dane = pobierzDane();  // Co to za dane?

// SzczegÃ³lnie problematyczne z metodami generycznymi
var stream = lista.stream()
    .filter(s -> s.length() > 5)
    .map(String::toUpperCase);  // Jaki to typ? Stream<String>? Ale nie jest to oczywiste
```

##### WpÅ‚yw na refaktoryzacjÄ™

`var` moÅ¼e utrudniÄ‡ refaktoryzacjÄ™ kodu:

```java
// Przed refaktoryzacjÄ…
var lista = pobierzListeStringow();  // zwraca List<String>

// Po zmianie metody na zwracanie Set<String>
var lista = pobierzListeStringow();  // teraz zwraca Set<String>
// Kod dalej siÄ™ kompiluje, ale semantyka siÄ™ zmieniÅ‚a!
```

##### WydajnoÅ›Ä‡ i optymalizacje

Kompilator Java wykonuje wiele optymalizacji na podstawie informacji o typach:

```java
public class OptymalizacjeZmiennych {
    // Zmienne final mogÄ… byÄ‡ optymalizowane
    private final int STALA = 42;
    
    // Kompilator moÅ¼e wstawiÄ‡ wartoÅ›Ä‡ bezpoÅ›rednio
    public int pobierzStala() {
        return STALA;  // MoÅ¼e byÄ‡ zastÄ…pione przez 'return 42;'
    }
    
    // Zmienne lokalne final rÃ³wnieÅ¼ mogÄ… zostaÄ‡ zoptymalizowane
    public void metoda() {
        final int lokalnaStala = 100;
        // Kompilator wie, Å¼e ta wartoÅ›Ä‡ siÄ™ nie zmieni
        for (int i = 0; i < lokalnaStala; i++) {
            // Optymalizacje pÄ™tli
        }
    }
}
```

#### Wzorce i best practices

##### Wzorzec Immutable Objects

**Niemutowalny obiekt w Javie**Â (ang.Â _immutable object_) to taki obiekt, ktÃ³rego stan (wartoÅ›ci pÃ³l)Â **nie moÅ¼e zostaÄ‡ zmieniony po jego utworzeniu**. Oznacza to, Å¼eÂ **wszystkie pola sÄ… ustawiane raz â€“ w konstruktorze â€“ i nie mogÄ… byÄ‡ pÃ³Åºniej zmodyfikowane**.

### Techniczna definicja niemutowalnego obiektu w Javie:

Obiekt jest uznawany za niemutowalny, jeÅ›li speÅ‚nia wszystkie poniÅ¼sze warunki:
1. **Klasa jest oznaczona jakoÂ `final`**, aby nie moÅ¼na byÅ‚o jej rozszerzyÄ‡ i nadpisaÄ‡ jej zachowania.
2. **Wszystkie pola sÄ…Â `private`Â iÂ `final`**, czyli przypisywane tylko raz.
3. **Nie zapewnia setterÃ³w**, czyli metod umoÅ¼liwiajÄ…cych zmianÄ™ stanu obiektu po jego utworzeniu.
4. **Nie udostÄ™pnia bezpoÅ›redniego dostÄ™pu do pÃ³l referencyjnych**, zwÅ‚aszcza modyfikowalnych (np. kolekcji), chyba Å¼e poprzez defensywnÄ… kopiÄ™ (_defensive copy_).
5. **Konstruktor inicjalizuje wszystkie pola obiektu**, a ich wartoÅ›ci nie mogÄ… byÄ‡ pÃ³Åºniej zmienione. 
6. 

```java
public final class ImmutablePerson {
    private final String imie;
    private final String nazwisko;
    private final int wiek;
    private final Date dataUrodzenia;
    
    public ImmutablePerson(String imie, String nazwisko, int wiek, Date dataUrodzenia) {
        this.imie = Objects.requireNonNull(imie);
        this.nazwisko = Objects.requireNonNull(nazwisko);
        this.wiek = wiek;
        this.dataUrodzenia = dataUrodzenia;
    }
    
    // Tylko gettery, brak setterÃ³w
    public String getImie() { return imie; }
    public String getNazwisko() { return nazwisko; }
    public int getWiek() { return wiek; }
    public Date getDataUrodzenia() { return new Date(dataUrodzenia.getTime()); } // kopia defensywna
    
    
    // Metody zwracajÄ…ce nowe instancje zamiast modyfikacji
    public ImmutablePerson withWiek(int nowyWiek) {
        return new ImmutablePerson(this.imie, this.nazwisko, nowyWiek);
    }
}
```

##### Wzorzec Builder z var

```java
public class PersonBuilder {
    private String imie;
    private String nazwisko;
    private int wiek;
    
    public PersonBuilder imie(String imie) {
        this.imie = imie;
        return this;
    }
    
    public PersonBuilder nazwisko(String nazwisko) {
        this.nazwisko = nazwisko;
        return this;
    }
    
    public PersonBuilder wiek(int wiek) {
        this.wiek = wiek;
        return this;
    }
    
    public ImmutablePerson build() {
        return new ImmutablePerson(imie, nazwisko, wiek);
    }
}

// UÅ¼ycie z var
var osoba = new PersonBuilder()
    .imie("Anna")
    .nazwisko("Kowalska")
    .wiek(30)
    .build();
```

#### ğŸ”§ Zadania dla Seniorek

##### Zadanie Zaawansowane 1: Wyciek stanu przez referencjÄ™ mutowalnÄ… (`Date`)

**ğŸ§  Kontekst**

PoniÅ¼ej znajdziesz dwie wersje klasyÂ `Spotkanie`. Obie przechowujÄ… datÄ™ spotkania, ale tylko jedna robi to poprawnie. Twoim zadaniem bÄ™dzie:
	1. WskazaÄ‡,Â **ktÃ³ra wersja jest podatna na wyciek stanu**.
	2. **WyjaÅ›niÄ‡, na czym polega problem**Â iÂ **jakie ma konsekwencje**.
	3. ZaproponowaÄ‡ poprawkÄ™ lub lepszÄ… konstrukcjÄ™.
    

**ğŸ“„ Wersja A **

```java
public class Spotkanie {
	private final Date data;
	
	public Spotkanie(Date data) {
		this.data = data;     
	}  
	    
	public Date getData() {
		return data;     
	} 
}
```

 **ğŸ“„ Wersja B **

```java
public class Spotkanie {     
	private final Date data;      
	
	public Spotkanie(Date data) {         
		this.data = new Date(data.getTime());   
	}      
	
	public Date getData() {         
		return new Date(data.getTime());   
	}
}
```


##### Zadanie Zaawansowane 2: NiemutowalnoÅ›Ä‡ i kopia defensywna
**Cel:**Â Zrozumienie ideiÂ _immutable objects_Â i defensywnego kopiowania.
Masz klasÄ™Â `ImmutableSpotkanie`, ktÃ³ra przechowuje datÄ™ spotkania (`java.util.Date`).
- Zaimplementuj klasÄ™ speÅ‚niajÄ…cÄ… wszystkie warunki niemutowalnoÅ›ci.
- Upewnij siÄ™, Å¼eÂ `getData()`Â zwracaÂ _defensywnÄ… kopiÄ™_.


#### â“ Pytania Kontrolne - Poziom Senior

1. Jak wpÅ‚ywa uÅ¼ycie `var` na proces kompilacji i czy ma jakikolwiek wpÅ‚yw na wydajnoÅ›Ä‡ runtime?
2. Jakie sÄ… implikacje uÅ¼ywania zmiennych final w kontekÅ›cie optymalizacji JVM?
3. Jak zmienne lokalne sÄ… przechowywane w pamiÄ™ci i dlaczego nie mogÄ… byÄ‡ dostÄ™pne poza swoim zasiÄ™giem?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public class Osoba {
    private String imie;
    private String nazwisko;
    private int wiek;
    private String miasto;
    
    public Osoba(String imie, String nazwisko, int wiek, String miasto) {
        this.imie = imie;
        this.nazwisko = nazwisko;
        this.wiek = wiek;
        this.miasto = miasto;
    }
    
    public void przedstawSie() {
        System.out.println("CzeÅ›Ä‡! Jestem " + imie + " " + nazwisko + 
                          ", mam " + wiek + " lat i mieszkam w " + miasto + ".");
    }
}
```

**Zadanie 2:**
```java
public double obliczBMI(double wzrost, double waga) {
    double wzrostWMetrach = wzrost / 100.0;  // konwersja cm na m
    double bmi = waga / (wzrostWMetrach * wzrostWMetrach);
    return Math.round(bmi * 100.0) / 100.0;  // zaokrÄ…glenie do 2 miejsc
}
```

**Zadanie 3:**
```java
var tekst = "Hello";  // String
var liczba = 42;  // int
var lista = new ArrayList<String>();  // ArrayList<String>
var mapa = Map.of("klucz", "wartoÅ›Ä‡");  // Map<String, String>

// Te nie zadziaÅ‚ajÄ…:
// var nic;  // BÅ‚Ä…d kompilacji
// var nullValue = null;  // BÅ‚Ä…d kompilacji
```

**Pytania kontrolne:**
1. **Deklaracja** to okreÅ›lenie nazwy i typu zmiennej (`int wiek;`), **inicjalizacja** to przypisanie pierwszej wartoÅ›ci (`wiek = 25;`).
2. Java ma statyczny system typÃ³w - typ jest sprawdzany w czasie kompilacji i nie moÅ¼e siÄ™ zmieniÄ‡, co zapewnia bezpieczeÅ„stwo typÃ³w.
3. `var` warto uÅ¼ywaÄ‡, gdy typ jest oczywisty z kontekstu. Unikaj, gdy typ nie jest jasny lub gdy jawne okreÅ›lenie typu poprawia czytelnoÅ›Ä‡.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
Wersja A jest podatna na wyciek stanu.**
W wersji A obiektÂ `Date`Â jest przypisywany bezpoÅ›rednio do prywatnego polaÂ `data`Â i jest zwracany przez getter bez Å¼adnej ochrony.Â `Date`Â to klasa mutowalna â€” to znaczy, Å¼e stan obiektuÂ `Date`Â moÅ¼na zmieniaÄ‡ po jego utworzeniu (np. zmieniajÄ…c godzinÄ™, dzieÅ„ itp.).

**Konsekwencje**:
- Klient, ktÃ³ry otrzyma referencjÄ™ do obiektuÂ `Date`Â przez metodÄ™Â `getData()`, moÅ¼e zmodyfikowaÄ‡ ten obiekt.
- Modyfikacja zwrÃ³conej daty skutkuje zmianÄ… stanu obiektuÂ `Spotkanie`Â _od zewnÄ…trz_, czyli dochodzi do wycieku stanu (state leak).
- To narusza enkapsulacjÄ™ i niemutowalnoÅ›Ä‡ klasy, co moÅ¼e prowadziÄ‡ do nieprzewidywalnych bÅ‚Ä™dÃ³w, zwÅ‚aszcza w kontekÅ›cie wielowÄ…tkowoÅ›ci czy logiki biznesowej, ktÃ³ra zakÅ‚ada, Å¼e data spotkania siÄ™ nie zmieni.

**Propozycja poprawki lub lepsza konstrukcja**
Wersja B stosuje tzw.Â **defensywnÄ… kopiÄ™**Â â€” zamiast przechowywaÄ‡ i udostÄ™pniaÄ‡ oryginalny obiektÂ `Date`, tworzy jego nowÄ… instancjÄ™ kopiujÄ…c czas z oryginaÅ‚u.
- Konstruktor tworzy nowÄ… kopiÄ™Â `Date`, wiÄ™c nawet jeÅ›li obiekt przekazany do konstruktora zostanie zmieniony po utworzeniuÂ `Spotkanie`, wewnÄ™trzny stan klasy pozostanie niezmieniony.
- Getter zwraca nowÄ… kopiÄ™Â `Date`, wiÄ™c klient nie moÅ¼e zmieniÄ‡ wewnÄ™trznego stanuÂ `Spotkanie`Â przez manipulacjÄ™ zwrÃ³conym obiektem.

**Alternatywne rozwiÄ…zanie (bardziej nowoczesne i odporne):**
- UÅ¼yÄ‡ klas niemutowalnych do reprezentacji dat, np.Â `java.time.LocalDateTime`Â lubÂ `java.time.Instant`Â z pakietuÂ `java.time`Â (Java 8+).
- Klasy zÂ `java.time`Â sÄ… niezmiennicze (immutable), wiÄ™c nie wymagajÄ… defensywnych kopii i eliminujÄ… ryzyko wycieku stanu.

**Zadanie Zaawansowane 2:**
```java
import java.util.Date;

public final class ImmutableSpotkanie {
    private final Date data; // lub po prostu uÅ¼ycie LocalDate

    public ImmutableSpotkanie(Date data) {
        if (data == null) {
            throw new IllegalArgumentException("Data spotkania nie moÅ¼e byÄ‡ nullem");
        }
        // defensywna kopia w konstruktorze
        this.data = new Date(data.getTime());
    }

    // zwraca defensywnÄ… kopiÄ™, by zapobiec wyciekowi stanu
    public Date getData() {
        return new Date(this.data.getTime());
    }

    // brak setterÃ³w â€“ klasa jest niemutowalna
}
```

**Pytania kontrolne:**
1. `var` to tylko syntactic sugar - kompilator zastÄ™puje go rzeczywistym typem, wiÄ™c nie ma wpÅ‚ywu na runtime ani wydajnoÅ›Ä‡.
2. Zmienne final mogÄ… byÄ‡ optymalizowane przez kompilator (inlining) i JVM (escape analysis, constant folding).
3. Zmienne lokalne sÄ… przechowywane na stosie (stack) w ramce metody. Gdy metoda koÅ„czy dziaÅ‚anie, ramka jest usuwana, dlatego zmienne lokalne nie sÄ… dostÄ™pne poza zasiÄ™giem.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Mam nadziejÄ™, Å¼e ten rozdziaÅ‚ byÅ‚ dla Ciebie pomocny. Zmienne to fundament, na ktÃ³rym budujesz caÅ‚Ä… resztÄ™ swojej wiedzy o Javie. W nastÄ™pnym rozdziale porozmawiamy o typach prymitywnych vs referencyjnych - czyli o tym, jak Java przechowuje rÃ³Å¼ne rodzaje danych i dlaczego czasami "kopiuj-wklej" dziaÅ‚a inaczej niÅ¼ byÅ›my chciaÅ‚y!*

---

*ğŸ’¡ PamiÄ™taj: Nie ma gÅ‚upich pytaÅ„, sÄ… tylko nieodpowiedziane! JeÅ›li coÅ› nie jest jasne, wrÃ³Ä‡ do tego rozdziaÅ‚u lub poszukaj dodatkowych przykÅ‚adÃ³w w internecie.*



## 2. Typy prymitywne vs referencyjne (czyli â€zrÃ³b mi kopiuj-wklej... albo i nie")

*CzeÅ›Ä‡ ponownie! DziÅ› mamy przed sobÄ… jeden z tych tematÃ³w, ktÃ³re na poczÄ…tku wydajÄ… siÄ™ proste, ale potem okazuje siÄ™, Å¼e kryjÄ… w sobie prawdziwe miny. Typy prymitywne vs referencyjne to podstawa zrozumienia, jak Java zarzÄ…dza pamiÄ™ciÄ… i dlaczego czasami TwÃ³j kod zachowuje siÄ™ inaczej niÅ¼ oczekujesz. Przygotuj siÄ™ na kilka "aha!" momentÃ³w!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

W Javie mamy dwa gÅ‚Ã³wne sposoby przechowywania danych:

1. **Typy prymitywne** - to jak maÅ‚e pudeÅ‚eczka, ktÃ³re przechowujÄ… konkretnÄ… wartoÅ›Ä‡ bezpoÅ›rednio
2. **Typy referencyjne** - to jak karteczki z adresem, gdzie prawdziwe dane sÄ… przechowywane gdzie indziej

WyobraÅº sobie, Å¼e masz dwie szuflady:
- W pierwszej trzymasz bezpoÅ›rednio monety (typy prymitywne)
- W drugiej trzymasz karteczki z adresami skarbcÃ³w, gdzie leÅ¼Ä… prawdziwe skarby (typy referencyjne)

```java
// Typy prymitywne - wartoÅ›Ä‡ jest przechowywana bezpoÅ›rednio
int wiek = 25;           // pudeÅ‚ko zawiera liczbÄ™ 25
double wzrost = 165.5;   // pudeÅ‚ko zawiera liczbÄ™ 165.5
boolean czyAktywna = true; // pudeÅ‚ko zawiera wartoÅ›Ä‡ true
char pierwszaLitera = 'A'; // pudeÅ‚ko zawiera znak 'A'

// Typy referencyjne - zmienna zawiera "adres" do obiektu
String imie = "Anna";    // zmienna zawiera adres do obiektu String
List<String> lista = new ArrayList<>(); // adres do obiektu ArrayList
Person osoba = new Person(); // adres do obiektu Person
```

#### Dlaczego to waÅ¼ne?

Ta rÃ³Å¼nica ma ogromne znaczenie dla tego, jak TwÃ³j kod siÄ™ zachowuje, szczegÃ³lnie gdy kopiujesz zmienne lub przekazujesz je do metod. To jak rÃ³Å¼nica miÄ™dzy kopiowaniem monety (masz dwie identyczne monety) a kopiowaniem adresu (masz dwie karteczki wskazujÄ…ce na ten sam skarb).

```java
// Kopiowanie typÃ³w prymitywnych
int a = 10;
int b = a;  // b dostaje kopiÄ™ wartoÅ›ci z a
a = 20;     // zmiana a nie wpÅ‚ywa na b
System.out.println(b); // wypisze 10

// Kopiowanie typÃ³w referencyjnych
List<String> lista1 = new ArrayList<>();
lista1.add("Java");
List<String> lista2 = lista1;  // lista2 dostaje kopiÄ™ ADRESU, nie zawartoÅ›ci!
lista1.add("Python");
System.out.println(lista2.size()); // wypisze 2! Obie zmienne wskazujÄ… na tÄ™ samÄ… listÄ™
```

#### Jak to dziaÅ‚a w praktyce?

Oto wszystkie typy prymitywne w Javie:

```java
public class TypyPrymitywne {
    // Liczby caÅ‚kowite
    byte maleLiczby = 127;        // -128 do 127
    short sredneLiczby = 32000;   // -32,768 do 32,767
    int normaleLiczby = 2000000;  // -2^31 do 2^31-1
    long duzeLiczby = 9000000000L; // -2^63 do 2^63-1 (uwaga na 'L'!)
    
    // Liczby zmiennoprzecinkowe
    float precyzja = 3.14f;       // 32-bitowa (uwaga na 'f'!)
    double podwojnaPrecyzja = 3.14159; // 64-bitowa (domyÅ›lna dla liczb z kropkÄ…)
    
    // Inne
    char znak = 'A';              // pojedynczy znak Unicode
    boolean prawdaFalsz = true;   // true lub false
}
```

A teraz przykÅ‚ady typÃ³w referencyjnych:

```java
public class TypyReferencyjne {
    // Wszystkie klasy to typy referencyjne
    String tekst = "Hello World";
    StringBuilder builder = new StringBuilder();
    List<Integer> liczby = new ArrayList<>();
    Map<String, String> mapa = new HashMap<>();
    
    // Twoje wÅ‚asne klasy teÅ¼
    Person osoba = new Person();
    Car samochod = new Car();
    
    // Tablice teÅ¼ sÄ… typami referencyjnymi!
    int[] tablicaLiczb = {1, 2, 3, 4, 5};
    String[] tablicaStringow = {"Java", "Python", "JavaScript"};
}
```

#### PuÅ‚apki, na ktÃ³re warto uwaÅ¼aÄ‡

**PuÅ‚apka 1: Przekazywanie do metod**

```java
public class PrzekazywaniePrametrow {
    public static void zmienPrymityw(int liczba) {
        liczba = 100;  // zmienia tylko lokalnÄ… kopiÄ™
    }
    
    public static void zmienObiekt(List<String> lista) {
        lista.add("Nowy element");  // zmienia oryginalnÄ… listÄ™!
    }
    
    public static void zmienReferencje(List<String> lista) {
        lista = new ArrayList<>();  // tworzy nowÄ… listÄ™, ale nie wpÅ‚ywa na oryginalnÄ…
        lista.add("To nie wpÅ‚ynie na oryginaÅ‚");
    }
    
    public static void main(String[] args) {
        int x = 10;
        zmienPrymityw(x);
        System.out.println(x); // wypisze 10 (bez zmian)
        
        List<String> mojaLista = new ArrayList<>();
        mojaLista.add("Pierwszy");
        zmienObiekt(mojaLista);
        System.out.println(mojaLista.size()); // wypisze 2
        
        zmienReferencje(mojaLista);
        System.out.println(mojaLista.size()); // nadal 2
    }
}
```

**PuÅ‚apka 2: PorÃ³wnywanie**

```java
// Typy prymitywne - porÃ³wnujemy wartoÅ›ci
int a = 5;
int b = 5;
System.out.println(a == b); // true

// Typy referencyjne - porÃ³wnujemy adresy!
String s1 = new String("Hello");
String s2 = new String("Hello");
System.out.println(s1 == s2);     // false! (rÃ³Å¼ne obiekty)
System.out.println(s1.equals(s2)); // true (ta sama zawartoÅ›Ä‡)

// WyjÄ…tek: String literals
String s3 = "Hello";
String s4 = "Hello";
System.out.println(s3 == s4); // true (Java optymalizuje i uÅ¼ywa tego samego obiektu)
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **UÅ¼ywaj `equals()` do porÃ³wnywania obiektÃ³w**, nie `==`
- **PamiÄ™taj o `null`** - typy prymitywne nie mogÄ… byÄ‡ null, referencyjne mogÄ…
- **UwaÅ¼aj na modyfikacje list i map** przekazanych do metod
- **Inicjalizuj obiekty** przed uÅ¼yciem (`new ArrayList<>()`, nie tylko deklaracja)
- **Tablice to teÅ¼ obiekty** - zachowujÄ… siÄ™ jak typy referencyjne

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** Napisz metodÄ™, ktÃ³ra przyjmuje listÄ™ liczb i dodaje do niej nowÄ… liczbÄ™. SprawdÅº, czy oryginalna lista siÄ™ zmienia.

```java
public static void dodajLiczbe(List<Integer> lista, int liczba) {
    // Twoja implementacja
}
```

**Zadanie 2:** StwÃ³rz klasÄ™ `Punkt` z polami x i y. Napisz metodÄ™, ktÃ³ra przyjmuje punkt i zmienia jego wspÃ³Å‚rzÄ™dne. SprawdÅº, czy oryginalny punkt siÄ™ zmienia.

**Zadanie 3:** Eksperymentuj z porÃ³wnywaniem StringÃ³w. StwÃ³rz Stringi na rÃ³Å¼ne sposoby i sprawdÅº, kiedy `==` zwraca true, a kiedy false.

#### â“ Pytania Kontrolne - Poziom Junior

1. Dlaczego zmiana listy w metodzie wpÅ‚ywa na oryginalnÄ… listÄ™, ale zmiana int nie wpÅ‚ywa na oryginalnÄ… zmiennÄ…?
2. Jaka jest rÃ³Å¼nica miÄ™dzy `==` a `equals()` dla obiektÃ³w?
3. Czy tablica int[] to typ prymitywny czy referencyjny?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

RÃ³Å¼nica miÄ™dzy typami prymitywnymi a referencyjnymi w Javie wynika z fundamentalnej architektury JVM i sposobu zarzÄ…dzania pamiÄ™ciÄ…. Ta decyzja projektowa ma daleko idÄ…ce konsekwencje dla wydajnoÅ›ci, bezpieczeÅ„stwa i semantyki jÄ™zyka.

##### Architektura pamiÄ™ci JVM

```java
public class ArchitekturapamiEci {
    // Zmienne statyczne - w Metaspace (Java 8+) lub Method Area
    private static final String STALA = "WartoÅ›Ä‡ staÅ‚a";
    
    // Pola instancji - w Heap
    private int poleInstancji = 42;
    private List<String> listaInstancji = new ArrayList<>();
    
    public void demonstracjaStosui() {
        // Zmienne lokalne prymitywne - na Stack
        int lokalnaLiczba = 100;
        boolean lokalnaFlaga = true;
        
        // Zmienne lokalne referencyjne - referencja na Stack, obiekt w Heap
        String lokalnyString = "Hello";  // referencja na Stack, obiekt w Heap
        List<Integer> lokalnaLista = new ArrayList<>();  // referencja na Stack, obiekt w Heap
        
        // Parametry metod teÅ¼ sÄ… na Stack
        metodaZParametrami(lokalnaLiczba, lokalnyString);
    }
    
    private void metodaZParametrami(int parametrPrymitywny, String parametrReferencyjny) {
        // Oba parametry sÄ… na Stack tej metody
        // parametrPrymitywny to kopia wartoÅ›ci
        // parametrReferencyjny to kopia referencji (adresu)
    }
}
```

##### Implikacje wydajnoÅ›ciowe

Typy prymitywne sÄ… znacznie szybsze w dostÄ™pie i zajmujÄ… mniej pamiÄ™ci:

```java
public class WydajnoscTypow {
    // PorÃ³wnanie zuÅ¼ycia pamiÄ™ci
    private int[] prymitywne = new int[1000000];        // ~4MB
    private Integer[] opakowane = new Integer[1000000]; // ~16MB + overhead obiektÃ³w
    
    // Benchmark dostÄ™pu
    public long sumaPrymitywnych(int[] tablica) {
        long suma = 0;
        for (int i = 0; i < tablica.length; i++) {
            suma += tablica[i];  // bezpoÅ›redni dostÄ™p do wartoÅ›ci
        }
        return suma;
    }
    
    public long sumaOpakowanych(Integer[] tablica) {
        long suma = 0;
        for (int i = 0; i < tablica.length; i++) {
            suma += tablica[i];  // wymaga dereferencji + unboxing
        }
        return suma;
    }
}
```

##### Semantyka kopiowania i przekazywania

Java zawsze przekazuje parametry przez wartoÅ›Ä‡, ale interpretacja "wartoÅ›ci" rÃ³Å¼ni siÄ™:

```java
public class SemantykaPrzekazywania {
    public static void modyfikujPrymityw(int x) {
        x = 999;  // modyfikuje lokalnÄ… kopiÄ™
    }
    
    public static void modyfikujObiekt(StringBuilder sb) {
        sb.append(" - zmodyfikowany");  // modyfikuje obiekt wskazywany przez kopiÄ™ referencji
    }
    
    public static void zastapObiekt(StringBuilder sb) {
        sb = new StringBuilder("Nowy obiekt");  // zmienia lokalnÄ… kopiÄ™ referencji
    }
    
    public static void demonstracja() {
        int liczba = 42;
        modyfikujPrymityw(liczba);
        System.out.println(liczba);  // 42 - bez zmian
        
        StringBuilder builder = new StringBuilder("Oryginalny");
        modyfikujObiekt(builder);
        System.out.println(builder);  // "Oryginalny - zmodyfikowany"
        
        zastapObiekt(builder);
        System.out.println(builder);  // "Oryginalny - zmodyfikowany" - bez zmian
    }
}
```

#### PuÅ‚apki i niuanse

##### Problem z autoboxing/unboxing

```java
public class PulapkiAutoboxing {
    // PuÅ‚apka 1: PorÃ³wnywanie Integer
    public void porownywaniePulapka() {
        Integer a = 127;
        Integer b = 127;
        System.out.println(a == b);  // true (cache dla -128 do 127)
        
        Integer c = 128;
        Integer d = 128;
        System.out.println(c == d);  // false! (poza cache)
        
        // Bezpieczne porÃ³wnywanie
        System.out.println(Objects.equals(c, d));  // true
    }
    
    // PuÅ‚apka 2: NullPointerException przy unboxing
    public void nullPointerPulapka() {
        Integer nullInteger = null;
        int prymityw = nullInteger;  // NPE! Nie moÅ¼na unboxowaÄ‡ null
    }
    
    // PuÅ‚apka 3: WydajnoÅ›Ä‡ w pÄ™tlach
    public void wydajnoscPulapka() {
        Integer suma = 0;  // Å¹le! KaÅ¼da iteracja tworzy nowy obiekt
        for (int i = 0; i < 1000000; i++) {
            suma += i;  // boxing/unboxing w kaÅ¼dej iteracji
        }
        
        int sumaPoprawnie = 0;  // Dobrze!
        for (int i = 0; i < 1000000; i++) {
            sumaPoprawnie += i;  // tylko prymitywy
        }
    }
}
```

##### Immutability i aliasing

```java
public class ImmutabilityAliasing {
    // String jest immutable
    public void stringImmutability() {
        String s1 = "Hello";
        String s2 = s1;
        s1 = s1 + " World";  // tworzy NOWY obiekt, s2 pozostaje niezmienione
        System.out.println(s2);  // "Hello"
    }
    
    // Ale uwaga na mutable obiekty!
    public void mutableAliasing() {
        List<String> lista1 = new ArrayList<>();
        lista1.add("Element");
        
        List<String> lista2 = lista1;  // aliasing!
        lista2.add("Drugi element");
        
        System.out.println(lista1.size());  // 2! Obie zmienne wskazujÄ… na tÄ™ samÄ… listÄ™
    }
    
    // Defensive copying
    public List<String> bezpiecznaKopia(List<String> oryginalna) {
        return new ArrayList<>(oryginalna);  // tworzy nowÄ… listÄ™ z tÄ… samÄ… zawartoÅ›ciÄ…
    }
}
```

#### Wzorce i best practices

##### Wzorzec Value Object

```java
public final class Money {
    private final BigDecimal amount;
    private final Currency currency;
    
    public Money(BigDecimal amount, Currency currency) {
        this.amount = Objects.requireNonNull(amount);
        this.currency = Objects.requireNonNull(currency);
    }
    
    // Immutable - metody zwracajÄ… nowe instancje
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot add different currencies");
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }
    
    public Money multiply(BigDecimal factor) {
        return new Money(this.amount.multiply(factor), this.currency);
    }
    
    // Proper equals and hashCode
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Money)) return false;
        Money money = (Money) obj;
        return Objects.equals(amount, money.amount) && 
               Objects.equals(currency, money.currency);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(amount, currency);
    }
}
```

##### Wzorzec Builder z defensive copying

```java
public final class ImmutablePerson {
    private final String name;
    private final List<String> hobbies;
    private final Map<String, String> attributes;
    
    private ImmutablePerson(Builder builder) {
        this.name = Objects.requireNonNull(builder.name);
        // Defensive copying dla mutable kolekcji
        this.hobbies = List.copyOf(builder.hobbies);
        this.attributes = Map.copyOf(builder.attributes);
    }
    
    public List<String> getHobbies() {
        return hobbies;  // juÅ¼ immutable, bezpieczne
    }
    
    public Map<String, String> getAttributes() {
        return attributes;  // juÅ¼ immutable, bezpieczne
    }
    
    public static class Builder {
        private String name;
        private List<String> hobbies = new ArrayList<>();
        private Map<String, String> attributes = new HashMap<>();
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder addHobby(String hobby) {
            this.hobbies.add(hobby);
            return this;
        }
        
        public Builder addAttribute(String key, String value) {
            this.attributes.put(key, value);
            return this;
        }
        
        public ImmutablePerson build() {
            return new ImmutablePerson(this);
        }
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj klasÄ™ `DeepCopyUtil`, ktÃ³ra potrafi wykonaÄ‡ gÅ‚Ä™bokÄ… kopiÄ™ dowolnego obiektu uÅ¼ywajÄ…c refleksji. UwzglÄ™dnij obsÅ‚ugÄ™ kolekcji, tablic i obiektÃ³w zagnieÅ¼dÅ¼onych.

**Zadanie Zaawansowane 2:** StwÃ³rz benchmark porÃ³wnujÄ…cy wydajnoÅ›Ä‡ operacji na typach prymitywnych vs opakowanych w rÃ³Å¼nych scenariuszach (pÄ™tle, kolekcje, przekazywanie parametrÃ³w).

**Zadanie Zaawansowane 3:** Zaprojektuj system cache'owania obiektÃ³w, ktÃ³ry optymalizuje zuÅ¼ycie pamiÄ™ci przez reuÅ¼ywanie immutable obiektÃ³w (podobnie do String pool).

#### â“ Pytania Kontrolne - Poziom Senior

1. Dlaczego Java nie pozwala na przeciÄ…Å¼anie operatorÃ³w dla typÃ³w referencyjnych (poza String)?
2. Jak wpÅ‚ywa na wydajnoÅ›Ä‡ czÄ™ste boxing/unboxing w kolekcjach generycznych?
3. Jakie sÄ… implikacje bezpieczeÅ„stwa zwiÄ…zane z przekazywaniem mutable obiektÃ³w miÄ™dzy wÄ…tkami?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static void dodajLiczbe(List<Integer> lista, int liczba) {
    lista.add(liczba);  // modyfikuje oryginalnÄ… listÄ™
}

// Test:
List<Integer> mojaLista = new ArrayList<>();
mojaLista.add(1);
dodajLiczbe(mojaLista, 2);
System.out.println(mojaLista.size()); // wypisze 2
```

**Zadanie 2:**
```java
public class Punkt {
    private int x, y;
    
    public Punkt(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public void setX(int x) { this.x = x; }
    public void setY(int y) { this.y = y; }
    public int getX() { return x; }
    public int getY() { return y; }
}

public static void zmienPunkt(Punkt p) {
    p.setX(100);  // zmienia oryginalny punkt
    p.setY(200);
}

// Test:
Punkt punkt = new Punkt(10, 20);
zmienPunkt(punkt);
System.out.println(punkt.getX()); // wypisze 100
```

**Zadanie 3:**
```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");
String s4 = new String("Hello");

System.out.println(s1 == s2);     // true (string pool)
System.out.println(s1 == s3);     // false (rÃ³Å¼ne obiekty)
System.out.println(s3 == s4);     // false (rÃ³Å¼ne obiekty)
System.out.println(s1.equals(s3)); // true (ta sama zawartoÅ›Ä‡)
```

**Pytania kontrolne:**
1. Lista to obiekt (typ referencyjny) - metoda dostaje kopiÄ™ adresu, wiÄ™c moÅ¼e modyfikowaÄ‡ obiekt. Int to typ prymitywny - metoda dostaje kopiÄ™ wartoÅ›ci.
2. `==` porÃ³wnuje adresy obiektÃ³w, `equals()` porÃ³wnuje zawartoÅ›Ä‡ obiektÃ³w.
3. Tablica to typ referencyjny - nawet tablica prymitywÃ³w jest obiektem.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class DeepCopyUtil {
    public static <T> T deepCopy(T original) throws Exception {
        if (original == null) return null;
        
        Class<?> clazz = original.getClass();
        
        // ObsÅ‚uga typÃ³w prymitywnych i immutable
        if (clazz.isPrimitive() || isImmutable(clazz)) {
            return original;
        }
        
        // ObsÅ‚uga tablic
        if (clazz.isArray()) {
            return copyArray(original);
        }
        
        // ObsÅ‚uga kolekcji
        if (Collection.class.isAssignableFrom(clazz)) {
            return copyCollection(original);
        }
        
        // ObsÅ‚uga map
        if (Map.class.isAssignableFrom(clazz)) {
            return copyMap(original);
        }
        
        // ObsÅ‚uga zwykÅ‚ych obiektÃ³w
        return copyObject(original);
    }
    
    private static boolean isImmutable(Class<?> clazz) {
        return clazz == String.class || 
               clazz == Integer.class || 
               clazz == Long.class ||
               // ... inne immutable klasy
               clazz.isEnum();
    }
    
    // Implementacje pomocniczych metod...
}
```

**Zadanie Zaawansowane 2:**
```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class PrimitiveVsBoxedBenchmark {
    
    @Benchmark
    public long sumPrimitiveArray() {
        int[] array = new int[1000];
        long sum = 0;
        for (int i = 0; i < array.length; i++) {
            sum += array[i];
        }
        return sum;
    }
    
    @Benchmark
    public long sumBoxedArray() {
        Integer[] array = new Integer[1000];
        long sum = 0;
        for (int i = 0; i < array.length; i++) {
            sum += array[i];  // unboxing w kaÅ¼dej iteracji
        }
        return sum;
    }
    
    // Wyniki pokazujÄ…, Å¼e prymitywy sÄ… ~10x szybsze
}
```

**Zadanie Zaawansowane 3:**
```java
public class ObjectPool<T> {
    private final Map<T, T> pool = new ConcurrentHashMap<>();
    private final Function<T, T> copyFunction;
    
    public ObjectPool(Function<T, T> copyFunction) {
        this.copyFunction = copyFunction;
    }
    
    public T intern(T object) {
        if (object == null) return null;
        
        return pool.computeIfAbsent(object, copyFunction);
    }
    
    public int size() {
        return pool.size();
    }
    
    public void clear() {
        pool.clear();
    }
}

// UÅ¼ycie:
ObjectPool<String> stringPool = new ObjectPool<>(String::new);
String interned = stringPool.intern("Hello World");
```

**Pytania kontrolne:**
1. Java nie pozwala na przeciÄ…Å¼anie operatorÃ³w dla bezpieczeÅ„stwa typÃ³w i czytelnoÅ›ci kodu. String ma specjalne wsparcie w JVM.
2. Boxing/unboxing tworzy nowe obiekty, co zwiÄ™ksza presjÄ™ na GC i zmniejsza wydajnoÅ›Ä‡, szczegÃ³lnie w pÄ™tlach.
3. Przekazywanie mutable obiektÃ³w moÅ¼e prowadziÄ‡ do race conditions, data races i naruszenia invariantÃ³w bez odpowiedniej synchronizacji.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Teraz rozumiesz jednÄ… z najwaÅ¼niejszych rÃ³Å¼nic w Javie. Ta wiedza bÄ™dzie Ci towarzyszyÄ‡ przez caÅ‚Ä… karierÄ™ programistycznÄ…. W nastÄ™pnym rozdziale porozmawiamy o autoboxing i unboxing - czyli o tym, jak Java automatycznie konwertuje miÄ™dzy typami prymitywnymi a ich opakowanymi odpowiednikami. Przygotuj siÄ™ na kolejne "aha!" momenty!*

---

*ğŸ’¡ PamiÄ™taj: Zrozumienie rÃ³Å¼nicy miÄ™dzy typami prymitywnymi a referencyjnymi to klucz do pisania wydajnego i bezpiecznego kodu Java!*


## 3. Autoboxing i unboxing â€” magia (i puÅ‚apki)

*CzeÅ›Ä‡! DziÅ› porozmawiamy o jednej z tych funkcjonalnoÅ›ci Javy, ktÃ³ra wydaje siÄ™ super wygodna, ale moÅ¼e sprawiÄ‡ Ci sporo problemÃ³w, jeÅ›li nie zrozumiesz, jak dziaÅ‚a pod maskÄ…. Autoboxing i unboxing to jak automatyczny tÅ‚umacz miÄ™dzy typami prymitywnymi a ich "opakowanymi" braÄ‡mi. Brzmi Å›wietnie, prawda? No to zobaczmy, gdzie czajÄ… siÄ™ puÅ‚apki!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

Autoboxing i unboxing to automatyczne konwersje miÄ™dzy typami prymitywnymi a ich odpowiednikami w postaci klas (wrapper classes). To jak mieÄ‡ asystenta, ktÃ³ry automatycznie pakuje i rozpakowuje prezenty za Ciebie.

**Autoboxing** = automatyczne "opakowanie" typu prymitywnego w obiekt
**Unboxing** = automatyczne "rozpakowanie" obiektu do typu prymitywnego

```java
// Przed JavÄ… 5 musiaÅ‚aÅ› robiÄ‡ to rÄ™cznie:
Integer starySposob = new Integer(42);  // rÄ™czne "pakowanie"
int wartoscStary = starySposob.intValue();  // rÄ™czne "rozpakowywanie"

// Od Javy 5 moÅ¼esz pisaÄ‡ tak:
Integer autobox = 42;        // autoboxing: int â†’ Integer
int autounbox = autobox;     // unboxing: Integer â†’ int
```

Oto wszystkie pary typÃ³w:

```java
// Typ prymitywny â†’ Wrapper class
byte    â†’ Byte
short   â†’ Short
int     â†’ Integer
long    â†’ Long
float   â†’ Float
double  â†’ Double
char    â†’ Character
boolean â†’ Boolean

// PrzykÅ‚ady autoboxing
Integer liczba = 100;           // int â†’ Integer
Double pi = 3.14159;           // double â†’ Double
Boolean flaga = true;          // boolean â†’ Boolean
Character litera = 'A';        // char â†’ Character

// PrzykÅ‚ady unboxing
int x = liczba;                // Integer â†’ int
double piValue = pi;           // Double â†’ double
boolean flagValue = flaga;     // Boolean â†’ boolean
char literaValue = litera;     // Character â†’ char
```

#### Dlaczego to waÅ¼ne?

Autoboxing i unboxing pozwalajÄ… Ci uÅ¼ywaÄ‡ typÃ³w prymitywnych i ich wrapper classes zamiennie w wiÄ™kszoÅ›ci sytuacji. To szczegÃ³lnie przydatne przy pracy z kolekcjami, ktÃ³re mogÄ… przechowywaÄ‡ tylko obiekty, nie prymitywy.

```java
// Bez autoboxing musiaÅ‚abyÅ› pisaÄ‡:
List<Integer> liczby = new ArrayList<Integer>();
liczby.add(new Integer(1));
liczby.add(new Integer(2));
liczby.add(new Integer(3));

// Z autoboxing moÅ¼esz pisaÄ‡:
List<Integer> liczby = new ArrayList<>();
liczby.add(1);    // autoboxing: int â†’ Integer
liczby.add(2);    // autoboxing: int â†’ Integer
liczby.add(3);    // autoboxing: int â†’ Integer

// I uÅ¼ywaÄ‡ w pÄ™tlach:
for (int liczba : liczby) {  // unboxing: Integer â†’ int
    System.out.println(liczba);
}
```

#### Jak to dziaÅ‚a w praktyce?

**PrzykÅ‚ad 1: Kolekcje**

```java
public class AutoboxingWKolekcjach {
    public static void main(String[] args) {
        List<Integer> liczby = new ArrayList<>();
        
        // Autoboxing przy dodawaniu
        liczby.add(10);      // int â†’ Integer
        liczby.add(20);      // int â†’ Integer
        liczby.add(30);      // int â†’ Integer
        
        // Unboxing przy pobieraniu
        int pierwsza = liczby.get(0);  // Integer â†’ int
        
        // Autoboxing/unboxing w operacjach
        int suma = 0;
        for (Integer liczba : liczby) {  // unboxing w kaÅ¼dej iteracji
            suma += liczba;              // unboxing: Integer â†’ int
        }
        
        liczby.add(suma);  // autoboxing: int â†’ Integer
    }
}
```

**PrzykÅ‚ad 2: Metody**

```java
public class AutoboxingWMetodach {
    // Metoda przyjmujÄ…ca wrapper
    public static void wypiszLiczbe(Integer liczba) {
        System.out.println("Liczba: " + liczba);
    }
    
    // Metoda przyjmujÄ…ca prymityw
    public static void obliczKwadrat(int liczba) {
        System.out.println("Kwadrat: " + (liczba * liczba));
    }
    
    public static void main(String[] args) {
        int prymityw = 5;
        Integer wrapper = 10;
        
        // Autoboxing przy wywoÅ‚aniu
        wypiszLiczbe(prymityw);    // int â†’ Integer
        
        // Unboxing przy wywoÅ‚aniu
        obliczKwadrat(wrapper);    // Integer â†’ int
    }
}
```

#### PuÅ‚apki, na ktÃ³re warto uwaÅ¼aÄ‡

**PuÅ‚apka 1: NullPointerException**

```java
Integer liczba = null;
int prymityw = liczba;  // BOOM! NullPointerException przy unboxing
```

**PuÅ‚apka 2: PorÃ³wnywanie z ==**

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);  // true (cache dla -128 do 127)

Integer c = 200;
Integer d = 200;
System.out.println(c == d);  // false! (poza cache)

// Bezpieczne porÃ³wnywanie:
System.out.println(Objects.equals(c, d));  // true
```

**PuÅ‚apka 3: WydajnoÅ›Ä‡**

```java
// Å¹le - tworzy nowy obiekt w kaÅ¼dej iteracji!
Integer suma = 0;
for (int i = 0; i < 1000; i++) {
    suma += i;  // unboxing + boxing w kaÅ¼dej iteracji
}

// Dobrze - uÅ¼ywa tylko prymitywÃ³w
int suma = 0;
for (int i = 0; i < 1000; i++) {
    suma += i;  // tylko prymitywy, szybko!
}
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **Sprawdzaj null** przed unboxing wrapper classes
- **UÅ¼ywaj `equals()`** do porÃ³wnywania wrapper classes, nie `==`
- **Unikaj autoboxing w pÄ™tlach** - moÅ¼e byÄ‡ wolne
- **Preferuj prymitywy** w obliczeniach matematycznych
- **UÅ¼ywaj wrapper classes** tylko gdy musisz (kolekcje, null values)

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** Napisz metodÄ™, ktÃ³ra przyjmuje `List<Integer>` i zwraca sumÄ™ wszystkich liczb. UwaÅ¼aj na potencjalne NullPointerException.

```java
public static int sumujLiczby(List<Integer> liczby) {
    // Twoja implementacja
}
```

**Zadanie 2:** StwÃ³rz metodÄ™, ktÃ³ra sprawdza, czy dwie listy Integer zawierajÄ… te same wartoÅ›ci (ale mogÄ… byÄ‡ rÃ³Å¼nymi obiektami).

**Zadanie 3:** Eksperymentuj z cache Integer. SprawdÅº, dla jakich wartoÅ›ci `==` zwraca true, a dla jakich false.

#### â“ Pytania Kontrolne - Poziom Junior

1. Co siÄ™ stanie, jeÅ›li sprÃ³bujesz zrobiÄ‡ unboxing na null?
2. Dlaczego `Integer a = 100; Integer b = 100; a == b` zwraca true, ale dla 200 zwraca false?
3. Kiedy autoboxing moÅ¼e wpÅ‚ynÄ…Ä‡ negatywnie na wydajnoÅ›Ä‡?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

Autoboxing i unboxing to syntactic sugar wprowadzony w Javie 5, ktÃ³ry ukrywa przed programistÄ… wywoÅ‚ania metod `valueOf()` i `xxxValue()`. Kompilator automatycznie wstawia te wywoÅ‚ania w odpowiednich miejscach, co ma zarÃ³wno zalety, jak i powaÅ¼ne implikacje wydajnoÅ›ciowe.

##### Mechanizm dziaÅ‚ania na poziomie bytecode

```java
// Kod ÅºrÃ³dÅ‚owy:
Integer x = 42;
int y = x;

// Jest kompilowany do:
Integer x = Integer.valueOf(42);
int y = x.intValue();
```

Przyjrzyjmy siÄ™ implementacji `Integer.valueOf()`:

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

private static class IntegerCache {
    static final int low = -128;
    static final int high = 127;  // moÅ¼e byÄ‡ zwiÄ™kszone przez -XX:AutoBoxCacheMax
    static final Integer cache[];
    
    static {
        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);
    }
}
```

##### Implikacje wydajnoÅ›ciowe

**Memory overhead:**

```java
public class MemoryOverhead {
    // PorÃ³wnanie zuÅ¼ycia pamiÄ™ci
    private int[] primitives = new int[1_000_000];     // ~4MB
    private Integer[] boxed = new Integer[1_000_000];  // ~16MB + object overhead
    
    // KaÅ¼dy Integer to:
    // - 12 bytes object header (64-bit JVM z compressed OOPs)
    // - 4 bytes dla int value
    // - padding do 8-byte boundary
    // = 16 bytes vs 4 bytes dla int
}
```

**CPU overhead w pÄ™tlach:**

```java
@Benchmark
public class AutoboxingBenchmark {
    private List<Integer> boxedList = IntStream.range(0, 1000)
        .boxed()
        .collect(Collectors.toList());
    
    @Benchmark
    public long sumWithAutoboxing() {
        long sum = 0;
        for (Integer i : boxedList) {  // unboxing w kaÅ¼dej iteracji
            sum += i;                  // unboxing
        }
        return sum;
    }
    
    @Benchmark
    public long sumWithPrimitives() {
        long sum = 0;
        for (int i = 0; i < 1000; i++) {  // tylko prymitywy
            sum += i;
        }
        return sum;
    }
    
    // Wynik: sumWithPrimitives jest ~10x szybsze
}
```

##### Garbage Collection pressure

```java
public class GCPressure {
    // Å¹le - tworzy miliony obiektÃ³w
    public Integer badSum() {
        Integer sum = 0;  // autoboxing
        for (int i = 0; i < 1_000_000; i++) {
            sum += i;  // unboxing + autoboxing w kaÅ¼dej iteracji!
        }
        return sum;
    }
    
    // Dobrze - tylko jeden obiekt na koÅ„cu
    public Integer goodSum() {
        int sum = 0;  // prymityw
        for (int i = 0; i < 1_000_000; i++) {
            sum += i;  // tylko prymitywy
        }
        return sum;  // autoboxing tylko raz
    }
}
```

#### PuÅ‚apki i niuanse

##### PuÅ‚apka z equals() i ==

```java
public class EqualsVsEquals {
    public void demonstrateComparison() {
        // Cache range: -128 do 127
        Integer a1 = 100, a2 = 100;
        System.out.println(a1 == a2);        // true (ten sam obiekt z cache)
        System.out.println(a1.equals(a2));   // true
        
        // Poza cache
        Integer b1 = 200, b2 = 200;
        System.out.println(b1 == b2);        // false (rÃ³Å¼ne obiekty)
        System.out.println(b1.equals(b2));   // true
        
        // Mieszanie z prymitywami
        int c = 200;
        Integer d = 200;
        System.out.println(c == d);          // true (unboxing d do int)
        
        // PuÅ‚apka z null
        Integer e = null;
        int f = 200;
        // System.out.println(e == f);       // NullPointerException!
        System.out.println(Objects.equals(e, f));  // false, bezpiecznie
    }
}
```

##### PuÅ‚apka z kolekcjami i null

```java
public class CollectionNullTrap {
    public void demonstrateNullTrap() {
        List<Integer> numbers = Arrays.asList(1, 2, null, 4, 5);
        
        // To spowoduje NPE:
        try {
            int sum = numbers.stream()
                .mapToInt(Integer::intValue)  // NPE na null
                .sum();
        } catch (NullPointerException e) {
            System.out.println("NPE przy unboxing null!");
        }
        
        // Bezpieczna wersja:
        int safeSum = numbers.stream()
            .filter(Objects::nonNull)
            .mapToInt(Integer::intValue)
            .sum();
    }
}
```

##### PuÅ‚apka z concurrent collections

```java
public class ConcurrentAutoboxingTrap {
    private final Map<String, Integer> counters = new ConcurrentHashMap<>();
    
    // Å¹le - race condition z autoboxing
    public void badIncrement(String key) {
        Integer current = counters.get(key);  // moÅ¼e byÄ‡ null
        if (current == null) {
            current = 0;
        }
        counters.put(key, current + 1);  // autoboxing, ale nie atomowe!
    }
    
    // Dobrze - atomowa operacja
    public void goodIncrement(String key) {
        counters.merge(key, 1, Integer::sum);
    }
    
    // Jeszcze lepiej - unikamy autoboxing
    private final Map<String, AtomicInteger> atomicCounters = new ConcurrentHashMap<>();
    
    public void bestIncrement(String key) {
        atomicCounters.computeIfAbsent(key, k -> new AtomicInteger(0))
                     .incrementAndGet();
    }
}
```

#### Wzorce i best practices

##### Wzorzec Primitive Specialization

```java
// Zamiast uÅ¼ywaÄ‡ generycznych kolekcji z autoboxing
List<Integer> numbers = new ArrayList<>();  // boxing overhead

// UÅ¼yj specialized collections
IntList numbers = new IntArrayList();  // Eclipse Collections
TIntList numbers = new TIntArrayList(); // Trove4j

// Lub primitive streams
IntStream.range(0, 1000)
    .filter(i -> i % 2 == 0)
    .sum();  // bez autoboxing!
```

##### Wzorzec Null Object dla wrapper classes

```java
public class SafeInteger {
    private final Integer value;
    
    private SafeInteger(Integer value) {
        this.value = value;
    }
    
    public static SafeInteger of(Integer value) {
        return new SafeInteger(value);
    }
    
    public static SafeInteger empty() {
        return new SafeInteger(null);
    }
    
    public int orElse(int defaultValue) {
        return value != null ? value : defaultValue;
    }
    
    public boolean isPresent() {
        return value != null;
    }
    
    public SafeInteger map(IntUnaryOperator mapper) {
        return value != null ? of(mapper.applyAsInt(value)) : empty();
    }
}
```

##### Performance-aware autoboxing

```java
public class PerformanceAwareAutoboxing {
    // Unikaj autoboxing w hot paths
    public long calculateSum(List<Integer> numbers) {
        // Å¹le - autoboxing w kaÅ¼dej iteracji
        return numbers.stream()
            .mapToLong(i -> i)  // Integer -> long (przez int)
            .sum();
        
        // Lepiej - explicit unboxing
        return numbers.stream()
            .filter(Objects::nonNull)
            .mapToLong(Integer::longValue)
            .sum();
        
        // Najlepiej - primitive stream
        return numbers.stream()
            .filter(Objects::nonNull)
            .mapToInt(Integer::intValue)
            .asLongStream()
            .sum();
    }
    
    // Optymalizacja dla czÄ™stych operacji
    private static final Integer[] CACHE = new Integer[1000];
    static {
        for (int i = 0; i < CACHE.length; i++) {
            CACHE[i] = i;
        }
    }
    
    public Integer fastValueOf(int i) {
        return (i >= 0 && i < CACHE.length) ? CACHE[i] : Integer.valueOf(i);
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj wÅ‚asnÄ… wersjÄ™ `IntegerCache` z konfigurowalnymi granicami i zmierz wpÅ‚yw na wydajnoÅ›Ä‡ w rÃ³Å¼nych scenariuszach.

**Zadanie Zaawansowane 2:** StwÃ³rz analizator kodu, ktÃ³ry znajdzie wszystkie miejsca potencjalnie problematycznego autoboxing/unboxing i zaproponuje optymalizacje.

**Zadanie Zaawansowane 3:** Zaprojektuj thread-safe licznik, ktÃ³ry minimalizuje autoboxing i maksymalizuje wydajnoÅ›Ä‡ w Å›rodowisku wielowÄ…tkowym.

#### â“ Pytania Kontrolne - Poziom Senior

1. Dlaczego autoboxing moÅ¼e byÄ‡ problematyczny w aplikacjach high-performance?
2. Jak moÅ¼na skonfigurowaÄ‡ rozmiar cache dla Integer i jakie sÄ… tego implikacje?
3. Jakie sÄ… alternatywy dla kolekcji generycznych, ktÃ³re eliminujÄ… autoboxing?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static int sumujLiczby(List<Integer> liczby) {
    if (liczby == null) {
        return 0;
    }
    
    int suma = 0;
    for (Integer liczba : liczby) {
        if (liczba != null) {  // sprawdzenie null przed unboxing
            suma += liczba;    // unboxing: Integer â†’ int
        }
    }
    return suma;
}

// Alternatywnie z streams:
public static int sumujLiczbyStream(List<Integer> liczby) {
    return liczby == null ? 0 : 
           liczby.stream()
                 .filter(Objects::nonNull)
                 .mapToInt(Integer::intValue)
                 .sum();
}
```

**Zadanie 2:**
```java
public static boolean majaTesamWartosci(List<Integer> lista1, List<Integer> lista2) {
    if (lista1 == null && lista2 == null) return true;
    if (lista1 == null || lista2 == null) return false;
    if (lista1.size() != lista2.size()) return false;
    
    for (int i = 0; i < lista1.size(); i++) {
        if (!Objects.equals(lista1.get(i), lista2.get(i))) {
            return false;
        }
    }
    return true;
}
```

**Zadanie 3:**
```java
// Test cache Integer
for (int i = -130; i <= 130; i++) {
    Integer a = i;
    Integer b = i;
    System.out.println(i + ": " + (a == b));
}
// Wynik: true dla -128 do 127, false dla reszty
```

**Pytania kontrolne:**
1. WystÄ…pi `NullPointerException` - nie moÅ¼na rozpakowaÄ‡ null do typu prymitywnego.
2. Java cache'uje Integer od -128 do 127, wiÄ™c dla tych wartoÅ›ci `==` porÃ³wnuje te same obiekty.
3. W pÄ™tlach, gdzie autoboxing/unboxing wystÄ™puje w kaÅ¼dej iteracji, tworzÄ…c niepotrzebne obiekty.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class CustomIntegerCache {
    private final int low;
    private final int high;
    private final Integer[] cache;
    
    public CustomIntegerCache(int low, int high) {
        this.low = low;
        this.high = high;
        this.cache = new Integer[high - low + 1];
        
        for (int i = 0; i < cache.length; i++) {
            cache[i] = new Integer(low + i);
        }
    }
    
    public Integer valueOf(int i) {
        if (i >= low && i <= high) {
            return cache[i - low];
        }
        return new Integer(i);
    }
    
    // Benchmark rÃ³Å¼nych rozmiarÃ³w cache
    @Benchmark
    public void testCachePerformance() {
        Random random = new Random();
        CustomIntegerCache cache = new CustomIntegerCache(-1000, 1000);
        
        for (int i = 0; i < 100000; i++) {
            int value = random.nextInt(2000) - 1000;
            Integer boxed = cache.valueOf(value);
        }
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class AutoboxingAnalyzer {
    public static class AutoboxingIssue {
        private final String location;
        private final String issue;
        private final String suggestion;
        
        // konstruktor, gettery...
    }
    
    public List<AutoboxingIssue> analyzeCode(String sourceCode) {
        List<AutoboxingIssue> issues = new ArrayList<>();
        
        // ZnajdÅº problematyczne wzorce:
        // 1. Autoboxing w pÄ™tlach
        if (sourceCode.contains("for") && sourceCode.contains("Integer")) {
            issues.add(new AutoboxingIssue(
                "Loop with Integer",
                "Potential autoboxing in loop",
                "Use int instead of Integer for loop variables"
            ));
        }
        
        // 2. PorÃ³wnywanie == z wrapper classes
        if (sourceCode.matches(".*Integer\\s*==\\s*Integer.*")) {
            issues.add(new AutoboxingIssue(
                "Integer comparison",
                "Using == to compare Integer objects",
                "Use Objects.equals() or .equals() method"
            ));
        }
        
        // 3. Null unboxing risk
        if (sourceCode.contains("Integer") && sourceCode.contains("= null")) {
            issues.add(new AutoboxingIssue(
                "Null unboxing risk",
                "Integer variable can be null",
                "Check for null before unboxing"
            ));
        }
        
        return issues;
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class HighPerformanceCounter {
    private final AtomicLong counter = new AtomicLong(0);
    
    // Unikamy autoboxing caÅ‚kowicie
    public long increment() {
        return counter.incrementAndGet();
    }
    
    public long add(long delta) {
        return counter.addAndGet(delta);
    }
    
    public long get() {
        return counter.get();
    }
    
    // JeÅ›li potrzebujemy Integer, robimy to Å›wiadomie
    public Integer getAsInteger() {
        long value = counter.get();
        if (value > Integer.MAX_VALUE || value < Integer.MIN_VALUE) {
            throw new ArithmeticException("Counter value exceeds Integer range");
        }
        return (int) value;  // explicit cast, potem autoboxing
    }
    
    // Batch operations dla lepszej wydajnoÅ›ci
    public long addBatch(long[] values) {
        long sum = 0;
        for (long value : values) {  // tylko prymitywy
            sum += value;
        }
        return counter.addAndGet(sum);
    }
}
```

**Pytania kontrolne:**
1. Autoboxing tworzy obiekty, zwiÄ™ksza presjÄ™ na GC, wymaga wiÄ™cej pamiÄ™ci i CPU. W hot paths moÅ¼e znaczÄ…co wpÅ‚ynÄ…Ä‡ na wydajnoÅ›Ä‡.
2. MoÅ¼na uÅ¼yÄ‡ `-XX:AutoBoxCacheMax=<size>` dla Integer. WiÄ™kszy cache = wiÄ™cej pamiÄ™ci, ale mniej alokacji dla czÄ™sto uÅ¼ywanych wartoÅ›ci.
3. Primitive collections (Eclipse Collections, Trove4j), primitive streams, specialized data structures, lub wÅ‚asne implementacje unikajÄ…ce autoboxing.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Teraz rozumiesz, jak dziaÅ‚a autoboxing i unboxing, i co waÅ¼niejsze - wiesz, gdzie czyhajÄ… puÅ‚apki. Ta wiedza bÄ™dzie nieoceniona przy optymalizacji wydajnoÅ›ci Twoich aplikacji. W nastÄ™pnym rozdziale porozmawiamy o operatorach - tych podstawowych plus, minus, ale teÅ¼ o bardziej zaawansowanych sztuczkach, ktÃ³re Java ma w zanadrzu!*

---

*ğŸ’¡ PamiÄ™taj: Autoboxing to wygoda, ale uÅ¼ywaj go Å›wiadomie. W krytycznych miejscach lepiej byÄ‡ explicit niÅ¼ Å¼aÅ‚owaÄ‡ pÃ³Åºniej!*


## 4. Operatory: plusy, minusy i inne czary

*CzeÅ›Ä‡! DziÅ› porozmawiamy o operatorach w Javie. Na pierwszy rzut oka moÅ¼e siÄ™ wydawaÄ‡, Å¼e to proste - przecieÅ¼ plus to plus, prawda? Ale Java ma w zanadrzu kilka niespodzianek, ktÃ³re mogÄ… CiÄ™ zaskoczyÄ‡. Od podstawowych operacji arytmetycznych, przez logiczne sztuczki, aÅ¼ po bitowe czary - przygotuj siÄ™ na peÅ‚en przeglÄ…d tego, co Java ma do zaoferowania!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

Operatory to symbole, ktÃ³re mÃ³wiÄ… Javie, jakÄ… operacjÄ™ ma wykonaÄ‡ na danych. To jak polecenia w przepisie kulinarnym - "dodaj", "odejmij", "porÃ³wnaj", "sprawdÅº czy prawda". Java ma kilka rodzin operatorÃ³w, kaÅ¼da do innych zadaÅ„.

```java
// Podstawowe operatory arytmetyczne
int a = 10;
int b = 3;

int suma = a + b;        // 13 - dodawanie
int roznica = a - b;     // 7  - odejmowanie  
int iloczyn = a * b;     // 30 - mnoÅ¼enie
int iloraz = a / b;      // 3  - dzielenie caÅ‚kowite
int reszta = a % b;      // 1  - reszta z dzielenia (modulo)

// Operatory porÃ³wnania
boolean rowne = (a == b);        // false
boolean nierowne = (a != b);     // true
boolean wieksze = (a > b);       // true
boolean mniejsze = (a < b);      // false
boolean wiekszeRowne = (a >= b); // true
boolean mniejszeRowne = (a <= b);// false
```

#### Dlaczego to waÅ¼ne?

Operatory to podstawowe narzÄ™dzia do manipulacji danych w kaÅ¼dym programie. Bez nich nie mogÅ‚abyÅ› wykonywaÄ‡ obliczeÅ„, porÃ³wnywaÄ‡ wartoÅ›ci ani podejmowaÄ‡ decyzji w kodzie. To jak prÃ³ba gotowania bez noÅ¼a - teoretycznie moÅ¼liwe, ale bardzo niepraktyczne!

#### Jak to dziaÅ‚a w praktyce?

**Operatory arytmetyczne:**

```java
public class OperatoryArytmetyczne {
    public static void main(String[] args) {
        // Podstawowe operacje
        int x = 15;
        int y = 4;
        
        System.out.println("x + y = " + (x + y));  // 19
        System.out.println("x - y = " + (x - y));  // 11
        System.out.println("x * y = " + (x * y));  // 60
        System.out.println("x / y = " + (x / y));  // 3 (dzielenie caÅ‚kowite!)
        System.out.println("x % y = " + (x % y));  // 3 (reszta)
        
        // Uwaga na dzielenie!
        double dokÅ‚adnyIloraz = (double) x / y;  // 3.75
        System.out.println("DokÅ‚adny iloraz: " + dokÅ‚adnyIloraz);
        
        // Operatory inkrementacji i dekrementacji
        int licznik = 5;
        licznik++;      // post-inkrementacja: uÅ¼yj wartoÅ›Ä‡, potem zwiÄ™ksz
        ++licznik;      // pre-inkrementacja: zwiÄ™ksz, potem uÅ¼yj wartoÅ›Ä‡
        licznik--;      // post-dekrementacja
        --licznik;      // pre-dekrementacja
        
        System.out.println("KoÅ„cowa wartoÅ›Ä‡ licznika: " + licznik); // 5
    }
}
```

**Operatory logiczne:**

```java
public class OperatoryLogiczne {
    public static void main(String[] args) {
        boolean prawda = true;
        boolean falsz = false;
        
        // Operatory logiczne
        System.out.println("prawda && falsz = " + (prawda && falsz)); // false (AND)
        System.out.println("prawda || falsz = " + (prawda || falsz)); // true (OR)
        System.out.println("!prawda = " + (!prawda));                 // false (NOT)
        
        // Praktyczny przykÅ‚ad
        int wiek = 25;
        boolean maLicencje = true;
        boolean mozeProwadzic = (wiek >= 18) && maLicencje;
        
        System.out.println("MoÅ¼e prowadziÄ‡: " + mozeProwadzic); // true
        
        // Short-circuit evaluation
        boolean wynik = falsz && (10 / 0 == 1); // Nie rzuci wyjÄ…tku!
        // Druga czÄ™Å›Ä‡ nie jest sprawdzana, bo pierwsza to false
    }
}
```

**Operator ternarny (? :):**

```java
public class OperatorTernarny {
    public static void main(String[] args) {
        int wiek = 17;
        
        // Zamiast if-else:
        String status;
        if (wiek >= 18) {
            status = "peÅ‚noletnia";
        } else {
            status = "niepeÅ‚noletnia";
        }
        
        // MoÅ¼esz uÅ¼yÄ‡ operatora ternarnego:
        String statusTernarny = (wiek >= 18) ? "peÅ‚noletnia" : "niepeÅ‚noletnia";
        
        System.out.println("Status: " + statusTernarny); // niepeÅ‚noletnia
        
        // MoÅ¼na zagnieÅ¼dÅ¼aÄ‡ (ale ostroÅ¼nie z czytelnoÅ›ciÄ…!)
        String ocena = (wiek >= 18) ? "dorosÅ‚a" : 
                      (wiek >= 13) ? "nastolatka" : "dziecko";
    }
}
```

**Operatory przypisania:**

```java
public class OperatoryPrzypisania {
    public static void main(String[] args) {
        int x = 10;
        
        x += 5;   // x = x + 5;  â†’ x = 15
        x -= 3;   // x = x - 3;  â†’ x = 12
        x *= 2;   // x = x * 2;  â†’ x = 24
        x /= 4;   // x = x / 4;  â†’ x = 6
        x %= 5;   // x = x % 5;  â†’ x = 1
        
        System.out.println("KoÅ„cowa wartoÅ›Ä‡ x: " + x); // 1
        
        // Dla StringÃ³w teÅ¼ dziaÅ‚a +=
        String tekst = "Hello";
        tekst += " World";  // tekst = tekst + " World";
        System.out.println(tekst); // Hello World
    }
}
```

#### PuÅ‚apki, na ktÃ³re warto uwaÅ¼aÄ‡

**PuÅ‚apka 1: Dzielenie caÅ‚kowite**

```java
int a = 5;
int b = 2;
double wynik = a / b;  // 2.0, nie 2.5!

// Poprawnie:
double poprawnyWynik = (double) a / b;  // 2.5
```

**PuÅ‚apka 2: RÃ³Å¼nica miÄ™dzy ++ i ++**

```java
int i = 5;
int j = i++;  // j = 5, i = 6 (najpierw przypisz, potem zwiÄ™ksz)
int k = ++i;  // k = 7, i = 7 (najpierw zwiÄ™ksz, potem przypisz)
```

**PuÅ‚apka 3: PorÃ³wnywanie obiektÃ³w**

```java
String s1 = new String("Hello");
String s2 = new String("Hello");
boolean rowne = (s1 == s2);  // false! PorÃ³wnuje referencje, nie zawartoÅ›Ä‡

// Poprawnie:
boolean poprawnieRowne = s1.equals(s2);  // true
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **UÅ¼ywaj nawiasÃ³w** dla jasnoÅ›ci: `(a + b) * c` zamiast `a + b * c`
- **UwaÅ¼aj na dzielenie przez zero** - sprawdzaj przed dzieleniem
- **PamiÄ™taj o kolejnoÅ›ci operacji** - mnoÅ¼enie i dzielenie przed dodawaniem i odejmowaniem
- **UÅ¼ywaj `equals()`** do porÃ³wnywania obiektÃ³w, nie `==`
- **Operator ternarny** jest Å›wietny dla prostych przypadkÃ³w, ale nie przesadzaj z zagnieÅ¼dÅ¼aniem

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** Napisz kalkulator, ktÃ³ry wykonuje podstawowe operacje arytmetyczne i obsÅ‚uguje dzielenie przez zero.

```java
public class Kalkulator {
    public static double dodaj(double a, double b) {
        // Twoja implementacja
    }
    
    public static double podziel(double a, double b) {
        // PamiÄ™taj o dzieleniu przez zero!
    }
    
    // Dodaj pozostaÅ‚e operacje
}
```

**Zadanie 2:** StwÃ³rz metodÄ™, ktÃ³ra sprawdza, czy rok jest przestÄ™pny (podzielny przez 4, ale nie przez 100, chyba Å¼e przez 400).

**Zadanie 3:** Eksperymentuj z operatorami pre/post inkrementacji w pÄ™tlach i sprawdÅº rÃ³Å¼nice.

#### â“ Pytania Kontrolne - Poziom Junior

1. Jaka jest rÃ³Å¼nica miÄ™dzy `i++` a `++i`?
2. Dlaczego `5 / 2` daje `2`, a nie `2.5`?
3. Co to jest "short-circuit evaluation" w operatorach logicznych?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

Operatory w Javie to nie tylko syntactic sugar - to fundamentalne elementy jÄ™zyka, ktÃ³re majÄ… gÅ‚Ä™bokie implikacje dla wydajnoÅ›ci, semantyki i bezpieczeÅ„stwa kodu. Przyjrzyjmy siÄ™ im z perspektywy architektury jÄ™zyka i optymalizacji JVM.

##### Hierarchia precedencji operatorÃ³w

Java ma Å›ciÅ›le okreÅ›lonÄ… hierarchiÄ™ precedencji operatorÃ³w, ktÃ³ra wpÅ‚ywa na kolejnoÅ›Ä‡ wykonywania operacji:

```java
public class PrecedencjaOperatorow {
    public void demonstracjaPrecedencji() {
        // Precedencja (od najwyÅ¼szej):
        // 1. Postfix: expr++, expr--
        // 2. Unary: ++expr, --expr, +expr, -expr, ~, !
        // 3. Multiplicative: *, /, %
        // 4. Additive: +, -
        // 5. Shift: <<, >>, >>>
        // 6. Relational: <, >, <=, >=, instanceof
        // 7. Equality: ==, !=
        // 8. Bitwise AND: &
        // 9. Bitwise XOR: ^
        // 10. Bitwise OR: |
        // 11. Logical AND: &&
        // 12. Logical OR: ||
        // 13. Ternary: ? :
        // 14. Assignment: =, +=, -=, etc.
        
        int result = 2 + 3 * 4;  // 14, nie 20 (mnoÅ¼enie ma wyÅ¼szÄ… precedencjÄ™)
        boolean complex = true || false && false;  // true (AND przed OR)
        
        // Dla czytelnoÅ›ci zawsze uÅ¼ywaj nawiasÃ³w w zÅ‚oÅ¼onych wyraÅ¼eniach
        int clearResult = 2 + (3 * 4);
        boolean clearComplex = true || (false && false);
    }
}
```

##### Operatory bitowe - zaawansowane zastosowania

```java
public class OperatoryBitowe {
    // Operatory bitowe dziaÅ‚ajÄ… na poziomie bitÃ³w
    public void demonstracjaBitowych() {
        int a = 60;  // 0011 1100 w binarnym
        int b = 13;  // 0000 1101 w binarnym
        
        System.out.println("a & b = " + (a & b));   // 12 (0000 1100) - AND
        System.out.println("a | b = " + (a | b));   // 61 (0011 1101) - OR
        System.out.println("a ^ b = " + (a ^ b));   // 49 (0011 0001) - XOR
        System.out.println("~a = " + (~a));         // -61 (1100 0011) - NOT
        System.out.println("a << 2 = " + (a << 2)); // 240 (przesuniÄ™cie w lewo)
        System.out.println("a >> 2 = " + (a >> 2)); // 15 (przesuniÄ™cie w prawo)
        System.out.println("a >>> 2 = " + (a >>> 2)); // 15 (unsigned right shift)
    }
    
    // Praktyczne zastosowania operatorÃ³w bitowych
    public class BitoweOptymalizacje {
        // Sprawdzenie czy liczba jest parzysta (szybsze niÅ¼ % 2)
        public boolean isEven(int n) {
            return (n & 1) == 0;
        }
        
        // MnoÅ¼enie/dzielenie przez potÄ™gi 2
        public int multiplyBy8(int n) {
            return n << 3;  // szybsze niÅ¼ n * 8
        }
        
        public int divideBy4(int n) {
            return n >> 2;  // szybsze niÅ¼ n / 4
        }
        
        // Swap bez dodatkowej zmiennej
        public void swapWithoutTemp(int a, int b) {
            a = a ^ b;
            b = a ^ b;
            a = a ^ b;
            // Teraz a i b sÄ… zamienione
        }
        
        // Ustawienie/czyszczenie/sprawdzanie bitÃ³w
        public int setBit(int number, int position) {
            return number | (1 << position);
        }
        
        public int clearBit(int number, int position) {
            return number & ~(1 << position);
        }
        
        public boolean isBitSet(int number, int position) {
            return (number & (1 << position)) != 0;
        }
    }
}
```

##### Operatory a autoboxing/unboxing

```java
public class OperatoryAutoboxing {
    public void demonstracjaAutoboxing() {
        Integer a = 100;
        Integer b = 200;
        
        // Operatory arytmetyczne powodujÄ… unboxing
        Integer sum = a + b;  // unboxing a i b, dodawanie, autoboxing wyniku
        
        // Operatory porÃ³wnania teÅ¼
        boolean greater = a > b;  // unboxing obu operandÃ³w
        
        // Ale uwaga na ==!
        Integer x = 127;
        Integer y = 127;
        System.out.println(x == y);  // true (cache)
        
        Integer m = 128;
        Integer n = 128;
        System.out.println(m == n);  // false (poza cache)
        
        // Bezpieczne porÃ³wnywanie
        System.out.println(Objects.equals(m, n));  // true
    }
}
```

#### PuÅ‚apki i niuanse

##### Overflow i underflow

```java
public class OverflowUnderflow {
    public void demonstracjaOverflow() {
        // Integer overflow
        int maxInt = Integer.MAX_VALUE;
        int overflow = maxInt + 1;  // -2147483648 (wraparound)
        
        System.out.println("Max int: " + maxInt);
        System.out.println("Overflow: " + overflow);
        
        // Bezpieczne dodawanie (Java 8+)
        try {
            int safeSum = Math.addExact(maxInt, 1);
        } catch (ArithmeticException e) {
            System.out.println("Overflow detected!");
        }
        
        // Floating point overflow
        double maxDouble = Double.MAX_VALUE;
        double doubleOverflow = maxDouble * 2;  // Infinity
        
        System.out.println("Double overflow: " + doubleOverflow);
        System.out.println("Is infinite: " + Double.isInfinite(doubleOverflow));
    }
}
```

##### Floating point precision

```java
public class FloatingPointPrecision {
    public void demonstracjaPrecyzji() {
        // Klasyczny problem z floating point
        double result = 0.1 + 0.2;
        System.out.println(result);  // 0.30000000000000004, nie 0.3!
        
        // PorÃ³wnywanie floating point
        double a = 0.1 + 0.2;
        double b = 0.3;
        
        // Å¹le
        boolean equal = (a == b);  // false!
        
        // Dobrze - z tolerancjÄ…
        double epsilon = 1e-10;
        boolean equalWithTolerance = Math.abs(a - b) < epsilon;  // true
        
        // Jeszcze lepiej - BigDecimal dla precyzyjnych obliczeÅ„
        BigDecimal bd1 = new BigDecimal("0.1");
        BigDecimal bd2 = new BigDecimal("0.2");
        BigDecimal bd3 = new BigDecimal("0.3");
        
        BigDecimal sum = bd1.add(bd2);
        boolean exactEqual = sum.equals(bd3);  // true
    }
}
```

##### Operator instanceof i pattern matching

```java
public class InstanceofPatternMatching {
    // Tradycyjny instanceof (przed Java 14)
    public void traditionalInstanceof(Object obj) {
        if (obj instanceof String) {
            String str = (String) obj;  // explicit cast
            System.out.println("String length: " + str.length());
        }
    }
    
    // Pattern matching instanceof (Java 14+)
    public void patternMatchingInstanceof(Object obj) {
        if (obj instanceof String str) {  // pattern variable
            System.out.println("String length: " + str.length());  // no cast needed
        }
        
        // MoÅ¼na uÅ¼ywaÄ‡ w zÅ‚oÅ¼onych wyraÅ¼eniach
        if (obj instanceof String str && str.length() > 5) {
            System.out.println("Long string: " + str);
        }
    }
    
    // Sealed classes i pattern matching (Java 17+)
    public sealed interface Shape permits Circle, Rectangle, Triangle {}
    public record Circle(double radius) implements Shape {}
    public record Rectangle(double width, double height) implements Shape {}
    public record Triangle(double base, double height) implements Shape {}
    
    public double calculateArea(Shape shape) {
        return switch (shape) {
            case Circle(var radius) -> Math.PI * radius * radius;
            case Rectangle(var width, var height) -> width * height;
            case Triangle(var base, var height) -> 0.5 * base * height;
        };
    }
}
```

#### Wzorce i best practices

##### Null-safe operators pattern

```java
public class NullSafeOperators {
    // Symulacja null-safe navigation (jak ?. w innych jÄ™zykach)
    public static <T, R> R safeGet(T object, Function<T, R> getter) {
        return object != null ? getter.apply(object) : null;
    }
    
    public static <T, R> R safeGet(T object, Function<T, R> getter, R defaultValue) {
        return object != null ? getter.apply(object) : defaultValue;
    }
    
    // UÅ¼ycie
    public void demonstracja() {
        Person person = getPerson();  // moÅ¼e byÄ‡ null
        
        // Zamiast:
        String city = null;
        if (person != null && person.getAddress() != null) {
            city = person.getAddress().getCity();
        }
        
        // MoÅ¼esz uÅ¼yÄ‡:
        String safeCity = safeGet(person, p -> safeGet(p.getAddress(), Address::getCity));
        
        // Lub z Optional (jeszcze lepiej)
        String optionalCity = Optional.ofNullable(person)
            .map(Person::getAddress)
            .map(Address::getCity)
            .orElse("Unknown");
    }
}
```

##### Fluent interface z operatorami

```java
public class FluentCalculator {
    private double value;
    
    public FluentCalculator(double initialValue) {
        this.value = initialValue;
    }
    
    public FluentCalculator add(double operand) {
        this.value += operand;
        return this;
    }
    
    public FluentCalculator subtract(double operand) {
        this.value -= operand;
        return this;
    }
    
    public FluentCalculator multiply(double operand) {
        this.value *= operand;
        return this;
    }
    
    public FluentCalculator divide(double operand) {
        if (operand == 0) {
            throw new ArithmeticException("Division by zero");
        }
        this.value /= operand;
        return this;
    }
    
    public double result() {
        return value;
    }
    
    // UÅ¼ycie
    public static void main(String[] args) {
        double result = new FluentCalculator(10)
            .add(5)
            .multiply(2)
            .subtract(3)
            .divide(4)
            .result();  // ((10 + 5) * 2 - 3) / 4 = 6.75
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj klasÄ™ `SafeMath`, ktÃ³ra wykonuje operacje arytmetyczne z detekcjÄ… overflow/underflow i automatycznÄ… promocjÄ… typÃ³w.

**Zadanie Zaawansowane 2:** StwÃ³rz system flag bitowych do zarzÄ…dzania uprawnieniami uÅ¼ytkownikÃ³w, uÅ¼ywajÄ…c operatorÃ³w bitowych do efektywnego przechowywania i sprawdzania uprawnieÅ„.

**Zadanie Zaawansowane 3:** Zaprojektuj DSL (Domain Specific Language) dla obliczeÅ„ matematycznych, ktÃ³ry uÅ¼ywa przeciÄ…Å¼enia operatorÃ³w (przez metody) do tworzenia czytelnych wyraÅ¼eÅ„.

#### â“ Pytania Kontrolne - Poziom Senior

1. Dlaczego operatory bitowe sÄ… szybsze od operacji arytmetycznych dla potÄ™g liczby 2?
2. Jak wpÅ‚ywa na wydajnoÅ›Ä‡ czÄ™ste uÅ¼ywanie operatorÃ³w z autoboxing?
3. Jakie sÄ… implikacje bezpieczeÅ„stwa zwiÄ…zane z overflow w operacjach arytmetycznych?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public class Kalkulator {
    public static double dodaj(double a, double b) {
        return a + b;
    }
    
    public static double odejmij(double a, double b) {
        return a - b;
    }
    
    public static double pomnoz(double a, double b) {
        return a * b;
    }
    
    public static double podziel(double a, double b) {
        if (b == 0) {
            throw new ArithmeticException("Nie moÅ¼na dzieliÄ‡ przez zero!");
        }
        return a / b;
    }
    
    public static double reszta(double a, double b) {
        if (b == 0) {
            throw new ArithmeticException("Nie moÅ¼na dzieliÄ‡ przez zero!");
        }
        return a % b;
    }
}
```

**Zadanie 2:**
```java
public static boolean czyRokPrzestepny(int rok) {
    return (rok % 4 == 0 && rok % 100 != 0) || (rok % 400 == 0);
}

// Test:
System.out.println(czyRokPrzestepny(2000)); // true (podzielny przez 400)
System.out.println(czyRokPrzestepny(1900)); // false (podzielny przez 100, ale nie przez 400)
System.out.println(czyRokPrzestepny(2024)); // true (podzielny przez 4, ale nie przez 100)
```

**Zadanie 3:**
```java
public class InkrementacjaTest {
    public static void main(String[] args) {
        // Pre-inkrementacja
        int i = 5;
        for (int j = 0; j < 3; j++) {
            System.out.println("Pre: " + (++i));  // 6, 7, 8
        }
        
        // Post-inkrementacja
        int k = 5;
        for (int j = 0; j < 3; j++) {
            System.out.println("Post: " + (k++));  // 5, 6, 7
        }
    }
}
```

**Pytania kontrolne:**
1. `i++` uÅ¼ywa wartoÅ›Ä‡, potem zwiÄ™ksza; `++i` zwiÄ™ksza, potem uÅ¼ywa wartoÅ›Ä‡.
2. Oba operandy to `int`, wiÄ™c wynik teÅ¼ jest `int` - dzielenie caÅ‚kowite obcina czÄ™Å›Ä‡ uÅ‚amkowÄ….
3. W `&&` jeÅ›li pierwszy operand to `false`, drugi nie jest sprawdzany. W `||` jeÅ›li pierwszy to `true`, drugi nie jest sprawdzany.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class SafeMath {
    public static int addExact(int a, int b) {
        long result = (long) a + (long) b;
        if (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE) {
            throw new ArithmeticException("Integer overflow");
        }
        return (int) result;
    }
    
    public static long addExact(long a, long b) {
        long result = a + b;
        // SprawdÅº overflow
        if (((a ^ result) & (b ^ result)) < 0) {
            throw new ArithmeticException("Long overflow");
        }
        return result;
    }
    
    public static BigInteger addExact(BigInteger a, BigInteger b) {
        return a.add(b);  // BigInteger nie ma overflow
    }
    
    // Automatyczna promocja typÃ³w
    public static Number add(Number a, Number b) {
        if (a instanceof BigInteger || b instanceof BigInteger) {
            return toBigInteger(a).add(toBigInteger(b));
        }
        if (a instanceof BigDecimal || b instanceof BigDecimal) {
            return toBigDecimal(a).add(toBigDecimal(b));
        }
        if (a instanceof Double || b instanceof Double) {
            return a.doubleValue() + b.doubleValue();
        }
        if (a instanceof Float || b instanceof Float) {
            return a.floatValue() + b.floatValue();
        }
        if (a instanceof Long || b instanceof Long) {
            return addExact(a.longValue(), b.longValue());
        }
        return addExact(a.intValue(), b.intValue());
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class PermissionSystem {
    // Definicja uprawnieÅ„ jako potÄ™gi 2
    public static final int READ = 1;      // 0001
    public static final int WRITE = 2;     // 0010
    public static final int EXECUTE = 4;   // 0100
    public static final int DELETE = 8;    // 1000
    public static final int ADMIN = 16;    // 10000
    
    private int permissions = 0;
    
    // Dodaj uprawnienie
    public void grantPermission(int permission) {
        permissions |= permission;
    }
    
    // UsuÅ„ uprawnienie
    public void revokePermission(int permission) {
        permissions &= ~permission;
    }
    
    // SprawdÅº uprawnienie
    public boolean hasPermission(int permission) {
        return (permissions & permission) == permission;
    }
    
    // SprawdÅº czy ma wszystkie uprawnienia
    public boolean hasAllPermissions(int... requiredPermissions) {
        int combined = 0;
        for (int perm : requiredPermissions) {
            combined |= perm;
        }
        return (permissions & combined) == combined;
    }
    
    // SprawdÅº czy ma ktÃ³rekolwiek z uprawnieÅ„
    public boolean hasAnyPermission(int... requiredPermissions) {
        for (int perm : requiredPermissions) {
            if ((permissions & perm) != 0) {
                return true;
            }
        }
        return false;
    }
    
    // UÅ¼ycie
    public static void main(String[] args) {
        PermissionSystem user = new PermissionSystem();
        user.grantPermission(READ | WRITE);  // Nadaj READ i WRITE
        
        System.out.println(user.hasPermission(READ));    // true
        System.out.println(user.hasPermission(DELETE));  // false
        System.out.println(user.hasAllPermissions(READ, WRITE)); // true
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class MathDSL {
    private final double value;
    
    private MathDSL(double value) {
        this.value = value;
    }
    
    public static MathDSL val(double value) {
        return new MathDSL(value);
    }
    
    public MathDSL plus(double other) {
        return new MathDSL(this.value + other);
    }
    
    public MathDSL plus(MathDSL other) {
        return new MathDSL(this.value + other.value);
    }
    
    public MathDSL minus(double other) {
        return new MathDSL(this.value - other);
    }
    
    public MathDSL times(double other) {
        return new MathDSL(this.value * other);
    }
    
    public MathDSL dividedBy(double other) {
        return new MathDSL(this.value / other);
    }
    
    public MathDSL pow(double exponent) {
        return new MathDSL(Math.pow(this.value, exponent));
    }
    
    public double result() {
        return value;
    }
    
    // UÅ¼ycie - czytelne wyraÅ¼enia matematyczne
    public static void main(String[] args) {
        double result = val(10)
            .plus(5)
            .times(2)
            .minus(val(3).times(4))
            .dividedBy(2)
            .pow(2)
            .result();  // ((10 + 5) * 2 - (3 * 4)) / 2)^2 = 49
    }
}
```

**Pytania kontrolne:**
1. Operatory bitowe dziaÅ‚ajÄ… bezpoÅ›rednio na bitach w rejestrach CPU, podczas gdy operacje arytmetyczne mogÄ… wymagaÄ‡ dodatkowych cykli procesora.
2. Autoboxing z operatorami tworzy nowe obiekty w kaÅ¼dej operacji, zwiÄ™kszajÄ…c presjÄ™ na GC i zmniejszajÄ…c wydajnoÅ›Ä‡.
3. Overflow moÅ¼e prowadziÄ‡ do nieprzewidywalnych wynikÃ³w, potencjalnych luk bezpieczeÅ„stwa (np. buffer overflow) i bÅ‚Ä™dÃ³w logicznych w aplikacji.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Teraz masz solidne podstawy operatorÃ³w w Javie. Od prostych dodawaÅ„ po zaawansowane operacje bitowe - to wszystko bÄ™dzie Ci towarzyszyÄ‡ w codziennej pracy. W nastÄ™pnym rozdziale porozmawiamy o warunkach - if, else, switch i innych Å¼yciowych wyborach, ktÃ³re TwÃ³j kod musi podejmowaÄ‡!*

---

*ğŸ’¡ PamiÄ™taj: Operatory to narzÄ™dzia - uÅ¼ywaj ich Å›wiadomie i zawsze myÅ›l o czytelnoÅ›ci kodu dla innych programistek!*


## 5. Warunki: if, else, switch i inne Å¼yciowe wybory

*CzeÅ›Ä‡! DziÅ› porozmawiamy o jednej z najwaÅ¼niejszych rzeczy w programowaniu - podejmowaniu decyzji. KaÅ¼dy program musi umieÄ‡ wybieraÄ‡ miÄ™dzy rÃ³Å¼nymi opcjami, reagowaÄ‡ na rÃ³Å¼ne sytuacje i podejmowaÄ‡ "Å¼yciowe wybory". W Javie mamy do tego kilka narzÄ™dzi, od prostego if-else po nowoczesne switch expressions. Przygotuj siÄ™ na poznanie wszystkich sposobÃ³w, jak TwÃ³j kod moÅ¼e myÅ›leÄ‡!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

Instrukcje warunkowe to sposÃ³b, w jaki TwÃ³j program podejmuje decyzje. To jak rozwidlenie drogi - w zaleÅ¼noÅ›ci od warunkÃ³w, program idzie w jednÄ… lub drugÄ… stronÄ™. Bez nich kaÅ¼dy program robiÅ‚by zawsze to samo, niezaleÅ¼nie od sytuacji.

```java
// Podstawowa struktura if
int wiek = 20;

if (wiek >= 18) {
    System.out.println("JesteÅ› peÅ‚noletnia!");
}

// If z else
if (wiek >= 18) {
    System.out.println("JesteÅ› peÅ‚noletnia!");
} else {
    System.out.println("JesteÅ› niepeÅ‚noletnia.");
}

// If-else if-else (Å‚aÅ„cuch warunkÃ³w)
if (wiek < 13) {
    System.out.println("JesteÅ› dzieckiem.");
} else if (wiek < 18) {
    System.out.println("JesteÅ› nastolatkÄ….");
} else if (wiek < 65) {
    System.out.println("JesteÅ› dorosÅ‚a.");
} else {
    System.out.println("JesteÅ› seniorkÄ….");
}
```

#### Dlaczego to waÅ¼ne?

Bez instrukcji warunkowych programy byÅ‚yby jak roboty wykonujÄ…ce zawsze te same czynnoÅ›ci. Warunki pozwalajÄ… programom reagowaÄ‡ na rÃ³Å¼ne sytuacje, dostosowywaÄ‡ siÄ™ do danych wejÅ›ciowych i podejmowaÄ‡ inteligentne decyzje. To podstawa interaktywnoÅ›ci i logiki biznesowej.

#### Jak to dziaÅ‚a w praktyce?

**Podstawowe if-else:**

```java
public class PodstawoweWarunki {
    public static void main(String[] args) {
        int temperatura = 25;
        
        // Prosty warunek
        if (temperatura > 30) {
            System.out.println("Jest gorÄ…co!");
        }
        
        // Warunek z else
        if (temperatura > 20) {
            System.out.println("Przyjemna temperatura.");
        } else {
            System.out.println("TrochÄ™ chÅ‚odno.");
        }
        
        // ZÅ‚oÅ¼one warunki z operatorami logicznymi
        boolean jestSlonecznie = true;
        if (temperatura > 25 && jestSlonecznie) {
            System.out.println("Idealny dzieÅ„ na spacer!");
        }
        
        // Warunki z OR
        if (temperatura < 0 || temperatura > 40) {
            System.out.println("Ekstremalna temperatura!");
        }
    }
}
```

**Switch - tradycyjna wersja:**

```java
public class TradycyjnySwitch {
    public static void main(String[] args) {
        int dzienTygodnia = 3;
        String nazwaDnia;
        
        switch (dzienTygodnia) {
            case 1:
                nazwaDnia = "PoniedziaÅ‚ek";
                break;
            case 2:
                nazwaDnia = "Wtorek";
                break;
            case 3:
                nazwaDnia = "Åšroda";
                break;
            case 4:
                nazwaDnia = "Czwartek";
                break;
            case 5:
                nazwaDnia = "PiÄ…tek";
                break;
            case 6:
            case 7:
                nazwaDnia = "Weekend";
                break;
            default:
                nazwaDnia = "NieprawidÅ‚owy dzieÅ„";
                break;
        }
        
        System.out.println("DziÅ› jest: " + nazwaDnia);
    }
}
```

**Switch expressions (Java 14+):**

```java
public class NowoczesnySwitch {
    public static void main(String[] args) {
        int dzienTygodnia = 3;
        
        // Switch expression - zwraca wartoÅ›Ä‡
        String nazwaDnia = switch (dzienTygodnia) {
            case 1 -> "PoniedziaÅ‚ek";
            case 2 -> "Wtorek";
            case 3 -> "Åšroda";
            case 4 -> "Czwartek";
            case 5 -> "PiÄ…tek";
            case 6, 7 -> "Weekend";  // MoÅ¼na grupowaÄ‡ przypadki
            default -> "NieprawidÅ‚owy dzieÅ„";
        };
        
        System.out.println("DziÅ› jest: " + nazwaDnia);
        
        // Switch z blokami kodu
        String opis = switch (dzienTygodnia) {
            case 1 -> {
                System.out.println("PoczÄ…tek tygodnia!");
                yield "PoniedziaÅ‚ek - czas na nowe wyzwania";
            }
            case 5 -> {
                System.out.println("Prawie weekend!");
                yield "PiÄ…tek - ostatni dzieÅ„ pracy";
            }
            default -> "ZwykÅ‚y dzieÅ„";
        };
        
        System.out.println(opis);
    }
}
```

**Warunki z String:**

```java
public class WarunkiZString {
    public static void main(String[] args) {
        String komenda = "start";
        
        // If z String
        if ("start".equals(komenda)) {
            System.out.println("Uruchamianie aplikacji...");
        } else if ("stop".equals(komenda)) {
            System.out.println("Zatrzymywanie aplikacji...");
        } else if ("restart".equals(komenda)) {
            System.out.println("Restartowanie aplikacji...");
        } else {
            System.out.println("Nieznana komenda: " + komenda);
        }
        
        // Switch z String (Java 7+)
        String akcja = switch (komenda) {
            case "start" -> "Uruchamianie...";
            case "stop" -> "Zatrzymywanie...";
            case "restart" -> "Restartowanie...";
            default -> "Nieznana komenda";
        };
        
        System.out.println(akcja);
    }
}
```

#### PuÅ‚apki, na ktÃ³re warto uwaÅ¼aÄ‡

**PuÅ‚apka 1: Brak break w switch**

```java
int liczba = 2;
switch (liczba) {
    case 1:
        System.out.println("Jeden");
        // Brak break! Wykona siÄ™ teÅ¼ case 2
    case 2:
        System.out.println("Dwa");
        // Brak break! Wykona siÄ™ teÅ¼ case 3
    case 3:
        System.out.println("Trzy");
        break;
}
// Wypisze: "Dwa" i "Trzy"
```

**PuÅ‚apka 2: PorÃ³wnywanie String z ==**

```java
String input = new String("hello");
if (input == "hello") {  // Å¹LE! PorÃ³wnuje referencje
    System.out.println("To nie zadziaÅ‚a");
}

if ("hello".equals(input)) {  // DOBRZE!
    System.out.println("To zadziaÅ‚a");
}
```

**PuÅ‚apka 3: Null w warunkach**

```java
String tekst = null;
if (tekst.equals("hello")) {  // NullPointerException!
    System.out.println("Nigdy siÄ™ nie wykona");
}

// Bezpieczne podejÅ›cie:
if ("hello".equals(tekst)) {  // Bezpieczne
    System.out.println("To jest bezpieczne");
}

// Lub z Objects.equals:
if (Objects.equals(tekst, "hello")) {  // TeÅ¼ bezpieczne
    System.out.println("To teÅ¼ jest bezpieczne");
}
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **Zawsze uÅ¼ywaj nawiasÃ³w klamrowych** `{}` nawet dla jednej linii - czytelnoÅ›Ä‡!
- **PamiÄ™taj o break** w tradycyjnym switch
- **UÅ¼ywaj `equals()`** do porÃ³wnywania String, nie `==`
- **Sprawdzaj null** przed wywoÅ‚aniem metod na obiektach
- **Switch expressions** sÄ… czÄ™sto czytelniejsze niÅ¼ tradycyjny switch

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** Napisz program, ktÃ³ry na podstawie oceny (1-6) wypisuje odpowiedni komentarz.

```java
public static String komentarzOceny(int ocena) {
    // UÅ¼yj switch expression
}
```

**Zadanie 2:** StwÃ³rz kalkulator BMI, ktÃ³ry nie tylko oblicza BMI, ale teÅ¼ kategoryzuje wynik (niedowaga, norma, nadwaga, otyÅ‚oÅ›Ä‡).

**Zadanie 3:** Napisz metodÄ™, ktÃ³ra sprawdza, czy podany rok jest przestÄ™pny, uÅ¼ywajÄ…c warunkÃ³w if-else.

#### â“ Pytania Kontrolne - Poziom Junior

1. Jaka jest rÃ³Å¼nica miÄ™dzy tradycyjnym switch a switch expression?
2. Dlaczego `"hello".equals(zmienna)` jest bezpieczniejsze niÅ¼ `zmienna.equals("hello")`?
3. Co siÄ™ stanie, jeÅ›li zapomnisz `break` w tradycyjnym switch?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

Instrukcje warunkowe w Javie to nie tylko syntactic sugar - to fundamentalne konstrukcje kontroli przepÅ‚ywu, ktÃ³re majÄ… gÅ‚Ä™bokie implikacje dla wydajnoÅ›ci, czytelnoÅ›ci i maintainability kodu. Przyjrzyjmy siÄ™ im z perspektywy architektury jÄ™zyka i optymalizacji JVM.

##### Optymalizacje JVM dla instrukcji warunkowych

```java
public class OptymalizacjeWarunkow {
    // JVM optymalizuje czÄ™ste Å›cieÅ¼ki (branch prediction)
    public int optimizedBranching(int value) {
        // JeÅ›li ta Å›cieÅ¼ka jest czÄ™sto wykonywana, JVM jÄ… zoptymalizuje
        if (value > 0) {  // "hot path"
            return value * 2;
        } else {  // "cold path"
            return value * -1;
        }
    }
    
    // Eliminacja martwego kodu
    public void deadCodeElimination() {
        final boolean DEBUG = false;
        
        if (DEBUG) {
            System.out.println("Debug info");  // Kompilator usunie ten kod
        }
        
        // JVM moÅ¼e teÅ¼ optymalizowaÄ‡ runtime
        boolean condition = Math.random() > 0.5;
        if (condition) {
            // JeÅ›li JVM stwierdzi, Å¼e ta Å›cieÅ¼ka nigdy nie jest wykonywana,
            // moÅ¼e jÄ… usunÄ…Ä‡ z skompilowanego kodu
        }
    }
    
    // Inlining metod w warunkach
    public boolean expensiveCondition() {
        // Ta metoda moÅ¼e zostaÄ‡ "wstawiona" bezpoÅ›rednio do miejsca wywoÅ‚ania
        return System.currentTimeMillis() % 2 == 0;
    }
    
    public void methodInlining() {
        if (expensiveCondition()) {  // MoÅ¼e zostaÄ‡ zastÄ…pione bezpoÅ›rednim kodem
            System.out.println("Even timestamp");
        }
    }
}
```

##### Pattern matching i sealed classes

```java
// Sealed classes dla exhaustive pattern matching
public sealed interface PaymentMethod 
    permits CreditCard, DebitCard, PayPal, BankTransfer {
}

public record CreditCard(String number, String cvv) implements PaymentMethod {}
public record DebitCard(String number, String pin) implements PaymentMethod {}
public record PayPal(String email) implements PaymentMethod {}
public record BankTransfer(String accountNumber, String routingNumber) implements PaymentMethod {}

public class PaymentProcessor {
    // Exhaustive pattern matching (Java 17+)
    public double calculateFee(PaymentMethod method, double amount) {
        return switch (method) {
            case CreditCard(var number, var cvv) -> amount * 0.03;  // 3% fee
            case DebitCard(var number, var pin) -> amount * 0.01;   // 1% fee
            case PayPal(var email) -> amount * 0.025;               // 2.5% fee
            case BankTransfer(var account, var routing) -> 5.0;     // flat $5 fee
            // Nie potrzeba default - kompilator wie, Å¼e wszystkie przypadki sÄ… pokryte
        };
    }
    
    // Guard conditions w pattern matching
    public String categorizePayment(PaymentMethod method, double amount) {
        return switch (method) {
            case CreditCard cc when amount > 1000 -> "High-value credit transaction";
            case CreditCard cc -> "Regular credit transaction";
            case DebitCard dd when amount < 10 -> "Micro debit transaction";
            case DebitCard dd -> "Regular debit transaction";
            case PayPal pp when pp.email().endsWith("@business.com") -> "Business PayPal";
            case PayPal pp -> "Personal PayPal";
            case BankTransfer bt -> "Bank transfer";
        };
    }
}
```

##### Zaawansowane wzorce warunkowe

```java
public class ZaawansowaneWzorce {
    // Null Object Pattern
    public interface Logger {
        void log(String message);
    }
    
    public static class ConsoleLogger implements Logger {
        public void log(String message) {
            System.out.println(message);
        }
    }
    
    public static class NullLogger implements Logger {
        public void log(String message) {
            // Nic nie rÃ³b
        }
    }
    
    // Zamiast sprawdzania null w kaÅ¼dym miejscu
    public void processWithNullChecks(Logger logger, String message) {
        if (logger != null) {
            logger.log(message);
        }
    }
    
    // UÅ¼ywamy Null Object Pattern
    public void processWithNullObject(Logger logger, String message) {
        logger.log(message);  // logger nigdy nie jest null
    }
    
    // Strategy Pattern z enum
    public enum DiscountStrategy {
        NONE {
            @Override
            public double apply(double price) {
                return price;
            }
        },
        STUDENT {
            @Override
            public double apply(double price) {
                return price * 0.9;  // 10% discount
            }
        },
        SENIOR {
            @Override
            public double apply(double price) {
                return price * 0.8;  // 20% discount
            }
        },
        VIP {
            @Override
            public double apply(double price) {
                return price * 0.7;  // 30% discount
            }
        };
        
        public abstract double apply(double price);
    }
    
    // Zamiast dÅ‚ugiego if-else if
    public double calculatePrice(double basePrice, DiscountStrategy strategy) {
        return strategy.apply(basePrice);
    }
}
```

#### PuÅ‚apki i niuanse

##### Performance considerations

```java
public class PerformanceConsiderations {
    // KolejnoÅ›Ä‡ warunkÃ³w ma znaczenie
    public String categorizeUser(User user) {
        // UmieÅ›Ä‡ najczÄ™stsze przypadki na poczÄ…tku
        if (user.isRegularUser()) {      // 80% przypadkÃ³w
            return "regular";
        } else if (user.isPremiumUser()) { // 15% przypadkÃ³w
            return "premium";
        } else if (user.isAdminUser()) {   // 4% przypadkÃ³w
            return "admin";
        } else if (user.isGuestUser()) {   // 1% przypadkÃ³w
            return "guest";
        }
        return "unknown";
    }
    
    // Unikaj kosztownych operacji w warunkach
    public boolean expensiveConditionBad(String data) {
        // Å¹le - kosztowna operacja wykonywana za kaÅ¼dym razem
        if (data.toLowerCase().trim().startsWith("prefix")) {
            return true;
        }
        return false;
    }
    
    public boolean expensiveConditionGood(String data) {
        // Dobrze - wykonaj kosztownÄ… operacjÄ™ raz
        String normalized = data.toLowerCase().trim();
        if (normalized.startsWith("prefix")) {
            return true;
        }
        return false;
    }
    
    // Switch vs if-else performance
    public String switchVsIfElse(int value) {
        // Dla wielu przypadkÃ³w switch moÅ¼e byÄ‡ szybszy (jump table)
        return switch (value) {
            case 1 -> "one";
            case 2 -> "two";
            case 3 -> "three";
            // ... wiele przypadkÃ³w
            case 100 -> "hundred";
            default -> "other";
        };
    }
}
```

##### Problemy z floating point w warunkach

```java
public class FloatingPointConditions {
    public void demonstrateFloatingPointIssues() {
        double a = 0.1 + 0.2;
        double b = 0.3;
        
        // To moÅ¼e nie zadziaÅ‚aÄ‡ jak oczekujesz!
        if (a == b) {
            System.out.println("Equal");  // MoÅ¼e siÄ™ nie wykonaÄ‡
        }
        
        // Poprawne porÃ³wnywanie floating point
        double epsilon = 1e-10;
        if (Math.abs(a - b) < epsilon) {
            System.out.println("Equal within tolerance");
        }
        
        // Lub uÅ¼yj BigDecimal dla precyzyjnych obliczeÅ„
        BigDecimal bd1 = new BigDecimal("0.1").add(new BigDecimal("0.2"));
        BigDecimal bd2 = new BigDecimal("0.3");
        if (bd1.equals(bd2)) {
            System.out.println("Exactly equal");
        }
    }
}
```

##### Concurrent access w warunkach

```java
public class ConcurrentConditions {
    private volatile boolean flag = false;
    private final Object lock = new Object();
    
    // Race condition w warunkach
    public void raceConditionExample() {
        // Thread 1
        if (!flag) {
            // Thread 2 moÅ¼e zmieniÄ‡ flag tutaj!
            flag = true;
            // MoÅ¼e prowadziÄ‡ do niespÃ³jnego stanu
        }
    }
    
    // Bezpieczna wersja
    public void threadSafeVersion() {
        synchronized (lock) {
            if (!flag) {
                flag = true;
                // Atomowa operacja
            }
        }
    }
    
    // Double-checked locking (dla lazy initialization)
    private volatile ExpensiveObject instance;
    
    public ExpensiveObject getInstance() {
        if (instance == null) {  // Pierwszy check bez synchronizacji
            synchronized (this) {
                if (instance == null) {  // Drugi check z synchronizacjÄ…
                    instance = new ExpensiveObject();
                }
            }
        }
        return instance;
    }
}
```

#### Wzorce i best practices

##### Command Pattern z switch expressions

```java
public class CommandPattern {
    public sealed interface Command permits StartCommand, StopCommand, RestartCommand {}
    public record StartCommand() implements Command {}
    public record StopCommand() implements Command {}
    public record RestartCommand() implements Command {}
    
    public class ServiceController {
        private boolean isRunning = false;
        
        public String execute(Command command) {
            return switch (command) {
                case StartCommand() -> {
                    if (!isRunning) {
                        isRunning = true;
                        yield "Service started";
                    } else {
                        yield "Service already running";
                    }
                }
                case StopCommand() -> {
                    if (isRunning) {
                        isRunning = false;
                        yield "Service stopped";
                    } else {
                        yield "Service not running";
                    }
                }
                case RestartCommand() -> {
                    isRunning = false;
                    isRunning = true;
                    yield "Service restarted";
                }
            };
        }
    }
}
```

##### Specification Pattern

```java
public class SpecificationPattern {
    @FunctionalInterface
    public interface Specification<T> {
        boolean isSatisfiedBy(T candidate);
        
        default Specification<T> and(Specification<T> other) {
            return candidate -> this.isSatisfiedBy(candidate) && other.isSatisfiedBy(candidate);
        }
        
        default Specification<T> or(Specification<T> other) {
            return candidate -> this.isSatisfiedBy(candidate) || other.isSatisfiedBy(candidate);
        }
        
        default Specification<T> not() {
            return candidate -> !this.isSatisfiedBy(candidate);
        }
    }
    
    // PrzykÅ‚ad uÅ¼ycia
    public class UserSpecifications {
        public static Specification<User> isAdult() {
            return user -> user.getAge() >= 18;
        }
        
        public static Specification<User> hasEmail() {
            return user -> user.getEmail() != null && !user.getEmail().isEmpty();
        }
        
        public static Specification<User> isPremium() {
            return user -> user.getSubscriptionType() == SubscriptionType.PREMIUM;
        }
    }
    
    // UÅ¼ycie
    public void filterUsers(List<User> users) {
        Specification<User> eligibleForPromotion = 
            UserSpecifications.isAdult()
                .and(UserSpecifications.hasEmail())
                .and(UserSpecifications.isPremium().not());
        
        List<User> eligible = users.stream()
            .filter(eligibleForPromotion::isSatisfiedBy)
            .collect(Collectors.toList());
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj system reguÅ‚ biznesowych uÅ¼ywajÄ…c pattern matching i sealed classes, ktÃ³ry moÅ¼e byÄ‡ Å‚atwo rozszerzany o nowe reguÅ‚y.

**Zadanie Zaawansowane 2:** StwÃ³rz benchmark porÃ³wnujÄ…cy wydajnoÅ›Ä‡ rÃ³Å¼nych podejÅ›Ä‡ do instrukcji warunkowych (if-else vs switch vs enum strategy vs lookup table).

**Zadanie Zaawansowane 3:** Zaprojektuj thread-safe state machine uÅ¼ywajÄ…c enum i switch expressions, z obsÅ‚ugÄ… concurrent transitions.

#### â“ Pytania Kontrolne - Poziom Senior

1. Jak JVM optymalizuje instrukcje warunkowe i co to jest branch prediction?
2. Jakie sÄ… zalety pattern matching z sealed classes w porÃ³wnaniu do tradycyjnych podejÅ›Ä‡?
3. Dlaczego double-checked locking wymaga volatile i jakie sÄ… alternatywy?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static String komentarzOceny(int ocena) {
    return switch (ocena) {
        case 1 -> "Niedostateczny - trzeba popracowaÄ‡!";
        case 2 -> "DopuszczajÄ…cy - moÅ¼na lepiej!";
        case 3 -> "Dostateczny - w porzÄ…dku.";
        case 4 -> "Dobry - Å›wietna robota!";
        case 5 -> "Bardzo dobry - brawo!";
        case 6 -> "CelujÄ…cy - fantastycznie!";
        default -> "NieprawidÅ‚owa ocena";
    };
}
```

**Zadanie 2:**
```java
public class KalkulatorBMI {
    public static double obliczBMI(double waga, double wzrost) {
        return waga / (wzrost * wzrost);
    }
    
    public static String kategoriaBMI(double bmi) {
        if (bmi < 18.5) {
            return "Niedowaga";
        } else if (bmi < 25) {
            return "Waga prawidÅ‚owa";
        } else if (bmi < 30) {
            return "Nadwaga";
        } else {
            return "OtyÅ‚oÅ›Ä‡";
        }
    }
    
    public static void analizaBMI(double waga, double wzrost) {
        double bmi = obliczBMI(waga, wzrost);
        String kategoria = kategoriaBMI(bmi);
        System.out.printf("BMI: %.2f - %s%n", bmi, kategoria);
    }
}
```

**Zadanie 3:**
```java
public static boolean czyRokPrzestepny(int rok) {
    if (rok % 400 == 0) {
        return true;  // Podzielny przez 400 - przestÄ™pny
    } else if (rok % 100 == 0) {
        return false; // Podzielny przez 100, ale nie przez 400 - nie przestÄ™pny
    } else if (rok % 4 == 0) {
        return true;  // Podzielny przez 4, ale nie przez 100 - przestÄ™pny
    } else {
        return false; // Nie podzielny przez 4 - nie przestÄ™pny
    }
}
```

**Pytania kontrolne:**
1. Tradycyjny switch wymaga `break` i nie zwraca wartoÅ›ci. Switch expression zwraca wartoÅ›Ä‡ i nie wymaga `break`.
2. JeÅ›li `zmienna` jest `null`, to `zmienna.equals("hello")` rzuci NPE, ale `"hello".equals(zmienna)` zwrÃ³ci `false`.
3. WykonajÄ… siÄ™ wszystkie kolejne case'y aÅ¼ do napotkania `break` lub koÅ„ca switch (fall-through behavior).

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class BusinessRulesEngine {
    public sealed interface Rule permits AgeRule, IncomeRule, CreditScoreRule, CompositeRule {}
    
    public record AgeRule(int minAge, int maxAge) implements Rule {}
    public record IncomeRule(double minIncome) implements Rule {}
    public record CreditScoreRule(int minScore) implements Rule {}
    public record CompositeRule(Rule left, LogicalOperator operator, Rule right) implements Rule {}
    
    public enum LogicalOperator { AND, OR }
    
    public record Customer(int age, double income, int creditScore) {}
    
    public class RuleEvaluator {
        public boolean evaluate(Rule rule, Customer customer) {
            return switch (rule) {
                case AgeRule(var minAge, var maxAge) -> 
                    customer.age() >= minAge && customer.age() <= maxAge;
                    
                case IncomeRule(var minIncome) -> 
                    customer.income() >= minIncome;
                    
                case CreditScoreRule(var minScore) -> 
                    customer.creditScore() >= minScore;
                    
                case CompositeRule(var left, var operator, var right) -> switch (operator) {
                    case AND -> evaluate(left, customer) && evaluate(right, customer);
                    case OR -> evaluate(left, customer) || evaluate(right, customer);
                };
            };
        }
    }
    
    // UÅ¼ycie
    public void example() {
        Rule loanEligibility = new CompositeRule(
            new AgeRule(18, 65),
            LogicalOperator.AND,
            new CompositeRule(
                new IncomeRule(50000),
                LogicalOperator.AND,
                new CreditScoreRule(650)
            )
        );
        
        Customer customer = new Customer(30, 60000, 700);
        RuleEvaluator evaluator = new RuleEvaluator();
        boolean eligible = evaluator.evaluate(loanEligibility, customer);
    }
}
```

**Zadanie Zaawansowane 2:**
```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class ConditionalBenchmark {
    private static final int[] testValues = IntStream.range(0, 1000).toArray();
    
    @Benchmark
    public int ifElseChain() {
        int sum = 0;
        for (int value : testValues) {
            if (value < 100) sum += 1;
            else if (value < 200) sum += 2;
            else if (value < 300) sum += 3;
            else if (value < 400) sum += 4;
            else sum += 5;
        }
        return sum;
    }
    
    @Benchmark
    public int switchStatement() {
        int sum = 0;
        for (int value : testValues) {
            sum += switch (value / 100) {
                case 0 -> 1;
                case 1 -> 2;
                case 2 -> 3;
                case 3 -> 4;
                default -> 5;
            };
        }
        return sum;
    }
    
    @Benchmark
    public int lookupTable() {
        int[] lookup = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int value : testValues) {
            int index = Math.min(value / 100, 4);
            sum += lookup[index];
        }
        return sum;
    }
    
    // Wyniki pokazujÄ…, Å¼e lookup table jest najszybszy dla prostych przypadkÃ³w
}
```

**Zadanie Zaawansowane 3:**
```java
public class ThreadSafeStateMachine {
    public enum State {
        IDLE, STARTING, RUNNING, STOPPING, ERROR
    }
    
    public enum Event {
        START, STOP, ERROR, RESET
    }
    
    private volatile State currentState = State.IDLE;
    private final Object stateLock = new Object();
    
    public State transition(Event event) {
        synchronized (stateLock) {
            State newState = switch (currentState) {
                case IDLE -> switch (event) {
                    case START -> State.STARTING;
                    case ERROR -> State.ERROR;
                    default -> currentState;
                };
                
                case STARTING -> switch (event) {
                    case START -> State.RUNNING;  // Transition completed
                    case ERROR -> State.ERROR;
                    case STOP -> State.STOPPING;
                    default -> currentState;
                };
                
                case RUNNING -> switch (event) {
                    case STOP -> State.STOPPING;
                    case ERROR -> State.ERROR;
                    default -> currentState;
                };
                
                case STOPPING -> switch (event) {
                    case STOP -> State.IDLE;  // Transition completed
                    case ERROR -> State.ERROR;
                    default -> currentState;
                };
                
                case ERROR -> switch (event) {
                    case RESET -> State.IDLE;
                    default -> currentState;
                };
            };
            
            if (newState != currentState) {
                State oldState = currentState;
                currentState = newState;
                notifyStateChange(oldState, newState);
            }
            
            return currentState;
        }
    }
    
    private void notifyStateChange(State from, State to) {
        // Notify listeners about state change
        System.out.printf("State changed: %s -> %s%n", from, to);
    }
    
    public State getCurrentState() {
        return currentState;
    }
}
```

**Pytania kontrolne:**
1. JVM uÅ¼ywa branch prediction do przewidywania, ktÃ³ra Å›cieÅ¼ka bÄ™dzie wykonana, i optymalizuje kod dla czÄ™stych Å›cieÅ¼ek. MoÅ¼e teÅ¼ eliminowaÄ‡ martwy kod i inlinowaÄ‡ metody.
2. Pattern matching z sealed classes zapewnia exhaustiveness checking w compile time, lepszÄ… czytelnoÅ›Ä‡ i type safety, eliminujÄ…c potrzebÄ™ default cases.
3. Volatile zapewnia visibility i ordering guarantees. Alternatywy to initialization-on-demand holder pattern lub enum singleton.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Teraz masz peÅ‚ne zrozumienie instrukcji warunkowych w Javie - od podstawowych if-else po zaawansowane pattern matching. Ta wiedza bÄ™dzie fundamentem dla wszystkich decyzji, ktÃ³re TwÃ³j kod bÄ™dzie musiaÅ‚ podejmowaÄ‡. W nastÄ™pnym rozdziale porozmawiamy o pÄ™tlach - for, while i innych sposobach na "wracanie do punktu wyjÅ›cia"!*

---

*ğŸ’¡ PamiÄ™taj: Dobry kod to kod, ktÃ³ry podejmuje mÄ…dre decyzje. UÅ¼ywaj odpowiednich konstrukcji warunkowych dla kaÅ¼dej sytuacji!*


## 6. PÄ™tle: for, while, czyli wracamy do punktu wyjÅ›cia

*CzeÅ›Ä‡! DziÅ› porozmawiamy o pÄ™tlach - jednej z najwaÅ¼niejszych konstrukcji w programowaniu. PÄ™tle to sposÃ³b, w jaki mÃ³wimy komputerowi: "rÃ³b to samo, dopÃ³ki nie powiem stop" lub "zrÃ³b to dla kaÅ¼dego elementu z tej listy". Bez pÄ™tli programowanie byÅ‚oby jak prÃ³ba napisania ksiÄ…Å¼ki, przepisujÄ…c kaÅ¼de zdanie rÄ™cznie zamiast uÅ¼yÄ‡ kopiuj-wklej. Przygotuj siÄ™ na poznanie wszystkich sposobÃ³w na eleganckie powtarzanie!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

PÄ™tla to konstrukcja, ktÃ³ra pozwala wykonywaÄ‡ ten sam kod wielokrotnie. To jak instrukcja "powtarzaj, aÅ¼..." w przepisie kulinarnym. Zamiast pisaÄ‡ ten sam kod 100 razy, piszesz go raz i mÃ³wisz komputerowi, Å¼eby powtÃ³rzyÅ‚ go 100 razy.

```java
// Bez pÄ™tli - okropne!
System.out.println("Hello 1");
System.out.println("Hello 2");
System.out.println("Hello 3");
// ... i tak dalej 100 razy

// Z pÄ™tlÄ… - elegancko!
for (int i = 1; i <= 100; i++) {
    System.out.println("Hello " + i);
}
```

#### Dlaczego to waÅ¼ne?

PÄ™tle to podstawa automatyzacji w programowaniu. PozwalajÄ… przetwarzaÄ‡ duÅ¼e iloÅ›ci danych, wykonywaÄ‡ powtarzalne zadania i tworzyÄ‡ interaktywne programy. Bez pÄ™tli kaÅ¼dy program byÅ‚by ograniczony do wykonywania z gÃ³ry okreÅ›lonej liczby operacji.

#### Jak to dziaÅ‚a w praktyce?

**PÄ™tla for - klasyczna:**

```java
public class PetlaFor {
    public static void main(String[] args) {
        // Podstawowa pÄ™tla for
        for (int i = 0; i < 5; i++) {
            System.out.println("Iteracja: " + i);
        }
        // Wypisze: 0, 1, 2, 3, 4
        
        // PÄ™tla od tyÅ‚u
        for (int i = 10; i >= 1; i--) {
            System.out.println("Odliczanie: " + i);
        }
        
        // PÄ™tla z krokiem 2
        for (int i = 0; i < 10; i += 2) {
            System.out.println("Parzyste: " + i);
        }
        // Wypisze: 0, 2, 4, 6, 8
        
        // PÄ™tla z wieloma zmiennymi
        for (int i = 0, j = 10; i < j; i++, j--) {
            System.out.println("i=" + i + ", j=" + j);
        }
    }
}
```

**PÄ™tla for-each (enhanced for):**

```java
public class PetlaForEach {
    public static void main(String[] args) {
        // Z tablicÄ…
        int[] liczby = {1, 2, 3, 4, 5};
        for (int liczba : liczby) {
            System.out.println("Liczba: " + liczba);
        }
        
        // Z listÄ…
        List<String> imiona = Arrays.asList("Anna", "Kasia", "Ola");
        for (String imie : imiona) {
            System.out.println("CzeÅ›Ä‡ " + imie + "!");
        }
        
        // Z String (kaÅ¼dy znak)
        String tekst = "Java";
        for (char znak : tekst.toCharArray()) {
            System.out.println("Znak: " + znak);
        }
    }
}
```

**PÄ™tla while:**

```java
public class PetlaWhile {
    public static void main(String[] args) {
        // Podstawowa pÄ™tla while
        int licznik = 0;
        while (licznik < 5) {
            System.out.println("Licznik: " + licznik);
            licznik++;
        }
        
        // PÄ™tla z warunkiem zÅ‚oÅ¼onym
        Scanner scanner = new Scanner(System.in);
        String input = "";
        while (!input.equals("quit")) {
            System.out.print("Wpisz coÅ› (lub 'quit' aby wyjÅ›Ä‡): ");
            input = scanner.nextLine();
            System.out.println("NapisaÅ‚aÅ›: " + input);
        }
        
        // PÄ™tla nieskoÅ„czona (z break)
        int x = 0;
        while (true) {
            x++;
            if (x > 10) {
                break;  // WyjÅ›cie z pÄ™tli
            }
            if (x % 2 == 0) {
                continue;  // PrzejdÅº do nastÄ™pnej iteracji
            }
            System.out.println("Nieparzyste: " + x);
        }
    }
}
```

**PÄ™tla do-while:**

```java
public class PetlaDoWhile {
    public static void main(String[] args) {
        // Do-while wykonuje siÄ™ przynajmniej raz
        int liczba = 10;
        do {
            System.out.println("Liczba: " + liczba);
            liczba--;
        } while (liczba > 5);
        
        // Praktyczny przykÅ‚ad - menu
        Scanner scanner = new Scanner(System.in);
        int wybor;
        do {
            System.out.println("1. Opcja A");
            System.out.println("2. Opcja B");
            System.out.println("0. WyjÅ›cie");
            System.out.print("Wybierz opcjÄ™: ");
            wybor = scanner.nextInt();
            
            switch (wybor) {
                case 1 -> System.out.println("WybraÅ‚aÅ› opcjÄ™ A");
                case 2 -> System.out.println("WybraÅ‚aÅ› opcjÄ™ B");
                case 0 -> System.out.println("Do widzenia!");
                default -> System.out.println("NieprawidÅ‚owy wybÃ³r");
            }
        } while (wybor != 0);
    }
}
```

#### Kontrola przepÅ‚ywu w pÄ™tlach

```java
public class KontrolaPrzeplywu {
    public static void main(String[] args) {
        // break - wyjÅ›cie z pÄ™tli
        for (int i = 0; i < 10; i++) {
            if (i == 5) {
                break;  // Przerywa pÄ™tlÄ™
            }
            System.out.println("i = " + i);
        }
        // Wypisze: 0, 1, 2, 3, 4
        
        // continue - przejÅ›cie do nastÄ™pnej iteracji
        for (int i = 0; i < 10; i++) {
            if (i % 2 == 0) {
                continue;  // Pomija resztÄ™ iteracji dla parzystych
            }
            System.out.println("Nieparzyste: " + i);
        }
        // Wypisze: 1, 3, 5, 7, 9
        
        // Etykiety dla zagnieÅ¼dÅ¼onych pÄ™tli
        outer: for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (i == 1 && j == 1) {
                    break outer;  // Przerywa zewnÄ™trznÄ… pÄ™tlÄ™
                }
                System.out.println("i=" + i + ", j=" + j);
            }
        }
    }
}
```

#### PuÅ‚apki, na ktÃ³re warto uwaÅ¼aÄ‡

**PuÅ‚apka 1: PÄ™tla nieskoÅ„czona**

```java
// Å¹LE - pÄ™tla nieskoÅ„czona!
int i = 0;
while (i < 10) {
    System.out.println(i);
    // ZapomniaÅ‚aÅ› zwiÄ™kszyÄ‡ i!
}

// DOBRZE
int i = 0;
while (i < 10) {
    System.out.println(i);
    i++;  // PamiÄ™taj o zmianie warunku!
}
```

**PuÅ‚apka 2: Off-by-one error**

```java
int[] tablica = {1, 2, 3, 4, 5};

// Å¹LE - IndexOutOfBoundsException!
for (int i = 0; i <= tablica.length; i++) {
    System.out.println(tablica[i]);
}

// DOBRZE
for (int i = 0; i < tablica.length; i++) {
    System.out.println(tablica[i]);
}

// JESZCZE LEPIEJ - for-each
for (int element : tablica) {
    System.out.println(element);
}
```

**PuÅ‚apka 3: Modyfikacja kolekcji podczas iteracji**

```java
List<String> lista = new ArrayList<>(Arrays.asList("a", "b", "c"));

// Å¹LE - ConcurrentModificationException!
for (String element : lista) {
    if (element.equals("b")) {
        lista.remove(element);  // Nie rÃ³b tego!
    }
}

// DOBRZE - uÅ¼yj Iterator
Iterator<String> iterator = lista.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    if (element.equals("b")) {
        iterator.remove();  // Bezpieczne usuwanie
    }
}
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **UÅ¼ywaj for-each** gdy nie potrzebujesz indeksu
- **Sprawdzaj warunki zakoÅ„czenia** - unikaj pÄ™tli nieskoÅ„czonych
- **PamiÄ™taj o break i continue** - mogÄ… uproÅ›ciÄ‡ logikÄ™
- **UwaÅ¼aj na modyfikacjÄ™ kolekcji** podczas iteracji
- **UÅ¼ywaj opisowych nazw zmiennych** zamiast `i`, `j`, `k`

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** Napisz program, ktÃ³ry oblicza silniÄ™ liczby uÅ¼ywajÄ…c pÄ™tli.

```java
public static long silnia(int n) {
    // Twoja implementacja
}
```

**Zadanie 2:** StwÃ³rz metodÄ™, ktÃ³ra znajdzie najwiÄ™kszy element w tablicy uÅ¼ywajÄ…c pÄ™tli for-each.

**Zadanie 3:** Napisz program, ktÃ³ry wypisuje tabliczkÄ™ mnoÅ¼enia dla liczby podanej przez uÅ¼ytkownika.

#### â“ Pytania Kontrolne - Poziom Junior

1. Jaka jest rÃ³Å¼nica miÄ™dzy pÄ™tlÄ… `while` a `do-while`?
2. Kiedy lepiej uÅ¼yÄ‡ pÄ™tli `for`, a kiedy `for-each`?
3. Co robi instrukcja `continue` w pÄ™tli?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

PÄ™tle w Javie to nie tylko konstrukcje syntaktyczne - to fundamentalne elementy kontroli przepÅ‚ywu, ktÃ³re majÄ… gÅ‚Ä™bokie implikacje dla wydajnoÅ›ci, bezpieczeÅ„stwa i czytelnoÅ›ci kodu. JVM wykonuje zaawansowane optymalizacje pÄ™tli, ktÃ³re mogÄ… dramatycznie wpÅ‚ynÄ…Ä‡ na performance aplikacji.

##### Optymalizacje JVM dla pÄ™tli

```java
public class OptymalizacjePetli {
    // Loop unrolling - JVM moÅ¼e "rozwinÄ…Ä‡" maÅ‚e pÄ™tle
    public int simpleLoop() {
        int sum = 0;
        for (int i = 0; i < 4; i++) {
            sum += i;
        }
        // JVM moÅ¼e to zoptymalizowaÄ‡ do: sum = 0 + 1 + 2 + 3;
        return sum;
    }
    
    // Loop hoisting - wynoszenie niezmiennych obliczeÅ„ poza pÄ™tlÄ™
    public void loopHoisting(List<String> items) {
        // Å¹le - size() wywoÅ‚ywane w kaÅ¼dej iteracji
        for (int i = 0; i < items.size(); i++) {
            process(items.get(i));
        }
        
        // Lepiej - JVM moÅ¼e to zoptymalizowaÄ‡ automatycznie
        int size = items.size();
        for (int i = 0; i < size; i++) {
            process(items.get(i));
        }
    }
    
    // Vectorization - SIMD instructions dla prostych pÄ™tli
    public void vectorizableLoop(int[] array) {
        // Ta pÄ™tla moÅ¼e byÄ‡ zwektoryzowana przez JVM
        for (int i = 0; i < array.length; i++) {
            array[i] = array[i] * 2;
        }
    }
    
    // Loop peeling - optymalizacja pierwszej/ostatniej iteracji
    public int loopPeeling(int[] array) {
        int sum = 0;
        for (int i = 0; i < array.length; i++) {
            if (i == 0) {
                // Specjalna logika dla pierwszego elementu
                sum += array[i] * 10;
            } else {
                sum += array[i];
            }
        }
        // JVM moÅ¼e "oderwaÄ‡" pierwszÄ… iteracjÄ™ od reszty
        return sum;
    }
    
    private void process(String item) { /* implementation */ }
}
```

##### Zaawansowane wzorce iteracji

```java
public class ZaawansowaneWzorce {
    // Iterator pattern z custom implementation
    public static class Range implements Iterable<Integer> {
        private final int start;
        private final int end;
        private final int step;
        
        public Range(int start, int end, int step) {
            this.start = start;
            this.end = end;
            this.step = step;
        }
        
        @Override
        public Iterator<Integer> iterator() {
            return new Iterator<Integer>() {
                private int current = start;
                
                @Override
                public boolean hasNext() {
                    return step > 0 ? current < end : current > end;
                }
                
                @Override
                public Integer next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    int result = current;
                    current += step;
                    return result;
                }
            };
        }
    }
    
    // UÅ¼ycie custom iterator
    public void demonstrateCustomIterator() {
        // Elegancka iteracja z krokiem
        for (int i : new Range(0, 100, 5)) {
            System.out.println(i);  // 0, 5, 10, 15, ...
        }
        
        // Iteracja wsteczna
        for (int i : new Range(10, 0, -1)) {
            System.out.println(i);  // 10, 9, 8, 7, ...
        }
    }
    
    // Parallel iteration patterns
    public void parallelIteration() {
        List<Integer> numbers = IntStream.range(0, 1_000_000)
            .boxed()
            .collect(Collectors.toList());
        
        // Sequential processing
        long sequentialSum = numbers.stream()
            .mapToLong(Integer::longValue)
            .sum();
        
        // Parallel processing
        long parallelSum = numbers.parallelStream()
            .mapToLong(Integer::longValue)
            .sum();
        
        // Custom parallel processing z ForkJoinPool
        ForkJoinPool customThreadPool = new ForkJoinPool(4);
        try {
            long customParallelSum = customThreadPool.submit(() ->
                numbers.parallelStream()
                    .mapToLong(Integer::longValue)
                    .sum()
            ).get();
        } catch (InterruptedException | ExecutionException e) {
            Thread.currentThread().interrupt();
        } finally {
            customThreadPool.shutdown();
        }
    }
}
```

##### Memory access patterns i cache efficiency

```java
public class CacheEfficiency {
    // Cache-friendly iteration (row-major order)
    public void cacheEfficientIteration(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Dobrze - iteracja po wierszach (cache-friendly)
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                matrix[i][j] = i * j;
            }
        }
    }
    
    // Cache-unfriendly iteration (column-major order)
    public void cacheUnfriendlyIteration(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Å¹le - iteracja po kolumnach (cache-unfriendly)
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                matrix[i][j] = i * j;
            }
        }
    }
    
    // Loop blocking dla duÅ¼ych struktur danych
    public void blockedMatrixMultiplication(double[][] A, double[][] B, double[][] C) {
        int n = A.length;
        int blockSize = 64;  // Dopasowane do cache line
        
        for (int ii = 0; ii < n; ii += blockSize) {
            for (int jj = 0; jj < n; jj += blockSize) {
                for (int kk = 0; kk < n; kk += blockSize) {
                    // Blok operacji na mniejszych fragmentach
                    for (int i = ii; i < Math.min(ii + blockSize, n); i++) {
                        for (int j = jj; j < Math.min(jj + blockSize, n); j++) {
                            for (int k = kk; k < Math.min(kk + blockSize, n); k++) {
                                C[i][j] += A[i][k] * B[k][j];
                            }
                        }
                    }
                }
            }
        }
    }
}
```

#### PuÅ‚apki i niuanse

##### Concurrent modification i thread safety

```java
public class ConcurrentModification {
    private final List<String> sharedList = new ArrayList<>();
    
    // Race condition w pÄ™tlach
    public void unsafeIteration() {
        // Thread 1 - iteracja
        for (String item : sharedList) {
            processItem(item);
        }
        
        // Thread 2 - modyfikacja (moÅ¼e spowodowaÄ‡ ConcurrentModificationException)
        sharedList.add("new item");
    }
    
    // Bezpieczne podejÅ›cia
    public void safeIteration1() {
        // Kopia defensywna
        List<String> copy = new ArrayList<>(sharedList);
        for (String item : copy) {
            processItem(item);
        }
    }
    
    public void safeIteration2() {
        // Synchronizacja
        synchronized (sharedList) {
            for (String item : sharedList) {
                processItem(item);
            }
        }
    }
    
    public void safeIteration3() {
        // CopyOnWriteArrayList dla read-heavy scenarios
        CopyOnWriteArrayList<String> concurrentList = new CopyOnWriteArrayList<>(sharedList);
        for (String item : concurrentList) {
            processItem(item);  // Bezpieczne nawet przy concurrent modifications
        }
    }
    
    private void processItem(String item) { /* implementation */ }
}
```

##### Performance anti-patterns

```java
public class PerformanceAntiPatterns {
    // Anti-pattern: String concatenation w pÄ™tli
    public String badStringConcatenation(List<String> items) {
        String result = "";
        for (String item : items) {
            result += item;  // Tworzy nowy String w kaÅ¼dej iteracji!
        }
        return result;
    }
    
    // Lepiej: StringBuilder
    public String goodStringConcatenation(List<String> items) {
        StringBuilder sb = new StringBuilder();
        for (String item : items) {
            sb.append(item);
        }
        return sb.toString();
    }
    
    // Jeszcze lepiej: String.join lub Streams
    public String bestStringConcatenation(List<String> items) {
        return String.join("", items);
        // lub: items.stream().collect(Collectors.joining());
    }
    
    // Anti-pattern: Autoboxing w pÄ™tlach
    public void badAutoboxing() {
        List<Integer> numbers = new ArrayList<>();
        Integer sum = 0;  // Wrapper type!
        for (Integer num : numbers) {
            sum += num;  // Unboxing + boxing w kaÅ¼dej iteracji
        }
    }
    
    // Lepiej: Primitive types
    public void goodPrimitives() {
        List<Integer> numbers = new ArrayList<>();
        int sum = 0;  // Primitive type
        for (Integer num : numbers) {
            sum += num;  // Tylko unboxing
        }
    }
    
    // Anti-pattern: Nested loops z O(nÂ²) complexity
    public boolean badContainsCheck(List<String> list1, List<String> list2) {
        for (String item1 : list1) {
            for (String item2 : list2) {  // O(nÂ²)
                if (item1.equals(item2)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    // Lepiej: Set dla O(1) lookup
    public boolean goodContainsCheck(List<String> list1, List<String> list2) {
        Set<String> set2 = new HashSet<>(list2);  // O(n)
        for (String item1 : list1) {  // O(n)
            if (set2.contains(item1)) {  // O(1)
                return true;
            }
        }
        return false;
    }
}
```

##### Advanced loop constructs

```java
public class AdvancedLoopConstructs {
    // Functional-style loops z Streams
    public void functionalLoops() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Tradycyjna pÄ™tla
        List<Integer> doubled = new ArrayList<>();
        for (Integer num : numbers) {
            if (num % 2 == 0) {
                doubled.add(num * 2);
            }
        }
        
        // Functional approach
        List<Integer> functionalDoubled = numbers.stream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * 2)
            .collect(Collectors.toList());
        
        // Parallel processing
        List<Integer> parallelDoubled = numbers.parallelStream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * 2)
            .collect(Collectors.toList());
    }
    
    // Custom loop constructs
    public static void times(int count, Runnable action) {
        for (int i = 0; i < count; i++) {
            action.run();
        }
    }
    
    public static <T> void forEach(Iterable<T> items, Consumer<T> action) {
        for (T item : items) {
            action.accept(item);
        }
    }
    
    public static <T> void forEachWithIndex(List<T> items, BiConsumer<Integer, T> action) {
        for (int i = 0; i < items.size(); i++) {
            action.accept(i, items.get(i));
        }
    }
    
    // UÅ¼ycie custom constructs
    public void demonstrateCustomLoops() {
        // Repeat action
        times(5, () -> System.out.println("Hello"));
        
        // Enhanced forEach
        List<String> names = Arrays.asList("Anna", "Kasia", "Ola");
        forEach(names, name -> System.out.println("Hello " + name));
        
        // forEach with index
        forEachWithIndex(names, (index, name) -> 
            System.out.println(index + ": " + name));
    }
}
```

#### Wzorce i best practices

##### Loop invariant pattern

```java
public class LoopInvariant {
    // Binary search z loop invariant
    public int binarySearch(int[] sortedArray, int target) {
        int left = 0;
        int right = sortedArray.length - 1;
        
        // Loop invariant: jeÅ›li target istnieje, to jest w przedziale [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;  // Unikamy overflow
            
            if (sortedArray[mid] == target) {
                return mid;
            } else if (sortedArray[mid] < target) {
                left = mid + 1;  // Zachowujemy invariant
            } else {
                right = mid - 1;  // Zachowujemy invariant
            }
        }
        
        return -1;  // Nie znaleziono
    }
    
    // Partition algorithm z loop invariant
    public int partition(int[] array, int low, int high) {
        int pivot = array[high];
        int i = low - 1;
        
        // Loop invariant: 
        // - array[low..i] zawiera elementy <= pivot
        // - array[i+1..j-1] zawiera elementy > pivot
        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }
        
        swap(array, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```

##### Producer-Consumer pattern z pÄ™tlami

```java
public class ProducerConsumer {
    private final BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);
    private volatile boolean running = true;
    
    // Producer loop
    public void producer() {
        int counter = 0;
        while (running) {
            try {
                String item = "Item " + counter++;
                queue.put(item);  // Blocking put
                Thread.sleep(100);  // Simulate work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    // Consumer loop
    public void consumer() {
        while (running || !queue.isEmpty()) {
            try {
                String item = queue.poll(1, TimeUnit.SECONDS);  // Timeout poll
                if (item != null) {
                    processItem(item);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    // Batch processing loop
    public void batchConsumer() {
        List<String> batch = new ArrayList<>();
        while (running || !queue.isEmpty()) {
            try {
                // Zbierz batch
                queue.drainTo(batch, 10);  // Max 10 items
                
                if (!batch.isEmpty()) {
                    processBatch(batch);
                    batch.clear();
                }
                
                if (batch.isEmpty()) {
                    Thread.sleep(100);  // Wait if no items
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private void processItem(String item) { /* implementation */ }
    private void processBatch(List<String> batch) { /* implementation */ }
    
    public void stop() {
        running = false;
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj cache-efficient matrix transpose algorithm, ktÃ³ry minimalizuje cache misses przez odpowiednie wzorce dostÄ™pu do pamiÄ™ci.

**Zadanie Zaawansowane 2:** StwÃ³rz thread-safe iterator pool, ktÃ³ry pozwala na bezpiecznÄ… iteracjÄ™ po kolekcji w Å›rodowisku wielowÄ…tkowym z moÅ¼liwoÅ›ciÄ… concurrent modifications.

**Zadanie Zaawansowane 3:** Zaprojektuj adaptive loop unrolling system, ktÃ³ry dynamicznie dostosowuje stopieÅ„ rozwiniÄ™cia pÄ™tli na podstawie charakterystyki danych wejÅ›ciowych.

#### â“ Pytania Kontrolne - Poziom Senior

1. Jakie optymalizacje JVM moÅ¼e zastosowaÄ‡ do pÄ™tli i jak moÅ¼na je wspomÃ³c w kodzie?
2. Dlaczego cache locality jest waÅ¼na w pÄ™tlach i jak projektowaÄ‡ cache-friendly algorithms?
3. Jakie sÄ… trade-offs miÄ™dzy sequential a parallel processing w pÄ™tlach?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static long silnia(int n) {
    if (n < 0) {
        throw new IllegalArgumentException("Silnia nie jest zdefiniowana dla liczb ujemnych");
    }
    
    long wynik = 1;
    for (int i = 1; i <= n; i++) {
        wynik *= i;
    }
    return wynik;
}

// Test:
System.out.println(silnia(5)); // 120
System.out.println(silnia(0)); // 1
```

**Zadanie 2:**
```java
public static int znajdzNajwiekszy(int[] tablica) {
    if (tablica.length == 0) {
        throw new IllegalArgumentException("Tablica nie moÅ¼e byÄ‡ pusta");
    }
    
    int najwiekszy = tablica[0];
    for (int element : tablica) {
        if (element > najwiekszy) {
            najwiekszy = element;
        }
    }
    return najwiekszy;
}

// Test:
int[] liczby = {3, 7, 2, 9, 1, 5};
System.out.println(znajdzNajwiekszy(liczby)); // 9
```

**Zadanie 3:**
```java
public static void tabliczkaMnozenia(int liczba) {
    System.out.println("Tabliczka mnoÅ¼enia dla " + liczba + ":");
    for (int i = 1; i <= 10; i++) {
        int wynik = liczba * i;
        System.out.println(liczba + " x " + i + " = " + wynik);
    }
}

// Test:
tabliczkaMnozenia(7);
// Wypisze: 7 x 1 = 7, 7 x 2 = 14, ..., 7 x 10 = 70
```

**Pytania kontrolne:**
1. `while` sprawdza warunek przed wykonaniem, `do-while` wykonuje kod przynajmniej raz, potem sprawdza warunek.
2. `for` gdy potrzebujesz indeksu lub okreÅ›lonej liczby iteracji, `for-each` gdy iterujesz po wszystkich elementach kolekcji.
3. `continue` pomija resztÄ™ bieÅ¼Ä…cej iteracji i przechodzi do nastÄ™pnej iteracji pÄ™tli.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class CacheEfficientTranspose {
    // Naive transpose - cache unfriendly
    public static void naiveTranspose(double[][] matrix, double[][] result) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[j][i] = matrix[i][j];  // Poor cache locality
            }
        }
    }
    
    // Cache-efficient blocked transpose
    public static void blockedTranspose(double[][] matrix, double[][] result) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int blockSize = 64;  // Tuned for cache line size
        
        for (int ii = 0; ii < rows; ii += blockSize) {
            for (int jj = 0; jj < cols; jj += blockSize) {
                // Transpose block
                int maxI = Math.min(ii + blockSize, rows);
                int maxJ = Math.min(jj + blockSize, cols);
                
                for (int i = ii; i < maxI; i++) {
                    for (int j = jj; j < maxJ; j++) {
                        result[j][i] = matrix[i][j];
                    }
                }
            }
        }
    }
    
    // In-place transpose for square matrices
    public static void inPlaceTranspose(double[][] matrix) {
        int n = matrix.length;
        int blockSize = 32;
        
        for (int ii = 0; ii < n; ii += blockSize) {
            for (int jj = ii; jj < n; jj += blockSize) {
                int maxI = Math.min(ii + blockSize, n);
                int maxJ = Math.min(jj + blockSize, n);
                
                for (int i = ii; i < maxI; i++) {
                    int startJ = (ii == jj) ? i + 1 : jj;  // Avoid double swap
                    for (int j = startJ; j < maxJ; j++) {
                        // Swap elements
                        double temp = matrix[i][j];
                        matrix[i][j] = matrix[j][i];
                        matrix[j][i] = temp;
                    }
                }
            }
        }
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class ThreadSafeIteratorPool {
    private final ConcurrentLinkedQueue<SafeIterator<?>> pool = new ConcurrentLinkedQueue<>();
    private final int maxPoolSize;
    
    public ThreadSafeIteratorPool(int maxPoolSize) {
        this.maxPoolSize = maxPoolSize;
    }
    
    public <T> SafeIterator<T> borrowIterator(Collection<T> collection) {
        SafeIterator<T> iterator = (SafeIterator<T>) pool.poll();
        if (iterator == null) {
            iterator = new SafeIterator<>();
        }
        iterator.reset(collection);
        return iterator;
    }
    
    public void returnIterator(SafeIterator<?> iterator) {
        if (pool.size() < maxPoolSize) {
            iterator.clear();
            pool.offer(iterator);
        }
    }
    
    public static class SafeIterator<T> implements Iterator<T> {
        private volatile List<T> snapshot;
        private volatile int position;
        private final AtomicInteger version = new AtomicInteger();
        
        public void reset(Collection<T> collection) {
            this.snapshot = new ArrayList<>(collection);
            this.position = 0;
            this.version.incrementAndGet();
        }
        
        @Override
        public boolean hasNext() {
            return position < snapshot.size();
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return snapshot.get(position++);
        }
        
        public void clear() {
            this.snapshot = null;
            this.position = 0;
        }
        
        // Thread-safe forEach
        public void forEach(Consumer<T> action) {
            List<T> currentSnapshot = this.snapshot;
            if (currentSnapshot != null) {
                for (T item : currentSnapshot) {
                    action.accept(item);
                }
            }
        }
    }
    
    // Usage example
    public void demonstrateUsage() {
        ThreadSafeIteratorPool pool = new ThreadSafeIteratorPool(10);
        List<String> sharedList = new CopyOnWriteArrayList<>();
        
        // Thread 1 - iteration
        SafeIterator<String> iterator = pool.borrowIterator(sharedList);
        try {
            iterator.forEach(System.out::println);
        } finally {
            pool.returnIterator(iterator);
        }
        
        // Thread 2 - modification (safe)
        sharedList.add("new item");
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class AdaptiveLoopUnroller {
    private static final int MIN_UNROLL_FACTOR = 2;
    private static final int MAX_UNROLL_FACTOR = 8;
    private static final int SAMPLE_SIZE = 1000;
    
    public static class UnrollStrategy {
        private final int unrollFactor;
        private final long avgExecutionTime;
        
        public UnrollStrategy(int unrollFactor, long avgExecutionTime) {
            this.unrollFactor = unrollFactor;
            this.avgExecutionTime = avgExecutionTime;
        }
        
        public int getUnrollFactor() { return unrollFactor; }
        public long getAvgExecutionTime() { return avgExecutionTime; }
    }
    
    public static UnrollStrategy findOptimalUnrollFactor(int[] data, IntUnaryOperator operation) {
        UnrollStrategy bestStrategy = null;
        long bestTime = Long.MAX_VALUE;
        
        for (int factor = MIN_UNROLL_FACTOR; factor <= MAX_UNROLL_FACTOR; factor *= 2) {
            long totalTime = 0;
            
            // Benchmark multiple runs
            for (int run = 0; run < 5; run++) {
                long startTime = System.nanoTime();
                executeUnrolledLoop(data, operation, factor);
                long endTime = System.nanoTime();
                totalTime += (endTime - startTime);
            }
            
            long avgTime = totalTime / 5;
            if (avgTime < bestTime) {
                bestTime = avgTime;
                bestStrategy = new UnrollStrategy(factor, avgTime);
            }
        }
        
        return bestStrategy;
    }
    
    private static void executeUnrolledLoop(int[] data, IntUnaryOperator operation, int unrollFactor) {
        int length = data.length;
        int unrolledLength = (length / unrollFactor) * unrollFactor;
        
        // Unrolled loop
        for (int i = 0; i < unrolledLength; i += unrollFactor) {
            switch (unrollFactor) {
                case 8:
                    data[i + 7] = operation.applyAsInt(data[i + 7]);
                case 7:
                    data[i + 6] = operation.applyAsInt(data[i + 6]);
                case 6:
                    data[i + 5] = operation.applyAsInt(data[i + 5]);
                case 5:
                    data[i + 4] = operation.applyAsInt(data[i + 4]);
                case 4:
                    data[i + 3] = operation.applyAsInt(data[i + 3]);
                case 3:
                    data[i + 2] = operation.applyAsInt(data[i + 2]);
                case 2:
                    data[i + 1] = operation.applyAsInt(data[i + 1]);
                case 1:
                    data[i] = operation.applyAsInt(data[i]);
            }
        }
        
        // Handle remaining elements
        for (int i = unrolledLength; i < length; i++) {
            data[i] = operation.applyAsInt(data[i]);
        }
    }
    
    // Adaptive processor that learns optimal unroll factor
    public static class AdaptiveProcessor {
        private final Map<String, UnrollStrategy> strategyCache = new ConcurrentHashMap<>();
        
        public void processArray(int[] data, IntUnaryOperator operation, String operationId) {
            UnrollStrategy strategy = strategyCache.computeIfAbsent(operationId, 
                id -> findOptimalUnrollFactor(Arrays.copyOf(data, Math.min(data.length, SAMPLE_SIZE)), operation));
            
            executeUnrolledLoop(data, operation, strategy.getUnrollFactor());
        }
    }
}
```

**Pytania kontrolne:**
1. JVM moÅ¼e zastosowaÄ‡ loop unrolling, hoisting, vectorization, peeling. MoÅ¼na pomÃ³c przez unikanie side effects, uÅ¼ywanie final variables, i pisanie prostych loop bodies.
2. Cache locality redukuje cache misses. Projektuj algorithms iterujÄ…c po danych w kolejnoÅ›ci ich ukÅ‚adu w pamiÄ™ci (row-major dla arrays), uÅ¼ywaj loop blocking dla duÅ¼ych struktur.
3. Sequential: prostsze, deterministyczne, mniejszy overhead. Parallel: szybsze dla CPU-intensive tasks, ale wymaga thread-safe operations i moÅ¼e mieÄ‡ overhead synchronizacji.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Teraz masz peÅ‚ne zrozumienie pÄ™tli w Javie - od podstawowych for i while po zaawansowane optymalizacje i wzorce. PÄ™tle to narzÄ™dzie, ktÃ³re bÄ™dziesz uÅ¼ywaÄ‡ codziennie, wiÄ™c warto je znaÄ‡ na wylot. W nastÄ™pnym rozdziale porozmawiamy o String - czyli o tym, co moÅ¼na robiÄ‡ z tekstem (a to naprawdÄ™ duÅ¼o!) plus poznamy nowoczesne API, ktÃ³re Java ma do zaoferowania!*

---

*ğŸ’¡ PamiÄ™taj: Dobra pÄ™tla to taka, ktÃ³ra robi dokÅ‚adnie to, co powinna, ani wiÄ™cej, ani mniej. MyÅ›l o wydajnoÅ›ci, ale nie kosztem czytelnoÅ›ci!*


## 7. String: co moÅ¼na robiÄ‡ z tekstem (duÅ¼o!) + nowoczesne API

*CzeÅ›Ä‡! DziÅ› porozmawiamy o String - jednej z najwaÅ¼niejszych klas w Javie. MoÅ¼e siÄ™ wydawaÄ‡, Å¼e tekst to tekst, ale String w Javie to prawdziwy szwajcarski scyzoryk do pracy z tekstem. Od podstawowych operacji po nowoczesne API wprowadzone w najnowszych wersjach Javy - przygotuj siÄ™ na odkrycie wszystkich moÅ¼liwoÅ›ci, jakie daje Ci praca z tekstem!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

String w Javie to obiekt reprezentujÄ…cy sekwencjÄ™ znakÃ³w. Ale uwaga - String jest **immutable** (niezmienialny), co oznacza, Å¼e raz utworzony String nigdy siÄ™ nie zmienia. KaÅ¼da "modyfikacja" tworzy nowy obiekt String.

```java
String imie = "Anna";
String powitanie = "CzeÅ›Ä‡ " + imie + "!";  // Tworzy nowy String
System.out.println(powitanie);  // "CzeÅ›Ä‡ Anna!"

// imie nadal zawiera "Anna" - nie zmieniÅ‚ siÄ™!
```

#### Dlaczego to waÅ¼ne?

String to podstawa komunikacji w kaÅ¼dej aplikacji. Czy to nazwy uÅ¼ytkownikÃ³w, komunikaty bÅ‚Ä™dÃ³w, czy dane z plikÃ³w - wszystko to tekst. UmiejÄ™tnoÅ›Ä‡ efektywnej pracy ze String pozwala tworzyÄ‡ czytelne, wydajne i bezpieczne aplikacje.

#### Jak to dziaÅ‚a w praktyce?

**Podstawowe operacje na String:**

```java
public class PodstawoweOperacje {
    public static void main(String[] args) {
        String tekst = "Java Programming";
        
        // DÅ‚ugoÅ›Ä‡
        System.out.println("DÅ‚ugoÅ›Ä‡: " + tekst.length());  // 16
        
        // Pobieranie znakÃ³w
        System.out.println("Pierwszy znak: " + tekst.charAt(0));  // 'J'
        System.out.println("Ostatni znak: " + tekst.charAt(tekst.length() - 1));  // 'g'
        
        // PodciÄ…gi
        System.out.println("PodciÄ…g: " + tekst.substring(5));     // "Programming"
        System.out.println("PodciÄ…g: " + tekst.substring(0, 4));  // "Java"
        
        // Wyszukiwanie
        System.out.println("Indeks 'P': " + tekst.indexOf('P'));        // 5
        System.out.println("Indeks 'gram': " + tekst.indexOf("gram"));   // 8
        System.out.println("Ostatni 'a': " + tekst.lastIndexOf('a'));   // 3
        
        // Sprawdzanie zawartoÅ›ci
        System.out.println("Zawiera 'Java': " + tekst.contains("Java"));     // true
        System.out.println("Zaczyna siÄ™ od 'Java': " + tekst.startsWith("Java")); // true
        System.out.println("KoÅ„czy siÄ™ na 'ing': " + tekst.endsWith("ing"));     // true
    }
}
```

**PorÃ³wnywanie String:**

```java
public class PorownywanieString {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "Hello";
        String s3 = new String("Hello");
        String s4 = "hello";
        
        // PorÃ³wnywanie referencji vs zawartoÅ›ci
        System.out.println("s1 == s2: " + (s1 == s2));         // true (string pool)
        System.out.println("s1 == s3: " + (s1 == s3));         // false (rÃ³Å¼ne obiekty)
        System.out.println("s1.equals(s3): " + s1.equals(s3)); // true (ta sama zawartoÅ›Ä‡)
        
        // PorÃ³wnywanie z ignorowaniem wielkoÅ›ci liter
        System.out.println("s1.equalsIgnoreCase(s4): " + s1.equalsIgnoreCase(s4)); // true
        
        // PorÃ³wnywanie leksykograficzne
        System.out.println("s1.compareTo(s4): " + s1.compareTo(s4));  // ujemna (H < h w ASCII)
        System.out.println("s1.compareToIgnoreCase(s4): " + s1.compareToIgnoreCase(s4)); // 0
        
        // Bezpieczne porÃ³wnywanie z null
        String nullString = null;
        System.out.println("Objects.equals: " + Objects.equals(s1, nullString)); // false
    }
}
```

**Modyfikowanie String (tworzenie nowych):**

```java
public class ModyfikowanieString {
    public static void main(String[] args) {
        String tekst = "  Java Programming  ";
        
        // Zmiana wielkoÅ›ci liter
        System.out.println("Wielkie: " + tekst.toUpperCase());    // "  JAVA PROGRAMMING  "
        System.out.println("MaÅ‚e: " + tekst.toLowerCase());       // "  java programming  "
        
        // Usuwanie biaÅ‚ych znakÃ³w
        System.out.println("Trim: '" + tekst.trim() + "'");       // "Java Programming"
        
        // ZastÄ™powanie
        System.out.println("Replace: " + tekst.replace("Java", "Python"));  // "  Python Programming  "
        System.out.println("ReplaceAll: " + tekst.replaceAll("\\s+", "-")); // "--Java-Programming--"
        
        // Dzielenie
        String csv = "Anna,Kasia,Ola,Magda";
        String[] imiona = csv.split(",");
        for (String imie : imiona) {
            System.out.println("ImiÄ™: " + imie);
        }
        
        // ÅÄ…czenie
        String polaczone = String.join(" | ", imiona);
        System.out.println("PoÅ‚Ä…czone: " + polaczone);  // "Anna | Kasia | Ola | Magda"
    }
}
```

**Nowoczesne API String (Java 11+):**

```java
public class NowoczesneStringAPI {
    public static void main(String[] args) {
        // isBlank() - sprawdza czy String jest pusty lub zawiera tylko biaÅ‚e znaki
        String pusty = "";
        String biale = "   ";
        String tekst = "Java";
        
        System.out.println("pusty.isEmpty(): " + pusty.isEmpty());     // true
        System.out.println("pusty.isBlank(): " + pusty.isBlank());     // true
        System.out.println("biale.isEmpty(): " + biale.isEmpty());     // false
        System.out.println("biale.isBlank(): " + biale.isBlank());     // true
        
        // strip() - lepszy trim (obsÅ‚uguje Unicode whitespace)
        String unicode = "\u2000Java\u2000";  // Unicode spaces
        System.out.println("trim: '" + unicode.trim() + "'");     // MoÅ¼e nie usunÄ…Ä‡ wszystkich
        System.out.println("strip: '" + unicode.strip() + "'");   // Usuwa wszystkie Unicode spaces
        System.out.println("stripLeading: '" + unicode.stripLeading() + "'");
        System.out.println("stripTrailing: '" + unicode.stripTrailing() + "'");
        
        // repeat() - powtarzanie String
        String gwiazdki = "*".repeat(10);
        System.out.println(gwiazdki);  // "**********"
        
        String linia = "-".repeat(20);
        System.out.println(linia);     // "--------------------"
        
        // lines() - dzielenie na linie
        String wielolinijkowy = "Pierwsza linia\nDruga linia\nTrzecia linia";
        wielolinijkowy.lines()
            .forEach(System.out::println);
    }
}
```

#### Formatowanie String

```java
public class FormatowanieString {
    public static void main(String[] args) {
        String imie = "Anna";
        int wiek = 25;
        double wzrost = 165.5;
        
        // String.format() - jak printf w C
        String sformatowany = String.format("CzeÅ›Ä‡ %s! Masz %d lat i %,.1f cm wzrostu.", 
                                           imie, wiek, wzrost);
        System.out.println(sformatowany);
        
        // formatted() - metoda instancyjna (Java 15+)
        String szablon = "CzeÅ›Ä‡ %s! Masz %d lat.";
        String wynik = szablon.formatted(imie, wiek);
        System.out.println(wynik);
        
        // RÃ³Å¼ne formaty
        double liczba = 1234.5678;
        System.out.println(String.format("DomyÅ›lnie: %f", liczba));        // 1234.567800
        System.out.println(String.format("2 miejsca: %.2f", liczba));      // 1234.57
        System.out.println(String.format("Z separatorami: %,.2f", liczba)); // 1,234.57
        System.out.println(String.format("Padding: %10.2f", liczba));      // "   1234.57"
        System.out.println(String.format("Zero padding: %010.2f", liczba)); // "0001234.57"
        
        // Formatowanie dat
        LocalDateTime teraz = LocalDateTime.now();
        System.out.println(String.format("Data: %tF %tT", teraz, teraz));
    }
}
```

#### PuÅ‚apki, na ktÃ³re warto uwaÅ¼aÄ‡

**PuÅ‚apka 1: Konkatenacja w pÄ™tlach**

```java
// Å¹LE - bardzo wolne!
String wynik = "";
for (int i = 0; i < 1000; i++) {
    wynik += "element " + i + ", ";  // Tworzy nowy String w kaÅ¼dej iteracji!
}

// DOBRZE - uÅ¼yj StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append("element ").append(i).append(", ");
}
String wynik = sb.toString();
```

**PuÅ‚apka 2: PorÃ³wnywanie z ==**

```java
String s1 = new String("Hello");
String s2 = new String("Hello");
if (s1 == s2) {  // Å¹LE! PorÃ³wnuje referencje
    System.out.println("Nigdy siÄ™ nie wykona");
}

if (s1.equals(s2)) {  // DOBRZE!
    System.out.println("To siÄ™ wykona");
}
```

**PuÅ‚apka 3: NullPointerException**

```java
String tekst = null;
if (tekst.equals("Hello")) {  // Å¹LE - NPE!
    System.out.println("Nigdy siÄ™ nie wykona");
}

// DOBRZE - bezpieczne podejÅ›cia:
if ("Hello".equals(tekst)) {  // Bezpieczne
    System.out.println("To jest bezpieczne");
}

if (Objects.equals(tekst, "Hello")) {  // TeÅ¼ bezpieczne
    System.out.println("To teÅ¼ jest bezpieczne");
}
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **UÅ¼ywaj `equals()`** do porÃ³wnywania String, nie `==`
- **StringBuilder** dla wielu konkatenacji, zwykÅ‚y `+` dla pojedynczych
- **Sprawdzaj null** przed wywoÅ‚aniem metod na String
- **UÅ¼ywaj nowoczesnego API** - `isBlank()`, `strip()`, `repeat()`
- **String.format()** dla zÅ‚oÅ¼onego formatowania

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** Napisz metodÄ™, ktÃ³ra sprawdza, czy podany String jest palindromem (czyta siÄ™ tak samo od przodu i od tyÅ‚u).

```java
public static boolean czyPalindrom(String tekst) {
    // Twoja implementacja (ignoruj wielkoÅ›Ä‡ liter i spacje)
}
```

**Zadanie 2:** StwÃ³rz metodÄ™, ktÃ³ra zlicza wystÄ…pienia kaÅ¼dej litery w tekÅ›cie.

**Zadanie 3:** Napisz funkcjÄ™, ktÃ³ra "maskuje" numer karty kredytowej, pokazujÄ…c tylko ostatnie 4 cyfry.

#### â“ Pytania Kontrolne - Poziom Junior

1. Dlaczego String jest immutable i jakie to ma konsekwencje?
2. Jaka jest rÃ³Å¼nica miÄ™dzy `trim()` a `strip()`?
3. Kiedy uÅ¼ywaÄ‡ `StringBuilder` zamiast konkatenacji z `+`?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

String w Javie to znacznie wiÄ™cej niÅ¼ prosta reprezentacja tekstu. To jedna z najbardziej zoptymalizowanych klas w JDK, z wieloma ukrytymi mechanizmami optymalizacji, ktÃ³re wpÅ‚ywajÄ… na wydajnoÅ›Ä‡ i zuÅ¼ycie pamiÄ™ci aplikacji.

##### WewnÄ™trzna reprezentacja String

```java
public class StringInternals {
    // Od Java 9: String uÅ¼ywa byte[] zamiast char[]
    // Compact Strings optimization - Latin-1 vs UTF-16
    
    public void demonstrateStringCompaction() {
        String latin1 = "Hello";      // 1 byte per character
        String unicode = "CzeÅ›Ä‡";     // 2 bytes per character
        
        // JVM automatycznie wybiera reprezentacjÄ™
        // Latin-1 dla ASCII, UTF-16 dla Unicode
        
        // MoÅ¼na sprawdziÄ‡ uÅ¼ywajÄ…c reflection (nie rÃ³b tego w produkcji!)
        try {
            Field valueField = String.class.getDeclaredField("value");
            valueField.setAccessible(true);
            
            byte[] latin1Bytes = (byte[]) valueField.get(latin1);
            byte[] unicodeBytes = (byte[]) valueField.get(unicode);
            
            System.out.println("Latin1 bytes: " + latin1Bytes.length);  // 5
            System.out.println("Unicode bytes: " + unicodeBytes.length); // 10 (2 * 5)
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

##### String Pool i interning

```java
public class StringPoolAnalysis {
    public void demonstrateStringPool() {
        // String literals trafiajÄ… do String Pool
        String s1 = "Hello";
        String s2 = "Hello";
        System.out.println(s1 == s2);  // true - ten sam obiekt z pool
        
        // new String() tworzy nowy obiekt
        String s3 = new String("Hello");
        System.out.println(s1 == s3);  // false - rÃ³Å¼ne obiekty
        
        // intern() dodaje do pool lub zwraca istniejÄ…cy
        String s4 = s3.intern();
        System.out.println(s1 == s4);  // true - s4 to obiekt z pool
        
        // Concatenation nie trafia do pool automatycznie
        String s5 = "Hel" + "lo";      // Compile-time constant - trafia do pool
        String s6 = "Hel" + new String("lo");  // Runtime - nie trafia do pool
        System.out.println(s1 == s5);  // true
        System.out.println(s1 == s6);  // false
    }
    
    // Custom string interning dla oszczÄ™dnoÅ›ci pamiÄ™ci
    private final Map<String, String> customPool = new ConcurrentHashMap<>();
    
    public String customIntern(String str) {
        return customPool.computeIfAbsent(str, Function.identity());
    }
    
    // Weak reference pool - pozwala na GC
    private final Map<String, WeakReference<String>> weakPool = new ConcurrentHashMap<>();
    
    public String weakIntern(String str) {
        WeakReference<String> ref = weakPool.get(str);
        String interned = (ref != null) ? ref.get() : null;
        
        if (interned == null) {
            interned = str;
            weakPool.put(str, new WeakReference<>(str));
        }
        
        return interned;
    }
}
```

##### Performance considerations

```java
public class StringPerformance {
    // String concatenation performance
    @Benchmark
    public String concatenationWithPlus() {
        String result = "";
        for (int i = 0; i < 1000; i++) {
            result += "item" + i;  // O(nÂ²) complexity!
        }
        return result;
    }
    
    @Benchmark
    public String concatenationWithStringBuilder() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append("item").append(i);  // O(n) complexity
        }
        return sb.toString();
    }
    
    @Benchmark
    public String concatenationWithStringJoiner() {
        StringJoiner joiner = new StringJoiner("");
        for (int i = 0; i < 1000; i++) {
            joiner.add("item" + i);
        }
        return joiner.toString();
    }
    
    // String comparison performance
    @Benchmark
    public boolean equalsComparison(String s1, String s2) {
        return s1.equals(s2);  // Optimized for common cases
    }
    
    @Benchmark
    public boolean equalsIgnoreCaseComparison(String s1, String s2) {
        return s1.equalsIgnoreCase(s2);  // More expensive
    }
    
    // Substring performance (Java 7+ vs Java 6)
    public void demonstrateSubstringBehavior() {
        String large = "A".repeat(1_000_000);
        
        // Java 7+: substring tworzy nowy array
        String small = large.substring(0, 10);  // Nie trzyma referencji do large
        
        // W Java 6: substring dzieliÅ‚ array z oryginalnym String
        // MogÅ‚o powodowaÄ‡ memory leaks
    }
}
```

##### Advanced String operations

```java
public class AdvancedStringOperations {
    // Efficient string searching - Boyer-Moore algorithm simulation
    public int efficientIndexOf(String text, String pattern) {
        // Simplified Boyer-Moore-like approach
        if (pattern.isEmpty()) return 0;
        if (text.length() < pattern.length()) return -1;
        
        // Build bad character table
        Map<Character, Integer> badChar = new HashMap<>();
        for (int i = 0; i < pattern.length(); i++) {
            badChar.put(pattern.charAt(i), i);
        }
        
        int shift = 0;
        while (shift <= text.length() - pattern.length()) {
            int j = pattern.length() - 1;
            
            while (j >= 0 && pattern.charAt(j) == text.charAt(shift + j)) {
                j--;
            }
            
            if (j < 0) {
                return shift;  // Found match
            } else {
                char badCharacter = text.charAt(shift + j);
                int badCharShift = badChar.getOrDefault(badCharacter, -1);
                shift += Math.max(1, j - badCharShift);
            }
        }
        
        return -1;  // Not found
    }
    
    // String similarity algorithms
    public int levenshteinDistance(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= s2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]);
                }
            }
        }
        
        return dp[s1.length()][s2.length()];
    }
    
    // Fuzzy string matching
    public double jaccardSimilarity(String s1, String s2) {
        Set<String> set1 = new HashSet<>();
        Set<String> set2 = new HashSet<>();
        
        // Create n-grams (bigrams in this case)
        for (int i = 0; i < s1.length() - 1; i++) {
            set1.add(s1.substring(i, i + 2));
        }
        for (int i = 0; i < s2.length() - 1; i++) {
            set2.add(s2.substring(i, i + 2));
        }
        
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        
        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();
    }
}
```

#### PuÅ‚apki i niuanse

##### Memory leaks z String

```java
public class StringMemoryLeaks {
    // Potential memory leak z substring (pre-Java 7)
    public class TokenHolder {
        private final String token;
        
        // Problematyczne w starych wersjach Java
        public TokenHolder(String largeDocument, int start, int end) {
            this.token = largeDocument.substring(start, end);
            // W Java 6: token dzieliÅ‚ char[] z largeDocument
            // CaÅ‚y largeDocument nie mÃ³gÅ‚ byÄ‡ GC'd
        }
        
        // Bezpieczna wersja
        public TokenHolder(String largeDocument, int start, int end) {
            this.token = new String(largeDocument.substring(start, end));
            // Tworzy nowy String z wÅ‚asnym char[]
        }
    }
    
    // String interning memory leak
    private final Set<String> internedStrings = new HashSet<>();
    
    public void problematicInterning(String userInput) {
        // NIGDY nie rÃ³b tego z user input!
        String interned = userInput.intern();
        internedStrings.add(interned);
        // String pool nigdy nie jest czyszczony - memory leak!
    }
    
    // Bezpieczna alternatywa
    private final Map<String, String> safeInternPool = new WeakHashMap<>();
    
    public String safeIntern(String str) {
        return safeInternPool.computeIfAbsent(str, Function.identity());
    }
}
```

##### Security considerations

```java
public class StringSecurity {
    // Password handling - String vs char[]
    public void demonstratePasswordSecurity() {
        // Å¹LE - String jest immutable i moÅ¼e zostaÄ‡ w pamiÄ™ci
        String password = "secretPassword123";
        // password moÅ¼e byÄ‡ widoczny w heap dump
        
        // DOBRZE - char[] moÅ¼na wyczyÅ›ciÄ‡
        char[] passwordChars = "secretPassword123".toCharArray();
        try {
            // UÅ¼yj password
            authenticateUser(passwordChars);
        } finally {
            // WyczyÅ›Ä‡ pamiÄ™Ä‡
            Arrays.fill(passwordChars, '\0');
        }
    }
    
    // SQL Injection prevention
    public void safeDatabaseQuery(String userInput) {
        // Å¹LE - podatne na SQL injection
        String unsafeQuery = "SELECT * FROM users WHERE name = '" + userInput + "'";
        
        // DOBRZE - prepared statements
        String safeQuery = "SELECT * FROM users WHERE name = ?";
        // UÅ¼yj PreparedStatement z parametrami
    }
    
    // XSS prevention
    public String escapeHtml(String input) {
        if (input == null) return null;
        
        return input.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#x27;");
    }
    
    private void authenticateUser(char[] password) {
        // Implementation
    }
}
```

##### Internationalization i Unicode

```java
public class StringInternationalization {
    // Unicode normalization
    public void demonstrateUnicodeNormalization() {
        // Te String mogÄ… wyglÄ…daÄ‡ identycznie, ale byÄ‡ rÃ³Å¼ne
        String s1 = "cafÃ©";  // Ã© jako jeden znak
        String s2 = "cafe\u0301";  // e + combining acute accent
        
        System.out.println(s1.equals(s2));  // false!
        System.out.println(s1.length());    // 4
        System.out.println(s2.length());    // 5
        
        // Normalizacja Unicode
        String normalized1 = Normalizer.normalize(s1, Normalizer.Form.NFC);
        String normalized2 = Normalizer.normalize(s2, Normalizer.Form.NFC);
        System.out.println(normalized1.equals(normalized2));  // true
    }
    
    // Locale-sensitive operations
    public void demonstrateLocaleOperations() {
        String turkish = "Ä°stanbul";
        
        // Problematyczne - uÅ¼ywa domyÅ›lnego Locale
        String lower1 = turkish.toLowerCase();
        
        // Poprawne - explicit Locale
        String lower2 = turkish.toLowerCase(Locale.ENGLISH);
        String lower3 = turkish.toLowerCase(new Locale("tr", "TR"));
        
        System.out.println("Default: " + lower1);
        System.out.println("English: " + lower2);
        System.out.println("Turkish: " + lower3);
        // W tureckim 'Ä°' -> 'i', w angielskim 'Ä°' -> 'iÌ‡'
    }
    
    // Collation for sorting
    public void demonstrateCollation() {
        List<String> names = Arrays.asList("MÃ¼ller", "Mueller", "MÃ¸ller");
        
        // Default sorting
        names.sort(String::compareTo);
        System.out.println("Default: " + names);
        
        // Locale-specific collation
        Collator germanCollator = Collator.getInstance(Locale.GERMAN);
        names.sort(germanCollator::compare);
        System.out.println("German: " + names);
        
        // Custom collation rules
        Collator customCollator = Collator.getInstance();
        customCollator.setStrength(Collator.PRIMARY);  // Ignore case and accents
        names.sort(customCollator::compare);
        System.out.println("Custom: " + names);
    }
}
```

#### Wzorce i best practices

##### String Builder patterns

```java
public class StringBuilderPatterns {
    // Fluent StringBuilder
    public static class FluentStringBuilder {
        private final StringBuilder sb = new StringBuilder();
        
        public FluentStringBuilder append(String str) {
            sb.append(str);
            return this;
        }
        
        public FluentStringBuilder appendLine(String str) {
            sb.append(str).append(System.lineSeparator());
            return this;
        }
        
        public FluentStringBuilder appendIf(boolean condition, String str) {
            if (condition) {
                sb.append(str);
            }
            return this;
        }
        
        public FluentStringBuilder repeat(String str, int times) {
            for (int i = 0; i < times; i++) {
                sb.append(str);
            }
            return this;
        }
        
        @Override
        public String toString() {
            return sb.toString();
        }
    }
    
    // Template pattern
    public static class StringTemplate {
        private final String template;
        private final Map<String, String> placeholders = new HashMap<>();
        
        public StringTemplate(String template) {
            this.template = template;
        }
        
        public StringTemplate set(String key, String value) {
            placeholders.put(key, value);
            return this;
        }
        
        public String build() {
            String result = template;
            for (Map.Entry<String, String> entry : placeholders.entrySet()) {
                result = result.replace("${" + entry.getKey() + "}", entry.getValue());
            }
            return result;
        }
    }
    
    // Usage examples
    public void demonstratePatterns() {
        // Fluent builder
        String html = new FluentStringBuilder()
            .append("<html>")
            .appendLine("<head><title>My Page</title></head>")
            .append("<body>")
            .appendIf(true, "<h1>Welcome!</h1>")
            .repeat("<p>Content</p>", 3)
            .append("</body></html>")
            .toString();
        
        // Template
        String email = new StringTemplate("Hello ${name}, your order ${orderId} is ready!")
            .set("name", "Anna")
            .set("orderId", "12345")
            .build();
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj wydajny algorytm wyszukiwania wzorca w tekÅ›cie (np. KMP lub Boyer-Moore) i porÃ³wnaj jego wydajnoÅ›Ä‡ z wbudowanym `indexOf()`.

**Zadanie Zaawansowane 2:** StwÃ³rz thread-safe String pool z automatycznym czyszczeniem nieuÅ¼ywanych String uÅ¼ywajÄ…c WeakReference i scheduled cleanup.

**Zadanie Zaawansowane 3:** Zaprojektuj system template'Ã³w z obsÅ‚ugÄ… zagnieÅ¼dÅ¼onych placeholder'Ã³w, conditional blocks i loops, zoptymalizowany pod kÄ…tem wydajnoÅ›ci.

#### â“ Pytania Kontrolne - Poziom Senior

1. Jak dziaÅ‚a String pool i jakie sÄ… implikacje uÅ¼ywania `intern()` w aplikacjach produkcyjnych?
2. Dlaczego String jest immutable i jakie optymalizacje JVM z tego wynikajÄ…?
3. Jakie sÄ… rÃ³Å¼nice w reprezentacji String miÄ™dzy Java 8 a Java 9+ i jak wpÅ‚ywa to na zuÅ¼ycie pamiÄ™ci?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static boolean czyPalindrom(String tekst) {
    if (tekst == null) return false;
    
    // UsuÅ„ spacje i zmieÅ„ na maÅ‚e litery
    String oczyszczony = tekst.replaceAll("\\s+", "").toLowerCase();
    
    int left = 0;
    int right = oczyszczony.length() - 1;
    
    while (left < right) {
        if (oczyszczony.charAt(left) != oczyszczony.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

// Test:
System.out.println(czyPalindrom("A man a plan a canal Panama")); // true
System.out.println(czyPalindrom("race a car")); // false
```

**Zadanie 2:**
```java
public static Map<Character, Integer> zliczLitery(String tekst) {
    Map<Character, Integer> licznik = new HashMap<>();
    
    for (char c : tekst.toLowerCase().toCharArray()) {
        if (Character.isLetter(c)) {
            licznik.put(c, licznik.getOrDefault(c, 0) + 1);
        }
    }
    
    return licznik;
}

// Test:
Map<Character, Integer> wynik = zliczLitery("Hello World");
wynik.forEach((litera, ilosc) -> 
    System.out.println(litera + ": " + ilosc));
```

**Zadanie 3:**
```java
public static String maskujKarte(String numerKarty) {
    if (numerKarty == null || numerKarty.length() < 4) {
        return numerKarty;
    }
    
    // UsuÅ„ wszystkie nie-cyfry
    String cyfry = numerKarty.replaceAll("\\D", "");
    
    if (cyfry.length() < 4) {
        return numerKarty;
    }
    
    String ostatnieCztery = cyfry.substring(cyfry.length() - 4);
    String maska = "*".repeat(cyfry.length() - 4);
    
    return maska + ostatnieCztery;
}

// Test:
System.out.println(maskujKarte("1234-5678-9012-3456")); // ************3456
System.out.println(maskujKarte("4111 1111 1111 1111")); // ************1111
```

**Pytania kontrolne:**
1. String jest immutable dla bezpieczeÅ„stwa (String pool, hash codes), thread safety i optymalizacji. Konsekwencja: kaÅ¼da "modyfikacja" tworzy nowy obiekt.
2. `trim()` usuwa tylko ASCII whitespace, `strip()` usuwa wszystkie Unicode whitespace characters.
3. StringBuilder gdy robisz wiele konkatenacji (szczegÃ³lnie w pÄ™tlach), `+` dla pojedynczych operacji.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class KMPStringSearch {
    // Knuth-Morris-Pratt algorithm
    public static int kmpSearch(String text, String pattern) {
        if (pattern.isEmpty()) return 0;
        
        int[] lps = computeLPSArray(pattern);
        int i = 0; // index for text
        int j = 0; // index for pattern
        
        while (i < text.length()) {
            if (pattern.charAt(j) == text.charAt(i)) {
                i++;
                j++;
            }
            
            if (j == pattern.length()) {
                return i - j; // Found match
            } else if (i < text.length() && pattern.charAt(j) != text.charAt(i)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1; // Not found
    }
    
    private static int[] computeLPSArray(String pattern) {
        int[] lps = new int[pattern.length()];
        int len = 0;
        int i = 1;
        
        while (i < pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    // Benchmark comparison
    @Benchmark
    public int builtinIndexOf(String text, String pattern) {
        return text.indexOf(pattern);
    }
    
    @Benchmark
    public int kmpIndexOf(String text, String pattern) {
        return kmpSearch(text, pattern);
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class ThreadSafeStringPool {
    private final ConcurrentHashMap<String, WeakReference<String>> pool = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cleanupExecutor = Executors.newSingleThreadScheduledExecutor();
    private final AtomicLong accessCounter = new AtomicLong();
    
    public ThreadSafeStringPool() {
        // Cleanup co 5 minut
        cleanupExecutor.scheduleAtFixedRate(this::cleanup, 5, 5, TimeUnit.MINUTES);
    }
    
    public String intern(String str) {
        if (str == null) return null;
        
        accessCounter.incrementAndGet();
        
        return pool.compute(str, (key, ref) -> {
            String existing = (ref != null) ? ref.get() : null;
            if (existing != null) {
                return ref; // Reuse existing reference
            } else {
                return new WeakReference<>(str); // Create new reference
            }
        }).get();
    }
    
    private void cleanup() {
        int removed = 0;
        Iterator<Map.Entry<String, WeakReference<String>>> iterator = pool.entrySet().iterator();
        
        while (iterator.hasNext()) {
            Map.Entry<String, WeakReference<String>> entry = iterator.next();
            if (entry.getValue().get() == null) {
                iterator.remove();
                removed++;
            }
        }
        
        System.out.printf("Cleanup: removed %d entries, pool size: %d, total accesses: %d%n", 
                         removed, pool.size(), accessCounter.get());
    }
    
    public void shutdown() {
        cleanupExecutor.shutdown();
    }
    
    public int getPoolSize() {
        return pool.size();
    }
    
    public long getAccessCount() {
        return accessCounter.get();
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class AdvancedTemplateEngine {
    private final Pattern placeholderPattern = Pattern.compile("\\$\\{([^}]+)\\}");
    private final Pattern conditionalPattern = Pattern.compile("\\{\\{#if\\s+([^}]+)\\}\\}(.*?)\\{\\{/if\\}\\}", Pattern.DOTALL);
    private final Pattern loopPattern = Pattern.compile("\\{\\{#each\\s+([^}]+)\\}\\}(.*?)\\{\\{/each\\}\\}", Pattern.DOTALL);
    
    public static class Template {
        private final String compiledTemplate;
        private final List<String> placeholders;
        
        private Template(String compiledTemplate, List<String> placeholders) {
            this.compiledTemplate = compiledTemplate;
            this.placeholders = placeholders;
        }
        
        public String render(Map<String, Object> context) {
            String result = compiledTemplate;
            
            for (String placeholder : placeholders) {
                Object value = getNestedValue(context, placeholder);
                String replacement = value != null ? value.toString() : "";
                result = result.replace("${" + placeholder + "}", replacement);
            }
            
            return result;
        }
        
        private Object getNestedValue(Map<String, Object> context, String path) {
            String[] parts = path.split("\\.");
            Object current = context;
            
            for (String part : parts) {
                if (current instanceof Map) {
                    current = ((Map<?, ?>) current).get(part);
                } else {
                    return null;
                }
            }
            
            return current;
        }
    }
    
    public Template compile(String template) {
        String processed = template;
        List<String> placeholders = new ArrayList<>();
        
        // Process conditionals
        processed = processConditionals(processed);
        
        // Process loops
        processed = processLoops(processed);
        
        // Extract placeholders
        Matcher matcher = placeholderPattern.matcher(processed);
        while (matcher.find()) {
            String placeholder = matcher.group(1);
            if (!placeholders.contains(placeholder)) {
                placeholders.add(placeholder);
            }
        }
        
        return new Template(processed, placeholders);
    }
    
    private String processConditionals(String template) {
        Matcher matcher = conditionalPattern.matcher(template);
        StringBuffer result = new StringBuffer();
        
        while (matcher.find()) {
            String condition = matcher.group(1);
            String content = matcher.group(2);
            
            // Simplified condition processing
            String replacement = "{{CONDITIONAL:" + condition + ":" + content + "}}";
            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));
        }
        
        matcher.appendTail(result);
        return result.toString();
    }
    
    private String processLoops(String template) {
        Matcher matcher = loopPattern.matcher(template);
        StringBuffer result = new StringBuffer();
        
        while (matcher.find()) {
            String collection = matcher.group(1);
            String content = matcher.group(2);
            
            String replacement = "{{LOOP:" + collection + ":" + content + "}}";
            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));
        }
        
        matcher.appendTail(result);
        return result.toString();
    }
}
```

**Pytania kontrolne:**
1. String pool przechowuje unique String instances w pamiÄ™ci. `intern()` moÅ¼e prowadziÄ‡ do memory leaks w produkcji, bo pool nigdy nie jest czyszczony. Lepiej uÅ¼ywaÄ‡ custom pools z WeakReference.
2. Immutability zapewnia thread safety, pozwala na hash code caching, String pool optimization i bezpieczne przekazywanie referencji. JVM moÅ¼e optymalizowaÄ‡ przez constant folding i escape analysis.
3. Java 9+ uÅ¼ywa Compact Strings (byte[] zamiast char[]), automatycznie wybierajÄ…c Latin-1 vs UTF-16. OszczÄ™dza ~50% pamiÄ™ci dla ASCII strings.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Teraz masz peÅ‚ne zrozumienie String w Javie - od podstawowych operacji po zaawansowane optymalizacje i wzorce. String to narzÄ™dzie, ktÃ³rego bÄ™dziesz uÅ¼ywaÄ‡ w kaÅ¼dym programie, wiÄ™c warto znaÄ‡ wszystkie jego moÅ¼liwoÅ›ci. W nastÄ™pnym rozdziale porozmawiamy o StringBuilder i StringBuffer - czyli o tym, jak ogarnÄ…Ä‡ duÅ¼o tekstu wydajnie!*

---

*ğŸ’¡ PamiÄ™taj: String jest immutable z bardzo dobrych powodÃ³w. UÅ¼ywaj go Å›wiadomie i pamiÄ™taj o wydajnoÅ›ci przy intensywnych operacjach tekstowych!*


## 8. StringBuilder i StringBuffer: jak ogarnÄ…Ä‡ duÅ¼o tekstu

*CzeÅ›Ä‡! DziÅ› porozmawiamy o StringBuilder i StringBuffer - czyli o tym, jak efektywnie budowaÄ‡ dÅ‚ugie teksty w Javie. JeÅ›li w poprzednim rozdziale String byÅ‚ jak niezmienialny notes, to StringBuilder to jak tablica, na ktÃ³rej moÅ¼esz pisaÄ‡, mazaÄ‡ i przepisywaÄ‡ do woli. To narzÄ™dzie, ktÃ³re uratuje CiÄ™ przed problemami wydajnoÅ›ciowymi przy intensywnej pracy z tekstem!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

StringBuilder i StringBuffer to **mutable** (zmienialny) odpowiednik String. Podczas gdy kaÅ¼da operacja na String tworzy nowy obiekt, StringBuilder pozwala modyfikowaÄ‡ zawartoÅ›Ä‡ bez tworzenia nowych obiektÃ³w.

```java
// String - kaÅ¼da operacja tworzy nowy obiekt
String tekst = "Hello";
tekst += " World";  // Tworzy nowy String!
tekst += "!";       // Znowu nowy String!

// StringBuilder - modyfikuje istniejÄ…cy obiekt
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");  // Modyfikuje istniejÄ…cy obiekt
sb.append("!");       // Nadal ten sam obiekt
String wynik = sb.toString();  // Konwersja do String tylko na koÅ„cu
```

#### Dlaczego to waÅ¼ne?

Gdy budujesz dÅ‚ugie teksty (szczegÃ³lnie w pÄ™tlach), StringBuilder jest znacznie wydajniejszy niÅ¼ konkatenacja String. To rÃ³Å¼nica miÄ™dzy O(nÂ²) a O(n) zÅ‚oÅ¼onoÅ›ciÄ… czasowÄ…!

```java
// Å¹LE - O(nÂ²) zÅ‚oÅ¼onoÅ›Ä‡!
String wynik = "";
for (int i = 0; i < 1000; i++) {
    wynik += "element " + i + ", ";  // KaÅ¼da iteracja tworzy nowy String
}

// DOBRZE - O(n) zÅ‚oÅ¼onoÅ›Ä‡!
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append("element ").append(i).append(", ");
}
String wynik = sb.toString();
```

#### Jak to dziaÅ‚a w praktyce?

**Podstawowe operacje StringBuilder:**

```java
public class PodstawoweStringBuilder {
    public static void main(String[] args) {
        // Tworzenie StringBuilder
        StringBuilder sb1 = new StringBuilder();                    // Pusty
        StringBuilder sb2 = new StringBuilder("Hello");             // Z poczÄ…tkowÄ… wartoÅ›ciÄ…
        StringBuilder sb3 = new StringBuilder(100);                 // Z poczÄ…tkowÄ… pojemnoÅ›ciÄ…
        
        // Dodawanie tekstu
        sb1.append("Java");
        sb1.append(" ");
        sb1.append("Programming");
        System.out.println(sb1);  // "Java Programming"
        
        // ÅaÅ„cuchowe wywoÅ‚ania (method chaining)
        StringBuilder sb4 = new StringBuilder()
            .append("CzeÅ›Ä‡ ")
            .append("Anna")
            .append("! ")
            .append("Masz ")
            .append(25)
            .append(" lat.");
        System.out.println(sb4);  // "CzeÅ›Ä‡ Anna! Masz 25 lat."
        
        // Wstawianie w okreÅ›lonym miejscu
        StringBuilder sb5 = new StringBuilder("Hello World");
        sb5.insert(6, "Beautiful ");
        System.out.println(sb5);  // "Hello Beautiful World"
        
        // Usuwanie fragmentÃ³w
        sb5.delete(6, 16);  // Usuwa "Beautiful "
        System.out.println(sb5);  // "Hello World"
        
        // ZastÄ™powanie fragmentÃ³w
        sb5.replace(0, 5, "Hi");
        System.out.println(sb5);  // "Hi World"
        
        // Odwracanie
        StringBuilder sb6 = new StringBuilder("Java");
        sb6.reverse();
        System.out.println(sb6);  // "avaJ"
    }
}
```

**StringBuilder vs StringBuffer:**

```java
public class StringBuilderVsStringBuffer {
    public static void main(String[] args) {
        // StringBuilder - NIE jest thread-safe, ale szybszy
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        sb.append(" World");
        
        // StringBuffer - JEST thread-safe, ale wolniejszy
        StringBuffer sbf = new StringBuffer();
        sbf.append("Hello");
        sbf.append(" World");
        
        // W praktyce: uÅ¼ywaj StringBuilder, chyba Å¼e potrzebujesz thread safety
        
        // Konwersja do String
        String fromBuilder = sb.toString();
        String fromBuffer = sbf.toString();
        
        System.out.println("StringBuilder: " + fromBuilder);
        System.out.println("StringBuffer: " + fromBuffer);
    }
}
```

**Praktyczne przykÅ‚ady uÅ¼ycia:**

```java
public class PraktyczneStringBuilder {
    // Budowanie HTML
    public static String buildHtml(String title, List<String> items) {
        StringBuilder html = new StringBuilder();
        html.append("<!DOCTYPE html>")
            .append("<html>")
            .append("<head><title>").append(title).append("</title></head>")
            .append("<body>")
            .append("<h1>").append(title).append("</h1>")
            .append("<ul>");
        
        for (String item : items) {
            html.append("<li>").append(item).append("</li>");
        }
        
        html.append("</ul>")
            .append("</body>")
            .append("</html>");
        
        return html.toString();
    }
    
    // Budowanie CSV
    public static String buildCsv(List<String[]> rows) {
        StringBuilder csv = new StringBuilder();
        
        for (String[] row : rows) {
            for (int i = 0; i < row.length; i++) {
                if (i > 0) csv.append(",");
                csv.append("\"").append(row[i].replace("\"", "\"\"")).append("\"");
            }
            csv.append("\n");
        }
        
        return csv.toString();
    }
    
    // Formatowanie liczb z separatorami
    public static String formatNumber(long number) {
        StringBuilder sb = new StringBuilder(Long.toString(number));
        
        // Dodaj separatory co 3 cyfry od koÅ„ca
        for (int i = sb.length() - 3; i > 0; i -= 3) {
            sb.insert(i, ",");
        }
        
        return sb.toString();
    }
    
    public static void main(String[] args) {
        // Test HTML
        List<String> items = Arrays.asList("Java", "Python", "JavaScript");
        System.out.println(buildHtml("JÄ™zyki programowania", items));
        
        // Test CSV
        List<String[]> rows = Arrays.asList(
            new String[]{"ImiÄ™", "Wiek", "Miasto"},
            new String[]{"Anna", "25", "Warszawa"},
            new String[]{"Kasia", "30", "KrakÃ³w"}
        );
        System.out.println(buildCsv(rows));
        
        // Test formatowania liczb
        System.out.println(formatNumber(1234567));  // "1,234,567"
    }
}
```

#### ZarzÄ…dzanie pojemnoÅ›ciÄ…

```java
public class ZarzadzaniePojemnoscia {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        
        // Sprawdzanie pojemnoÅ›ci
        System.out.println("PoczÄ…tkowa pojemnoÅ›Ä‡: " + sb.capacity());  // 16
        System.out.println("DÅ‚ugoÅ›Ä‡: " + sb.length());                  // 0
        
        // Dodawanie tekstu
        sb.append("Hello World Programming");
        System.out.println("Po dodaniu tekstu:");
        System.out.println("PojemnoÅ›Ä‡: " + sb.capacity());  // Automatycznie zwiÄ™kszona
        System.out.println("DÅ‚ugoÅ›Ä‡: " + sb.length());
        
        // RÄ™czne ustawianie pojemnoÅ›ci
        sb.ensureCapacity(100);  // Zapewnia minimum 100 znakÃ³w
        System.out.println("Po ensureCapacity(100): " + sb.capacity());
        
        // Zmniejszanie pojemnoÅ›ci do rzeczywistej dÅ‚ugoÅ›ci
        sb.trimToSize();
        System.out.println("Po trimToSize(): " + sb.capacity());
        
        // Ustawianie dÅ‚ugoÅ›ci (moÅ¼e obciÄ…Ä‡ tekst)
        sb.setLength(5);
        System.out.println("Po setLength(5): '" + sb + "'");  // "Hello"
    }
}
```

#### PuÅ‚apki, na ktÃ³re warto uwaÅ¼aÄ‡

**PuÅ‚apka 1: Thread safety**

```java
// Å¹LE - StringBuilder w Å›rodowisku wielowÄ…tkowym
StringBuilder shared = new StringBuilder();

// Thread 1
shared.append("Hello ");

// Thread 2 (jednoczeÅ›nie)
shared.append("World");

// Wynik moÅ¼e byÄ‡ nieprzewidywalny!

// DOBRZE - StringBuffer lub synchronizacja
StringBuffer threadSafe = new StringBuffer();
// lub
StringBuilder sb = new StringBuilder();
synchronized(sb) {
    sb.append("Hello ");
}
```

**PuÅ‚apka 2: Zapominanie o toString()**

```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");

// Å¹LE - porÃ³wnujesz obiekty StringBuilder
if (sb.equals("Hello World")) {  // Zawsze false!
    System.out.println("Nigdy siÄ™ nie wykona");
}

// DOBRZE - konwertuj do String
if (sb.toString().equals("Hello World")) {
    System.out.println("To siÄ™ wykona");
}
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **UÅ¼ywaj StringBuilder** dla konkatenacji w pÄ™tlach
- **StringBuffer tylko** gdy potrzebujesz thread safety
- **Ustaw poczÄ…tkowÄ… pojemnoÅ›Ä‡** jeÅ›li znasz przybliÅ¼ony rozmiar
- **Method chaining** czyni kod bardziej czytelnym
- **PamiÄ™taj o toString()** na koÅ„cu

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** Napisz metodÄ™, ktÃ³ra tworzy "drabinkÄ™" z gwiazdek o podanej wysokoÅ›ci.

```java
public static String stworzDrabinke(int wysokosc) {
    // PrzykÅ‚ad dla wysokosc=3:
    // *
    // **
    // ***
}
```

**Zadanie 2:** StwÃ³rz metodÄ™, ktÃ³ra odwraca sÅ‚owa w zdaniu, ale zachowuje ich kolejnoÅ›Ä‡.

**Zadanie 3:** Napisz funkcjÄ™, ktÃ³ra tworzy prosty raport z listy produktÃ³w (nazwa, cena, iloÅ›Ä‡).

#### â“ Pytania Kontrolne - Poziom Junior

1. Jaka jest gÅ‚Ã³wna rÃ³Å¼nica miÄ™dzy String a StringBuilder?
2. Kiedy uÅ¼ywaÄ‡ StringBuffer zamiast StringBuilder?
3. Dlaczego StringBuilder jest wydajniejszy przy wielu konkatenacjach?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

StringBuilder i StringBuffer to nie tylko wygodne narzÄ™dzia - to przykÅ‚ady przemyÅ›lanej architektury, ktÃ³ra balansuje miÄ™dzy wydajnoÅ›ciÄ…, bezpieczeÅ„stwem i uÅ¼ytecznoÅ›ciÄ…. Przyjrzyjmy siÄ™ ich wewnÄ™trznej implementacji i zaawansowanym wzorcom uÅ¼ycia.

##### WewnÄ™trzna implementacja

```java
public class StringBuilderInternals {
    // Uproszczona implementacja pokazujÄ…ca kluczowe koncepty
    public static class SimpleStringBuilder {
        private char[] buffer;
        private int length;
        
        public SimpleStringBuilder(int capacity) {
            this.buffer = new char[capacity];
            this.length = 0;
        }
        
        public SimpleStringBuilder append(String str) {
            int newLength = length + str.length();
            ensureCapacity(newLength);
            
            str.getChars(0, str.length(), buffer, length);
            length = newLength;
            return this;
        }
        
        private void ensureCapacity(int minimumCapacity) {
            if (minimumCapacity > buffer.length) {
                int newCapacity = Math.max(minimumCapacity, buffer.length * 2 + 2);
                buffer = Arrays.copyOf(buffer, newCapacity);
            }
        }
        
        @Override
        public String toString() {
            return new String(buffer, 0, length);
        }
    }
    
    // Performance analysis
    public void analyzeGrowthStrategy() {
        StringBuilder sb = new StringBuilder(1);  // Start small
        
        for (int i = 0; i < 20; i++) {
            int capacityBefore = sb.capacity();
            sb.append("x");
            int capacityAfter = sb.capacity();
            
            if (capacityBefore != capacityAfter) {
                System.out.printf("Growth: %d -> %d (factor: %.2f)%n", 
                    capacityBefore, capacityAfter, (double)capacityAfter / capacityBefore);
            }
        }
    }
}
```

##### Advanced patterns i optymalizacje

```java
public class AdvancedStringBuilderPatterns {
    // Object pooling dla StringBuilder
    public static class StringBuilderPool {
        private final Queue<StringBuilder> pool = new ConcurrentLinkedQueue<>();
        private final int maxPoolSize;
        private final int initialCapacity;
        
        public StringBuilderPool(int maxPoolSize, int initialCapacity) {
            this.maxPoolSize = maxPoolSize;
            this.initialCapacity = initialCapacity;
        }
        
        public StringBuilder acquire() {
            StringBuilder sb = pool.poll();
            if (sb == null) {
                sb = new StringBuilder(initialCapacity);
            } else {
                sb.setLength(0);  // Clear content
            }
            return sb;
        }
        
        public void release(StringBuilder sb) {
            if (pool.size() < maxPoolSize && sb.capacity() <= initialCapacity * 4) {
                pool.offer(sb);
            }
        }
        
        public String buildString(Function<StringBuilder, StringBuilder> builder) {
            StringBuilder sb = acquire();
            try {
                return builder.apply(sb).toString();
            } finally {
                release(sb);
            }
        }
    }
    
    // Template-based string building
    public static class StringTemplate {
        private final List<Object> parts = new ArrayList<>();
        
        public StringTemplate text(String text) {
            parts.add(text);
            return this;
        }
        
        public StringTemplate placeholder(String name) {
            parts.add(new Placeholder(name));
            return this;
        }
        
        public String build(Map<String, Object> values) {
            StringBuilder sb = new StringBuilder();
            for (Object part : parts) {
                if (part instanceof String) {
                    sb.append(part);
                } else if (part instanceof Placeholder) {
                    Object value = values.get(((Placeholder) part).name);
                    sb.append(value != null ? value : "");
                }
            }
            return sb.toString();
        }
        
        private static class Placeholder {
            final String name;
            Placeholder(String name) { this.name = name; }
        }
    }
    
    // Streaming string builder
    public static class StreamingStringBuilder {
        private final StringBuilder sb = new StringBuilder();
        
        public StreamingStringBuilder appendIf(boolean condition, String text) {
            if (condition) sb.append(text);
            return this;
        }
        
        public StreamingStringBuilder appendForEach(Iterable<?> items, 
                                                   Function<Object, String> mapper) {
            for (Object item : items) {
                sb.append(mapper.apply(item));
            }
            return this;
        }
        
        public StreamingStringBuilder appendJoin(Iterable<?> items, 
                                               String delimiter,
                                               Function<Object, String> mapper) {
            boolean first = true;
            for (Object item : items) {
                if (!first) sb.append(delimiter);
                sb.append(mapper.apply(item));
                first = false;
            }
            return this;
        }
        
        @Override
        public String toString() {
            return sb.toString();
        }
    }
}
```

#### Performance benchmarks

```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public class StringBuilderBenchmarks {
    private static final int ITERATIONS = 1000;
    
    @Benchmark
    public String stringConcatenation() {
        String result = "";
        for (int i = 0; i < ITERATIONS; i++) {
            result += "item" + i;
        }
        return result;
    }
    
    @Benchmark
    public String stringBuilderDefault() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < ITERATIONS; i++) {
            sb.append("item").append(i);
        }
        return sb.toString();
    }
    
    @Benchmark
    public String stringBuilderPreSized() {
        StringBuilder sb = new StringBuilder(ITERATIONS * 10);  // Pre-allocate
        for (int i = 0; i < ITERATIONS; i++) {
            sb.append("item").append(i);
        }
        return sb.toString();
    }
    
    @Benchmark
    public String stringJoiner() {
        StringJoiner joiner = new StringJoiner("");
        for (int i = 0; i < ITERATIONS; i++) {
            joiner.add("item" + i);
        }
        return joiner.toString();
    }
    
    @Benchmark
    public String streamJoining() {
        return IntStream.range(0, ITERATIONS)
            .mapToObj(i -> "item" + i)
            .collect(Collectors.joining());
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj thread-safe StringBuilder pool z automatycznym zarzÄ…dzaniem rozmiarem i metrykami uÅ¼ycia.

**Zadanie Zaawansowane 2:** StwÃ³rz system template'Ã³w z lazy evaluation i caching, zoptymalizowany pod kÄ…tem wydajnoÅ›ci dla czÄ™stych renderowaÅ„.

#### â“ Pytania Kontrolne - Poziom Senior

1. Jak dziaÅ‚a strategia wzrostu pojemnoÅ›ci w StringBuilder i dlaczego jest efektywna?
2. Jakie sÄ… trade-offs miÄ™dzy StringBuilder pooling a tworzeniem nowych instancji?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static String stworzDrabinke(int wysokosc) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = 1; i <= wysokosc; i++) {
        for (int j = 0; j < i; j++) {
            sb.append("*");
        }
        if (i < wysokosc) {  // Nie dodawaj nowej linii po ostatnim wierszu
            sb.append("\n");
        }
    }
    
    return sb.toString();
}
```

**Zadanie 2:**
```java
public static String odwrocSlowa(String zdanie) {
    String[] slowa = zdanie.split(" ");
    StringBuilder sb = new StringBuilder();
    
    for (int i = 0; i < slowa.length; i++) {
        if (i > 0) sb.append(" ");
        
        // OdwrÃ³Ä‡ kaÅ¼de sÅ‚owo
        StringBuilder slowoSb = new StringBuilder(slowa[i]);
        sb.append(slowoSb.reverse());
    }
    
    return sb.toString();
}
```

**Zadanie 3:**
```java
public static String stworzRaport(List<Produkt> produkty) {
    StringBuilder sb = new StringBuilder();
    
    sb.append("RAPORT PRODUKTÃ“W\n");
    sb.append("================\n\n");
    
    double sumaWartosci = 0;
    
    for (Produkt p : produkty) {
        double wartosc = p.getCena() * p.getIlosc();
        sumaWartosci += wartosc;
        
        sb.append(String.format("%-20s | %8.2f zÅ‚ | %5d szt | %10.2f zÅ‚\n",
            p.getNazwa(), p.getCena(), p.getIlosc(), wartosc));
    }
    
    sb.append("\n");
    sb.append("SUMA WARTOÅšCI: ").append(String.format("%.2f zÅ‚", sumaWartosci));
    
    return sb.toString();
}
```

**Pytania kontrolne:**
1. String jest immutable - kaÅ¼da operacja tworzy nowy obiekt. StringBuilder jest mutable - modyfikuje istniejÄ…cy obiekt.
2. StringBuffer gdy potrzebujesz thread safety (metody sÄ… synchronized). StringBuilder jest szybszy ale nie thread-safe.
3. StringBuilder unika tworzenia wielu poÅ›rednich obiektÃ³w String, co redukuje alokacje pamiÄ™ci i presjÄ™ na GC.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class ThreadSafeStringBuilderPool {
    private final ConcurrentLinkedQueue<StringBuilder> pool = new ConcurrentLinkedQueue<>();
    private final AtomicInteger poolSize = new AtomicInteger(0);
    private final AtomicLong totalAcquisitions = new AtomicLong(0);
    private final AtomicLong poolHits = new AtomicLong(0);
    
    private final int maxPoolSize;
    private final int initialCapacity;
    private final int maxRetainedCapacity;
    
    public ThreadSafeStringBuilderPool(int maxPoolSize, int initialCapacity, int maxRetainedCapacity) {
        this.maxPoolSize = maxPoolSize;
        this.initialCapacity = initialCapacity;
        this.maxRetainedCapacity = maxRetainedCapacity;
    }
    
    public StringBuilder acquire() {
        totalAcquisitions.incrementAndGet();
        
        StringBuilder sb = pool.poll();
        if (sb != null) {
            poolSize.decrementAndGet();
            poolHits.incrementAndGet();
            sb.setLength(0);
            return sb;
        }
        
        return new StringBuilder(initialCapacity);
    }
    
    public void release(StringBuilder sb) {
        if (sb.capacity() <= maxRetainedCapacity && poolSize.get() < maxPoolSize) {
            if (pool.offer(sb)) {
                poolSize.incrementAndGet();
            }
        }
    }
    
    public PoolMetrics getMetrics() {
        long total = totalAcquisitions.get();
        long hits = poolHits.get();
        return new PoolMetrics(
            poolSize.get(),
            total,
            hits,
            total > 0 ? (double) hits / total : 0.0
        );
    }
    
    public static class PoolMetrics {
        public final int currentPoolSize;
        public final long totalAcquisitions;
        public final long poolHits;
        public final double hitRate;
        
        public PoolMetrics(int currentPoolSize, long totalAcquisitions, long poolHits, double hitRate) {
            this.currentPoolSize = currentPoolSize;
            this.totalAcquisitions = totalAcquisitions;
            this.poolHits = poolHits;
            this.hitRate = hitRate;
        }
    }
}
```

**Pytania kontrolne:**
1. StringBuilder podwaja pojemnoÅ›Ä‡ + 2 gdy potrzebuje wiÄ™cej miejsca. To amortyzuje koszt kopiowania do O(1) per operacja, minimalizujÄ…c liczbÄ™ realokacji.
2. Pooling redukuje GC pressure ale zwiÄ™ksza memory footprint i complexity. OpÅ‚aca siÄ™ dla high-frequency, short-lived StringBuilder usage patterns.

---

#### ğŸ“š Co dalej?

*Åšwietnie! Teraz rozumiesz, jak efektywnie budowaÄ‡ dÅ‚ugie teksty w Javie. StringBuilder to narzÄ™dzie, ktÃ³re znacznie przyspieszy Twoje aplikacje przy intensywnej pracy z tekstem. W nastÄ™pnym rozdziale porozmawiamy o Text Blocks - czyli o wielolinijkowych String bez bÃ³lu!*


## 9. Text Blocks (""") â€” czyli wielolinijkowe Stringi bez bÃ³lu

*CzeÅ›Ä‡! Na koniec pierwszej sekcji porozmawiamy o Text Blocks - jednej z najfajniejszych funkcjonalnoÅ›ci dodanych do Javy w ostatnich latach. JeÅ›li kiedykolwiek mÄ™czyÅ‚aÅ› siÄ™ z budowaniem wielolinijkowych String uÅ¼ywajÄ…c \n i konkatenacji, to Text Blocks to TwÃ³j nowy najlepszy przyjaciel. Przygotuj siÄ™ na odkrycie, jak elegancko moÅ¼na pisaÄ‡ kod z dÅ‚ugimi tekstami!*

---

### ğŸŒ± CzÄ™Å›Ä‡ dla Juniorek

#### Co to wÅ‚aÅ›ciwie jest?

Text Blocks (wprowadzone w Javie 15) to sposÃ³b na tworzenie wielolinijkowych String bez uÅ¼ywania escape sequences i konkatenacji. Zamiast mÄ™czyÄ‡ siÄ™ z `\n` i `\"`, po prostu piszesz tekst tak, jak chcesz, Å¼eby wyglÄ…daÅ‚.

```java
// Stary sposÃ³b - okropny!
String html = "<html>\n" +
              "  <head>\n" +
              "    <title>Moja strona</title>\n" +
              "  </head>\n" +
              "  <body>\n" +
              "    <h1>Witaj!</h1>\n" +
              "  </body>\n" +
              "</html>";

// Nowy sposÃ³b - piÄ™kny!
String html = """
              <html>
                <head>
                  <title>Moja strona</title>
                </head>
                <body>
                  <h1>Witaj!</h1>
                </body>
              </html>
              """;
```

#### Dlaczego to waÅ¼ne?

Text Blocks znacznie poprawiajÄ… czytelnoÅ›Ä‡ kodu, szczegÃ³lnie gdy pracujesz z:
- HTML/XML
- JSON
- SQL queries
- Wielolinijkowymi komunikatami
- DokumentacjÄ… w kodzie

#### Jak to dziaÅ‚a w praktyce?

**Podstawowa skÅ‚adnia:**

```java
public class PodstawoweTextBlocks {
    public static void main(String[] args) {
        // Podstawowy text block
        String powitanie = """
                          CzeÅ›Ä‡!
                          Jak siÄ™ masz?
                          MiÅ‚ego dnia!
                          """;
        System.out.println(powitanie);
        
        // Text block z interpolacjÄ…
        String imie = "Anna";
        int wiek = 25;
        String wiadomosc = """
                          CzeÅ›Ä‡ %s!
                          Masz %d lat.
                          MiÅ‚o CiÄ™ poznaÄ‡!
                          """.formatted(imie, wiek);
        System.out.println(wiadomosc);
        
        // Pusty text block
        String pusty = """
                      """;
        System.out.println("DÅ‚ugoÅ›Ä‡ pustego: " + pusty.length());  // 0
    }
}
```

**Praktyczne przykÅ‚ady:**

```java
public class PraktyczneTextBlocks {
    // JSON
    public static String createJsonUser(String name, String email, int age) {
        return """
               {
                 "name": "%s",
                 "email": "%s",
                 "age": %d,
                 "active": true
               }
               """.formatted(name, email, age);
    }
    
    // SQL Query
    public static String getUsersQuery(String city, int minAge) {
        return """
               SELECT u.id, u.name, u.email, p.phone
               FROM users u
               LEFT JOIN profiles p ON u.id = p.user_id
               WHERE u.city = '%s'
                 AND u.age >= %d
                 AND u.active = true
               ORDER BY u.name
               """.formatted(city, minAge);
    }
    
    // HTML Template
    public static String createHtmlPage(String title, String content) {
        return """
               <!DOCTYPE html>
               <html lang="pl">
               <head>
                   <meta charset="UTF-8">
                   <meta name="viewport" content="width=device-width, initial-scale=1.0">
                   <title>%s</title>
                   <style>
                       body { font-family: Arial, sans-serif; margin: 40px; }
                       h1 { color: #333; }
                   </style>
               </head>
               <body>
                   <h1>%s</h1>
                   <div class="content">
                       %s
                   </div>
               </body>
               </html>
               """.formatted(title, title, content);
    }
    
    public static void main(String[] args) {
        // Test JSON
        System.out.println(createJsonUser("Anna Kowalska", "anna@example.com", 25));
        
        // Test SQL
        System.out.println(getUsersQuery("Warszawa", 18));
        
        // Test HTML
        System.out.println(createHtmlPage("Moja strona", "<p>Witaj na mojej stronie!</p>"));
    }
}
```

**ZarzÄ…dzanie wciÄ™ciami:**

```java
public class ZarzadzanieWcieciami {
    public static void main(String[] args) {
        // Text block automatycznie usuwa wspÃ³lne wciÄ™cia
        String tekst1 = """
                        Pierwsza linia
                        Druga linia
                        Trzecia linia
                        """;
        
        // To samo co:
        String tekst2 = """
Pierwsza linia
Druga linia
Trzecia linia
""";
        
        System.out.println("Tekst1 equals Tekst2: " + tekst1.equals(tekst2));  // true
        
        // Kontrolowanie wciÄ™Ä‡
        String sformatowany = """
                             Linia z wciÄ™ciem
                               Linia z wiÄ™kszym wciÄ™ciem
                             Znowu normalne wciÄ™cie
                             """;
        System.out.println(sformatowany);
        
        // Metody do manipulacji wciÄ™Ä‡
        String bezWciec = tekst1.stripIndent();
        String zWcieciem = tekst1.indent(4);
        
        System.out.println("Bez wciÄ™Ä‡:\n" + bezWciec);
        System.out.println("Z wciÄ™ciem:\n" + zWcieciem);
    }
}
```

#### Escape sequences w Text Blocks

```java
public class EscapeSequences {
    public static void main(String[] args) {
        // WiÄ™kszoÅ›Ä‡ escape sequences dziaÅ‚a normalnie
        String tekst = """
                      Linia z \ttabulatorem
                      Linia z "cudzysÅ‚owami"
                      Linia z 'apostrofami'
                      """;
        System.out.println(tekst);
        
        // Specjalne przypadki
        String specjalne = """
                          Backslash: \\
                          PotrÃ³jny cudzysÅ‚Ã³w: \"\"\"
                          Nowa linia na koÅ„cu: \
                          kontynuacja tej samej linii
                          """;
        System.out.println(specjalne);
        
        // Zachowanie biaÅ‚ych znakÃ³w na koÅ„cu linii
        String bialezZnaki = """
                            Linia bez spacji na koÅ„cu
                            Linia ze spacjami na koÅ„cu   \s
                            Kolejna linia
                            """;
        System.out.println("'" + bialezZnaki + "'");
    }
}
```

#### ğŸ’¡ WskazÃ³wki dla Juniorek

- **Text blocks** Å›wietne do HTML, JSON, SQL
- **Automatyczne usuwanie wciÄ™Ä‡** - nie martw siÄ™ o formatowanie
- **UÅ¼ywaj `.formatted()`** zamiast String.format()
- **UwaÅ¼aj na biaÅ‚e znaki** na koÅ„cu linii
- **Kombinuj z StringBuilder** dla dynamicznej zawartoÅ›ci

#### ğŸ¯ Zadania dla Juniorek

**Zadanie 1:** StwÃ³rz metodÄ™ generujÄ…cÄ… email HTML z szablonem powitalnym.

**Zadanie 2:** Napisz funkcjÄ™ tworzÄ…cÄ… konfiguracjÄ™ JSON dla aplikacji.

**Zadanie 3:** Zbuduj generator prostych raportÃ³w w formacie tekstowym.

#### â“ Pytania Kontrolne - Poziom Junior

1. Jaka jest gÅ‚Ã³wna zaleta Text Blocks nad tradycyjnÄ… konkatenacjÄ…?
2. Jak Text Blocks radzÄ… sobie z wciÄ™ciami?
3. Kiedy warto uÅ¼ywaÄ‡ Text Blocks zamiast StringBuilder?

---

### ğŸš€ CzÄ™Å›Ä‡ dla Seniorek

#### GÅ‚Ä™bsza analiza tematu

Text Blocks to nie tylko syntactic sugar - to przemyÅ›lana funkcjonalnoÅ›Ä‡, ktÃ³ra wpÅ‚ywa na czytelnoÅ›Ä‡, maintainability i bezpieczeÅ„stwo kodu. Przyjrzyjmy siÄ™ zaawansowanym aspektom i wzorcom uÅ¼ycia.

##### Kompilacja i optymalizacje

```java
public class TextBlockInternals {
    // Text blocks sÄ… kompilowane do zwykÅ‚ych String literals
    public void demonstrateCompilation() {
        String textBlock = """
                          Hello
                          World
                          """;
        
        String traditional = "Hello\nWorld\n";
        
        // Te dwa String sÄ… identyczne na poziomie bytecode
        System.out.println(textBlock.equals(traditional));  // true
        System.out.println(textBlock == traditional);       // true (string pool)
    }
    
    // Performance implications
    @Benchmark
    public String textBlockCreation() {
        return """
               {
                 "name": "test",
                 "value": 123
               }
               """;
    }
    
    @Benchmark
    public String traditionalCreation() {
        return "{\n  \"name\": \"test\",\n  \"value\": 123\n}";
    }
    // Wyniki sÄ… identyczne - text blocks nie majÄ… overhead
}
```

##### Zaawansowane wzorce

```java
public class AdvancedTextBlockPatterns {
    // Template system z text blocks
    public static class TextTemplate {
        private final String template;
        
        public TextTemplate(String template) {
            this.template = template;
        }
        
        public String render(Object... args) {
            return template.formatted(args);
        }
        
        public String render(Map<String, Object> context) {
            String result = template;
            for (Map.Entry<String, Object> entry : context.entrySet()) {
                result = result.replace("${" + entry.getKey() + "}", 
                                      String.valueOf(entry.getValue()));
            }
            return result;
        }
    }
    
    // SQL Builder z text blocks
    public static class SqlBuilder {
        private final StringBuilder query = new StringBuilder();
        
        public SqlBuilder select(String... columns) {
            query.append("SELECT ").append(String.join(", ", columns));
            return this;
        }
        
        public SqlBuilder from(String table) {
            query.append("\nFROM ").append(table);
            return this;
        }
        
        public SqlBuilder where(String condition) {
            query.append("\nWHERE ").append(condition);
            return this;
        }
        
        public SqlBuilder orderBy(String... columns) {
            query.append("\nORDER BY ").append(String.join(", ", columns));
            return this;
        }
        
        @Override
        public String toString() {
            return query.toString();
        }
    }
    
    // Configuration DSL
    public static String createDockerfile(String baseImage, List<String> commands) {
        StringBuilder dockerfile = new StringBuilder();
        dockerfile.append("""
                         FROM %s
                         
                         WORKDIR /app
                         """.formatted(baseImage));
        
        for (String command : commands) {
            dockerfile.append("RUN ").append(command).append("\n");
        }
        
        dockerfile.append("""
                         
                         EXPOSE 8080
                         CMD ["java", "-jar", "app.jar"]
                         """);
        
        return dockerfile.toString();
    }
}
```

#### Security considerations

```java
public class TextBlockSecurity {
    // SQL Injection prevention
    public static class SafeSqlBuilder {
        public static String createParameterizedQuery() {
            return """
                   SELECT u.id, u.name, u.email
                   FROM users u
                   WHERE u.city = ?
                     AND u.age >= ?
                     AND u.active = true
                   ORDER BY u.name
                   """;
        }
        
        // NIGDY nie rÃ³b tego z user input!
        public static String unsafeQuery(String userInput) {
            return """
                   SELECT * FROM users
                   WHERE name = '%s'
                   """.formatted(userInput);  // SQL Injection risk!
        }
    }
    
    // XSS prevention w HTML templates
    public static String safeHtmlTemplate(String userContent) {
        String escaped = userContent
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#x27;");
        
        return """
               <div class="user-content">
                   %s
               </div>
               """.formatted(escaped);
    }
}
```

#### ğŸ”§ Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj system template'Ã³w z obsÅ‚ugÄ… includes, conditionals i loops uÅ¼ywajÄ…c text blocks jako base.

#### â“ Pytania Kontrolne - Poziom Senior

1. Jak text blocks wpÅ‚ywajÄ… na string pool i internowanie?
2. Jakie sÄ… security implications uÅ¼ywania text blocks z user input?

---

### ğŸ”‘ Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static String generateWelcomeEmail(String name, String company) {
    return """
           <!DOCTYPE html>
           <html>
           <head>
               <title>Witamy w %s!</title>
           </head>
           <body>
               <h1>CzeÅ›Ä‡ %s!</h1>
               <p>Witamy w %s. Cieszymy siÄ™, Å¼e do nas doÅ‚Ä…czyÅ‚aÅ›!</p>
               <p>Å»yczymy powodzenia!</p>
           </body>
           </html>
           """.formatted(company, name, company);
}
```

**Zadanie 2:**
```java
public static String generateAppConfig(String appName, String version, int port) {
    return """
           {
               "application": {
                   "name": "%s",
                   "version": "%s",
                   "port": %d
               },
               "database": {
                   "host": "localhost",
                   "port": 5432,
                   "name": "app_db"
               },
               "logging": {
                   "level": "INFO",
                   "file": "app.log"
               }
           }
           """.formatted(appName, version, port);
}
```

**Pytania kontrolne:**
1. CzytelnoÅ›Ä‡ - nie trzeba uÅ¼ywaÄ‡ \n i konkatenacji, kod wyglÄ…da jak docelowy tekst.
2. Automatycznie usuwajÄ… wspÃ³lne wciÄ™cia z lewej strony, zachowujÄ…c relatywne wciÄ™cia.
3. Text blocks dla statycznych template'Ã³w, StringBuilder dla dynamicznego budowania.

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Text blocks sÄ… kompilowane do zwykÅ‚ych String literals, wiÄ™c dziaÅ‚ajÄ… identycznie z string pool - mogÄ… byÄ‡ internowane.
2. Nigdy nie wstawiaj raw user input do text blocks bez escapowania - ryzyko injection attacks (SQL, XSS, etc.).

---

### ğŸ“š Koniec pierwszej sekcji!

*Gratulacje! UkoÅ„czyÅ‚aÅ› pierwszÄ… sekcjÄ™ przewodnika - "Podstawy Javy i Å›rodowiska uruchomieniowego". PoznaÅ‚aÅ› zmienne, typy danych, operatory, warunki, pÄ™tle i wszystko zwiÄ…zane z tekstem w Javie. To solidny fundament, na ktÃ³rym bÄ™dziesz budowaÄ‡ caÅ‚Ä… resztÄ™ swojej wiedzy o Javie.*

*W nastÄ™pnej sekcji zagÅ‚Ä™bimy siÄ™ w klasy i struktury danych - enumy, kolekcje, Optional i rekordy. To bÄ™dzie kolejny krok w Twojej podrÃ³Å¼y do mistrzostwa w Javie!*

---

*ğŸ’¡ PamiÄ™taj: Podstawy to fundament. Im lepiej je znasz, tym Å‚atwiej bÄ™dzie Ci zrozumieÄ‡ zaawansowane koncepty!*

