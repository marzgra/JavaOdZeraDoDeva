
# I. Podstawy Javy i środowiska uruchomieniowego

## 1. Zmienne, czyli szufladki na dane (w tym var — czy warto?)

*Cześć! Siadaj wygodnie z kawą, bo dziś rozmawiamy o zmiennych w Javie. To jeden z tych fundamentalnych tematów, które na początku mogą wydawać się oczywiste, ale kryją w sobie więcej niuansów, niż mogłoby się wydawać. Obiecuję Ci, że po tym rozdziale będziesz wiedzieć nie tylko jak deklarować zmienne, ale też dlaczego Java jest tak rygorystyczna w tej kwestii!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest zmienna?

Wyobraź sobie, że Twój kod to wielka szafa z szufladkami. Każda szufladka ma swoją etykietkę (nazwę zmiennej) i może przechowywać określony typ rzeczy (typ danych). Kiedy chcesz coś schować lub znaleźć, patrzysz na etykietkę i wiesz, czego się spodziewać.

W Javie zmienna to po prostu nazwane miejsce w pamięci, gdzie możesz przechować dane. Ale uwaga - Java jest bardzo pedantyczna! Musisz z góry powiedzieć, jakiego typu dane będziesz tam trzymać, i nie możesz tego zmienić w trakcie działania programu.

```java
// Deklaracja zmiennej - mówisz Javie: "Przygotuj mi szufladkę na liczbę całkowitą"
int wiek;

// Inicjalizacja - wkładasz coś do szufladki
wiek = 25;

// Możesz też zrobić to jednocześnie
int wzrost = 165;
String imie = "Anna";
boolean czyProgramistka = true;
```

#### Dlaczego to ważne?

Zmienne to podstawa każdego programu. Zmienne nadają nazwę Twoim danym i sprawiają, że kod staje się czytelny i zrozumiały.

Dodatkowo, Java sprawdza w czasie kompilacji, czy używasz zmiennych poprawnie. To znaczy, że jeśli spróbujesz przypisać tekst do zmiennej liczbowej, kompilator Cię powstrzyma (tak na prawdę to najczęściej już IDE wykryje tę nieprawidłowość). Choć może wydawać się to uciążliwe, w rzeczywistości chroni Cię przed wieloma błędami!

#### Jak to działa w praktyce?

Zobaczmy różne sposoby deklarowania zmiennych:

```java
public class ZmienneExample {
    // Zmienne instancji/obietu (pola klasy) - dostępne w całej klasie
    private String nazwisko = "Kowalska";
    private int rokUrodzenia;

    // Zmienne klasy/statyczne - dostęp bez tworzenia instancji (np. Math.PI)
    public static final String START_VALUE = "Moja stała";
    
    public void metodaExample() {
        // Zmienne lokalne - dostępne tylko w tej metodzie
        int aktualnyRok = 2024;
        int wiek = aktualnyRok - rokUrodzenia;
        
        // Różne typy zmiennych
        double pensja = 8500.50;
        char pierwszaLitera = 'A';
        boolean czyZatrudniona = true;
        
        // Stałe - wartości, które się nie zmieniają - słowo kluczowe final
        final double PI = 3.14159;
        final String NAZWA_FIRMY = "TechCorp";
        
        System.out.println("Wiek: " + wiek);
        System.out.println("Pensja: " + pensja);
    }
}
```

#### A co z tym słynnym `var`?

Od Javy 10 mamy nowe słowo kluczowe `var`, które pozwala kompilatorowi samemu wydedukować typ zmiennej. To jak powiedzenie: "Java, sama się domyśl, co tu powinno być!".
Niby fajna sprawa, ale czasami może utrudnić czytelność kodu, gdy wynik metody jest przypisany do zmiennej var, a nazwa ani metody ani zmiennej nie wskazuje jednoznacznie na typ.

```java
// Zamiast pisać:
String imie = "Katarzyna";
List<String> listaImion = new ArrayList<String>();

// Możesz napisać:
var imie = "Katarzyna";  // Java wie, że to String
var listaImion = new ArrayList<String>();  // Java wie, że to List<String>

// Ale uwaga! To nie zadziała:
var cos;  // Błąd! Java nie wie, jakiego typu ma być 'cos'
var nic = null;  // Błąd! Nie można wydedukować typu z null
var result = getCalculationResult(a, b); // co tu się kryje? dowiesz się dopiero sprawdzając sygnaturę metody ¯\_(ツ)_/¯
```

#### 💡 Wskazówki dla Juniorek

- **Nazywaj zmienne opisowo**: `wiek` zamiast `w`, `nazwiskoUzytkownika` zamiast `nu`
- **Używaj konwencji camelCase**: `pierwszeImie`, `dataUrodzenia`, `czyAktywny`
- **Stałe pisz WIELKIMI_LITERAMI**: `MAX_ROZMIAR`, `DOMYSLNA_WARTOSC`
- **Inicjalizuj zmienne**: Nie zostawiaj zmiennych bez wartości, jeśli nie musisz
- **`var` używaj ostrożnie**: Tylko wtedy, gdy typ jest oczywisty z kontekstu

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz klasę `Osoba` z polami opisującymi osobę (imię, nazwisko, wiek, miasto). Użyj odpowiednich typów danych.

```java
public class Osoba {
    // Uzupełnij pola klasy
    
    public void przedstawSie() {
        // Wypisz informacje o osobie
    }
}
```

**Zadanie 2:** Napisz metodę, która obliczy BMI na podstawie wzrostu i wagi. Użyj zmiennych lokalnych do przechowania wyników pośrednich.

**Zadanie 3:** Eksperymentuj z `var`. Stwórz kilka zmiennych używając `var` i sprawdź, jakie typy Java im przypisze. Spróbuj też sytuacji, gdzie `var` nie zadziała.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między deklaracją a inicjalizacją zmiennej?
2. Dlaczego nie można zmienić typu zmiennej po jej deklaracji?
3. Kiedy warto używać `var`, a kiedy lepiej jawnie określić typ?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Zmienne w Javie to znacznie więcej niż tylko "szufladki na dane". To fundamentalny element systemu typów Javy, który wpływa na bezpieczeństwo, wydajność i czytelność kodu. Przyjrzyjmy się temu z perspektywy architektury języka.

Java implementuje statyczny system typów z silnym typowaniem. Oznacza to, że każda zmienna ma określony typ w czasie kompilacji, a kompilator sprawdza zgodność typów. To podejście eliminuje całą klasę błędów runtime'owych związanych z nieprawidłowym użyciem typów.

```java
public class ZaawansowaneZmienne {
    // Zmienne instancji vs zmienne klasowe
    private static final String WERSJA = "1.0";  // zmienna klasowa
    private String nazwa;  // zmienna instancji
    
    // Różne poziomy dostępu
    public String publicznaZmienna;
    protected String chronionaZmienna;
    String pakietowaZmienna;  // package-private
    private String prywatnaZmienna;
    
    public void demonstracjaZasiegow() {
        // Zmienne lokalne przesłaniają pola klasy
        String nazwa = "lokalna";  // przesłania pole 'nazwa'
        System.out.println(nazwa);  // wypisze "lokalna"
        System.out.println(this.nazwa);  // wypisze wartość pola
        
        // Zasięg zmiennych w blokach
        if (true) {
            int lokalnaWBloku = 42;
            // lokalnaWBloku jest dostępna tylko w tym bloku
        }
        // lokalnaWBloku nie jest już dostępna
        
        // Zmienne w pętlach
        for (int i = 0; i < 10; i++) {
            // 'i' jest dostępne tylko w tej pętli
        }
        // 'i' nie jest już dostępne
    }
}
```

#### Pułapki i niuanse

##### Problem z `var` i czytelność kodu

Chociaż `var` może uprościć kod, może też go zaciemnić. Rozważmy przykłady:

```java
// Dobry przykład użycia var - typ jest oczywisty
var lista = new ArrayList<String>();
var mapa = new HashMap<String, Integer>();
var plik = new File("dane.txt");

// Problematyczny przykład - typ nie jest oczywisty
var wynik = obliczCosTrudnego();  // Jaki typ zwraca ta metoda?
var dane = pobierzDane();  // Co to za dane?

// Szczególnie problematyczne z metodami generycznymi
var stream = lista.stream()
    .filter(s -> s.length() > 5)
    .map(String::toUpperCase);  // Jaki to typ? Stream<String>? Ale nie jest to oczywiste
```

##### Wpływ na refaktoryzację

`var` może utrudnić refaktoryzację kodu:

```java
// Przed refaktoryzacją
var lista = pobierzListeStringow();  // zwraca List<String>

// Po zmianie metody na zwracanie Set<String>
var lista = pobierzListeStringow();  // teraz zwraca Set<String>
// Kod dalej się kompiluje, ale semantyka się zmieniła!
```

##### Wydajność i optymalizacje

Kompilator Java wykonuje wiele optymalizacji na podstawie informacji o typach:

```java
public class OptymalizacjeZmiennych {
    // Zmienne final mogą być optymalizowane
    private final int STALA = 42;
    
    // Kompilator może wstawić wartość bezpośrednio
    public int pobierzStala() {
        return STALA;  // Może być zastąpione przez 'return 42;'
    }
    
    // Zmienne lokalne final również mogą zostać zoptymalizowane
    public void metoda() {
        final int lokalnaStala = 100;
        // Kompilator wie, że ta wartość się nie zmieni
        for (int i = 0; i < lokalnaStala; i++) {
            // Optymalizacje pętli
        }
    }
}
```

#### Wzorce i best practices

##### Wzorzec Immutable Objects

**Niemutowalny obiekt w Javie** (ang. _immutable object_) to taki obiekt, którego stan (wartości pól) **nie może zostać zmieniony po jego utworzeniu**. Oznacza to, że **wszystkie pola są ustawiane raz – w konstruktorze – i nie mogą być później zmodyfikowane**.

### Techniczna definicja niemutowalnego obiektu w Javie:

Obiekt jest uznawany za niemutowalny, jeśli spełnia wszystkie poniższe warunki:
1. **Klasa jest oznaczona jako `final`**, aby nie można było jej rozszerzyć i nadpisać jej zachowania.
2. **Wszystkie pola są `private` i `final`**, czyli przypisywane tylko raz.
3. **Nie zapewnia setterów**, czyli metod umożliwiających zmianę stanu obiektu po jego utworzeniu.
4. **Nie udostępnia bezpośredniego dostępu do pól referencyjnych**, zwłaszcza modyfikowalnych (np. kolekcji), chyba że poprzez defensywną kopię (_defensive copy_).
5. **Konstruktor inicjalizuje wszystkie pola obiektu**, a ich wartości nie mogą być później zmienione. 
6. 

```java
public final class ImmutablePerson {
    private final String imie;
    private final String nazwisko;
    private final int wiek;
    private final Date dataUrodzenia;
    
    public ImmutablePerson(String imie, String nazwisko, int wiek, Date dataUrodzenia) {
        this.imie = Objects.requireNonNull(imie);
        this.nazwisko = Objects.requireNonNull(nazwisko);
        this.wiek = wiek;
        this.dataUrodzenia = dataUrodzenia;
    }
    
    // Tylko gettery, brak setterów
    public String getImie() { return imie; }
    public String getNazwisko() { return nazwisko; }
    public int getWiek() { return wiek; }
    public Date getDataUrodzenia() { return new Date(dataUrodzenia.getTime()); } // kopia defensywna
    
    
    // Metody zwracające nowe instancje zamiast modyfikacji
    public ImmutablePerson withWiek(int nowyWiek) {
        return new ImmutablePerson(this.imie, this.nazwisko, nowyWiek);
    }
}
```

##### Wzorzec Builder z var

```java
public class PersonBuilder {
    private String imie;
    private String nazwisko;
    private int wiek;
    
    public PersonBuilder imie(String imie) {
        this.imie = imie;
        return this;
    }
    
    public PersonBuilder nazwisko(String nazwisko) {
        this.nazwisko = nazwisko;
        return this;
    }
    
    public PersonBuilder wiek(int wiek) {
        this.wiek = wiek;
        return this;
    }
    
    public ImmutablePerson build() {
        return new ImmutablePerson(imie, nazwisko, wiek);
    }
}

// Użycie z var
var osoba = new PersonBuilder()
    .imie("Anna")
    .nazwisko("Kowalska")
    .wiek(30)
    .build();
```

#### 🔧 Zadania dla Seniorek

##### Zadanie Zaawansowane 1: Wyciek stanu przez referencję mutowalną (`Date`)

**🧠 Kontekst**

Poniżej znajdziesz dwie wersje klasy `Spotkanie`. Obie przechowują datę spotkania, ale tylko jedna robi to poprawnie. Twoim zadaniem będzie:
	1. Wskazać, **która wersja jest podatna na wyciek stanu**.
	2. **Wyjaśnić, na czym polega problem** i **jakie ma konsekwencje**.
	3. Zaproponować poprawkę lub lepszą konstrukcję.
    

**📄 Wersja A **

```java
public class Spotkanie {
	private final Date data;
	
	public Spotkanie(Date data) {
		this.data = data;     
	}  
	    
	public Date getData() {
		return data;     
	} 
}
```

 **📄 Wersja B **

```java
public class Spotkanie {     
	private final Date data;      
	
	public Spotkanie(Date data) {         
		this.data = new Date(data.getTime());   
	}      
	
	public Date getData() {         
		return new Date(data.getTime());   
	}
}
```


##### Zadanie Zaawansowane 2: Niemutowalność i kopia defensywna
**Cel:** Zrozumienie idei _immutable objects_ i defensywnego kopiowania.
Masz klasę `ImmutableSpotkanie`, która przechowuje datę spotkania (`java.util.Date`).
- Zaimplementuj klasę spełniającą wszystkie warunki niemutowalności.
- Upewnij się, że `getData()` zwraca _defensywną kopię_.


#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak wpływa użycie `var` na proces kompilacji i czy ma jakikolwiek wpływ na wydajność runtime?
2. Jakie są implikacje używania zmiennych final w kontekście optymalizacji JVM?
3. Jak zmienne lokalne są przechowywane w pamięci i dlaczego nie mogą być dostępne poza swoim zasięgiem?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public class Osoba {
    private String imie;
    private String nazwisko;
    private int wiek;
    private String miasto;
    
    public Osoba(String imie, String nazwisko, int wiek, String miasto) {
        this.imie = imie;
        this.nazwisko = nazwisko;
        this.wiek = wiek;
        this.miasto = miasto;
    }
    
    public void przedstawSie() {
        System.out.println("Cześć! Jestem " + imie + " " + nazwisko + 
                          ", mam " + wiek + " lat i mieszkam w " + miasto + ".");
    }
}
```

**Zadanie 2:**
```java
public double obliczBMI(double wzrost, double waga) {
    double wzrostWMetrach = wzrost / 100.0;  // konwersja cm na m
    double bmi = waga / (wzrostWMetrach * wzrostWMetrach);
    return Math.round(bmi * 100.0) / 100.0;  // zaokrąglenie do 2 miejsc
}
```

**Zadanie 3:**
```java
var tekst = "Hello";  // String
var liczba = 42;  // int
var lista = new ArrayList<String>();  // ArrayList<String>
var mapa = Map.of("klucz", "wartość");  // Map<String, String>

// Te nie zadziałają:
// var nic;  // Błąd kompilacji
// var nullValue = null;  // Błąd kompilacji
```

**Pytania kontrolne:**
1. **Deklaracja** to określenie nazwy i typu zmiennej (`int wiek;`), **inicjalizacja** to przypisanie pierwszej wartości (`wiek = 25;`).
2. Java ma statyczny system typów - typ jest sprawdzany w czasie kompilacji i nie może się zmienić, co zapewnia bezpieczeństwo typów.
3. `var` warto używać, gdy typ jest oczywisty z kontekstu. Unikaj, gdy typ nie jest jasny lub gdy jawne określenie typu poprawia czytelność.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
Wersja A jest podatna na wyciek stanu.**
W wersji A obiekt `Date` jest przypisywany bezpośrednio do prywatnego pola `data` i jest zwracany przez getter bez żadnej ochrony. `Date` to klasa mutowalna — to znaczy, że stan obiektu `Date` można zmieniać po jego utworzeniu (np. zmieniając godzinę, dzień itp.).

**Konsekwencje**:
- Klient, który otrzyma referencję do obiektu `Date` przez metodę `getData()`, może zmodyfikować ten obiekt.
- Modyfikacja zwróconej daty skutkuje zmianą stanu obiektu `Spotkanie` _od zewnątrz_, czyli dochodzi do wycieku stanu (state leak).
- To narusza enkapsulację i niemutowalność klasy, co może prowadzić do nieprzewidywalnych błędów, zwłaszcza w kontekście wielowątkowości czy logiki biznesowej, która zakłada, że data spotkania się nie zmieni.

**Propozycja poprawki lub lepsza konstrukcja**
Wersja B stosuje tzw. **defensywną kopię** — zamiast przechowywać i udostępniać oryginalny obiekt `Date`, tworzy jego nową instancję kopiując czas z oryginału.
- Konstruktor tworzy nową kopię `Date`, więc nawet jeśli obiekt przekazany do konstruktora zostanie zmieniony po utworzeniu `Spotkanie`, wewnętrzny stan klasy pozostanie niezmieniony.
- Getter zwraca nową kopię `Date`, więc klient nie może zmienić wewnętrznego stanu `Spotkanie` przez manipulację zwróconym obiektem.

**Alternatywne rozwiązanie (bardziej nowoczesne i odporne):**
- Użyć klas niemutowalnych do reprezentacji dat, np. `java.time.LocalDateTime` lub `java.time.Instant` z pakietu `java.time` (Java 8+).
- Klasy z `java.time` są niezmiennicze (immutable), więc nie wymagają defensywnych kopii i eliminują ryzyko wycieku stanu.

**Zadanie Zaawansowane 2:**
```java
import java.util.Date;

public final class ImmutableSpotkanie {
    private final Date data; // lub po prostu użycie LocalDate

    public ImmutableSpotkanie(Date data) {
        if (data == null) {
            throw new IllegalArgumentException("Data spotkania nie może być nullem");
        }
        // defensywna kopia w konstruktorze
        this.data = new Date(data.getTime());
    }

    // zwraca defensywną kopię, by zapobiec wyciekowi stanu
    public Date getData() {
        return new Date(this.data.getTime());
    }

    // brak setterów – klasa jest niemutowalna
}
```

**Pytania kontrolne:**
1. `var` to tylko syntactic sugar - kompilator zastępuje go rzeczywistym typem, więc nie ma wpływu na runtime ani wydajność.
2. Zmienne final mogą być optymalizowane przez kompilator (inlining) i JVM (escape analysis, constant folding).
3. Zmienne lokalne są przechowywane na stosie (stack) w ramce metody. Gdy metoda kończy działanie, ramka jest usuwana, dlatego zmienne lokalne nie są dostępne poza zasięgiem.

---

#### 📚 Co dalej?

*Świetnie! Mam nadzieję, że ten rozdział był dla Ciebie pomocny. Zmienne to fundament, na którym budujesz całą resztę swojej wiedzy o Javie. W następnym rozdziale porozmawiamy o typach prymitywnych vs referencyjnych - czyli o tym, jak Java przechowuje różne rodzaje danych i dlaczego czasami "kopiuj-wklej" działa inaczej niż byśmy chciały!*

---

*💡 Pamiętaj: Nie ma głupich pytań, są tylko nieodpowiedziane! Jeśli coś nie jest jasne, wróć do tego rozdziału lub poszukaj dodatkowych przykładów w internecie.*



## 2. Typy prymitywne vs referencyjne (czyli „zrób mi kopiuj-wklej... albo i nie")

*Cześć ponownie! Dziś mamy przed sobą jeden z tych tematów, które na początku wydają się proste, ale potem okazuje się, że kryją w sobie prawdziwe miny. Typy prymitywne vs referencyjne to podstawa zrozumienia, jak Java zarządza pamięcią i dlaczego czasami Twój kod zachowuje się inaczej niż oczekujesz. Przygotuj się na kilka "aha!" momentów!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

W Javie mamy dwa główne sposoby przechowywania danych:

1. **Typy prymitywne** - to jak małe pudełeczka, które przechowują konkretną wartość bezpośrednio
2. **Typy referencyjne** - to jak karteczki z adresem, gdzie prawdziwe dane są przechowywane gdzie indziej

Wyobraź sobie, że masz dwie szuflady:
- W pierwszej trzymasz bezpośrednio monety (typy prymitywne)
- W drugiej trzymasz karteczki z adresami skarbców, gdzie leżą prawdziwe skarby (typy referencyjne)

```java
// Typy prymitywne - wartość jest przechowywana bezpośrednio
int wiek = 25;           // pudełko zawiera liczbę 25
double wzrost = 165.5;   // pudełko zawiera liczbę 165.5
boolean czyAktywna = true; // pudełko zawiera wartość true
char pierwszaLitera = 'A'; // pudełko zawiera znak 'A'

// Typy referencyjne - zmienna zawiera "adres" do obiektu
String imie = "Anna";    // zmienna zawiera adres do obiektu String
List<String> lista = new ArrayList<>(); // adres do obiektu ArrayList
Person osoba = new Person(); // adres do obiektu Person
```

#### Dlaczego to ważne?

Ta różnica ma ogromne znaczenie dla tego, jak Twój kod się zachowuje, szczególnie gdy kopiujesz zmienne lub przekazujesz je do metod. To jak różnica między kopiowaniem monety (masz dwie identyczne monety) a kopiowaniem adresu (masz dwie karteczki wskazujące na ten sam skarb).

```java
// Kopiowanie typów prymitywnych
int a = 10;
int b = a;  // b dostaje kopię wartości z a
a = 20;     // zmiana a nie wpływa na b
System.out.println(b); // wypisze 10

// Kopiowanie typów referencyjnych
List<String> lista1 = new ArrayList<>();
lista1.add("Java");
List<String> lista2 = lista1;  // lista2 dostaje kopię ADRESU, nie zawartości!
lista1.add("Python");
System.out.println(lista2.size()); // wypisze 2! Obie zmienne wskazują na tę samą listę
```

#### Jak to działa w praktyce?

Oto wszystkie typy prymitywne w Javie:

```java
public class TypyPrymitywne {
    // Liczby całkowite
    byte maleLiczby = 127;        // -128 do 127
    short sredneLiczby = 32000;   // -32,768 do 32,767
    int normaleLiczby = 2000000;  // -2^31 do 2^31-1
    long duzeLiczby = 9000000000L; // -2^63 do 2^63-1 (uwaga na 'L'!)
    
    // Liczby zmiennoprzecinkowe
    float precyzja = 3.14f;       // 32-bitowa (uwaga na 'f'!)
    double podwojnaPrecyzja = 3.14159; // 64-bitowa (domyślna dla liczb z kropką)
    
    // Inne
    char znak = 'A';              // pojedynczy znak Unicode
    boolean prawdaFalsz = true;   // true lub false
}
```

A teraz przykłady typów referencyjnych:

```java
public class TypyReferencyjne {
    // Wszystkie klasy to typy referencyjne
    String tekst = "Hello World";
    StringBuilder builder = new StringBuilder();
    List<Integer> liczby = new ArrayList<>();
    Map<String, String> mapa = new HashMap<>();
    
    // Twoje własne klasy też
    Person osoba = new Person();
    Car samochod = new Car();
    
    // Tablice też są typami referencyjnymi!
    int[] tablicaLiczb = {1, 2, 3, 4, 5};
    String[] tablicaStringow = {"Java", "Python", "JavaScript"};
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Przekazywanie do metod**

```java
public class PrzekazywaniePrametrow {
    public static void zmienPrymityw(int liczba) {
        liczba = 100;  // zmienia tylko lokalną kopię
    }
    
    public static void zmienObiekt(List<String> lista) {
        lista.add("Nowy element");  // zmienia oryginalną listę!
    }
    
    public static void zmienReferencje(List<String> lista) {
        lista = new ArrayList<>();  // tworzy nową listę, ale nie wpływa na oryginalną
        lista.add("To nie wpłynie na oryginał");
    }
    
    public static void main(String[] args) {
        int x = 10;
        zmienPrymityw(x);
        System.out.println(x); // wypisze 10 (bez zmian)
        
        List<String> mojaLista = new ArrayList<>();
        mojaLista.add("Pierwszy");
        zmienObiekt(mojaLista);
        System.out.println(mojaLista.size()); // wypisze 2
        
        zmienReferencje(mojaLista);
        System.out.println(mojaLista.size()); // nadal 2
    }
}
```

**Pułapka 2: Porównywanie**

```java
// Typy prymitywne - porównujemy wartości
int a = 5;
int b = 5;
System.out.println(a == b); // true

// Typy referencyjne - porównujemy adresy!
String s1 = new String("Hello");
String s2 = new String("Hello");
System.out.println(s1 == s2);     // false! (różne obiekty)
System.out.println(s1.equals(s2)); // true (ta sama zawartość)

// Wyjątek: String literals
String s3 = "Hello";
String s4 = "Hello";
System.out.println(s3 == s4); // true (Java optymalizuje i używa tego samego obiektu)
```

#### 💡 Wskazówki dla Juniorek

- **Używaj `equals()` do porównywania obiektów**, nie `==`
- **Pamiętaj o `null`** - typy prymitywne nie mogą być null, referencyjne mogą
- **Uważaj na modyfikacje list i map** przekazanych do metod
- **Inicjalizuj obiekty** przed użyciem (`new ArrayList<>()`, nie tylko deklaracja)
- **Tablice to też obiekty** - zachowują się jak typy referencyjne

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz metodę, która przyjmuje listę liczb i dodaje do niej nową liczbę. Sprawdź, czy oryginalna lista się zmienia.

```java
public static void dodajLiczbe(List<Integer> lista, int liczba) {
    // Twoja implementacja
}
```

**Zadanie 2:** Stwórz klasę `Punkt` z polami x i y. Napisz metodę, która przyjmuje punkt i zmienia jego współrzędne. Sprawdź, czy oryginalny punkt się zmienia.

**Zadanie 3:** Eksperymentuj z porównywaniem Stringów. Stwórz Stringi na różne sposoby i sprawdź, kiedy `==` zwraca true, a kiedy false.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Dlaczego zmiana listy w metodzie wpływa na oryginalną listę, ale zmiana int nie wpływa na oryginalną zmienną?
2. Jaka jest różnica między `==` a `equals()` dla obiektów?
3. Czy tablica int[] to typ prymitywny czy referencyjny?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Różnica między typami prymitywnymi a referencyjnymi w Javie wynika z fundamentalnej architektury JVM i sposobu zarządzania pamięcią. Ta decyzja projektowa ma daleko idące konsekwencje dla wydajności, bezpieczeństwa i semantyki języka.

##### Architektura pamięci JVM

```java
public class ArchitekturapamiEci {
    // Zmienne statyczne - w Metaspace (Java 8+) lub Method Area
    private static final String STALA = "Wartość stała";
    
    // Pola instancji - w Heap
    private int poleInstancji = 42;
    private List<String> listaInstancji = new ArrayList<>();
    
    public void demonstracjaStosui() {
        // Zmienne lokalne prymitywne - na Stack
        int lokalnaLiczba = 100;
        boolean lokalnaFlaga = true;
        
        // Zmienne lokalne referencyjne - referencja na Stack, obiekt w Heap
        String lokalnyString = "Hello";  // referencja na Stack, obiekt w Heap
        List<Integer> lokalnaLista = new ArrayList<>();  // referencja na Stack, obiekt w Heap
        
        // Parametry metod też są na Stack
        metodaZParametrami(lokalnaLiczba, lokalnyString);
    }
    
    private void metodaZParametrami(int parametrPrymitywny, String parametrReferencyjny) {
        // Oba parametry są na Stack tej metody
        // parametrPrymitywny to kopia wartości
        // parametrReferencyjny to kopia referencji (adresu)
    }
}
```

##### Implikacje wydajnościowe

Typy prymitywne są znacznie szybsze w dostępie i zajmują mniej pamięci:

```java
public class WydajnoscTypow {
    // Porównanie zużycia pamięci
    private int[] prymitywne = new int[1000000];        // ~4MB
    private Integer[] opakowane = new Integer[1000000]; // ~16MB + overhead obiektów
    
    // Benchmark dostępu
    public long sumaPrymitywnych(int[] tablica) {
        long suma = 0;
        for (int i = 0; i < tablica.length; i++) {
            suma += tablica[i];  // bezpośredni dostęp do wartości
        }
        return suma;
    }
    
    public long sumaOpakowanych(Integer[] tablica) {
        long suma = 0;
        for (int i = 0; i < tablica.length; i++) {
            suma += tablica[i];  // wymaga dereferencji + unboxing
        }
        return suma;
    }
}
```

##### Semantyka kopiowania i przekazywania

Java zawsze przekazuje parametry przez wartość, ale interpretacja "wartości" różni się:

```java
public class SemantykaPrzekazywania {
    public static void modyfikujPrymityw(int x) {
        x = 999;  // modyfikuje lokalną kopię
    }
    
    public static void modyfikujObiekt(StringBuilder sb) {
        sb.append(" - zmodyfikowany");  // modyfikuje obiekt wskazywany przez kopię referencji
    }
    
    public static void zastapObiekt(StringBuilder sb) {
        sb = new StringBuilder("Nowy obiekt");  // zmienia lokalną kopię referencji
    }
    
    public static void demonstracja() {
        int liczba = 42;
        modyfikujPrymityw(liczba);
        System.out.println(liczba);  // 42 - bez zmian
        
        StringBuilder builder = new StringBuilder("Oryginalny");
        modyfikujObiekt(builder);
        System.out.println(builder);  // "Oryginalny - zmodyfikowany"
        
        zastapObiekt(builder);
        System.out.println(builder);  // "Oryginalny - zmodyfikowany" - bez zmian
    }
}
```

#### Pułapki i niuanse

##### Problem z autoboxing/unboxing

```java
public class PulapkiAutoboxing {
    // Pułapka 1: Porównywanie Integer
    public void porownywaniePulapka() {
        Integer a = 127;
        Integer b = 127;
        System.out.println(a == b);  // true (cache dla -128 do 127)
        
        Integer c = 128;
        Integer d = 128;
        System.out.println(c == d);  // false! (poza cache)
        
        // Bezpieczne porównywanie
        System.out.println(Objects.equals(c, d));  // true
    }
    
    // Pułapka 2: NullPointerException przy unboxing
    public void nullPointerPulapka() {
        Integer nullInteger = null;
        int prymityw = nullInteger;  // NPE! Nie można unboxować null
    }
    
    // Pułapka 3: Wydajność w pętlach
    public void wydajnoscPulapka() {
        Integer suma = 0;  // Źle! Każda iteracja tworzy nowy obiekt
        for (int i = 0; i < 1000000; i++) {
            suma += i;  // boxing/unboxing w każdej iteracji
        }
        
        int sumaPoprawnie = 0;  // Dobrze!
        for (int i = 0; i < 1000000; i++) {
            sumaPoprawnie += i;  // tylko prymitywy
        }
    }
}
```

##### Immutability i aliasing

```java
public class ImmutabilityAliasing {
    // String jest immutable
    public void stringImmutability() {
        String s1 = "Hello";
        String s2 = s1;
        s1 = s1 + " World";  // tworzy NOWY obiekt, s2 pozostaje niezmienione
        System.out.println(s2);  // "Hello"
    }
    
    // Ale uwaga na mutable obiekty!
    public void mutableAliasing() {
        List<String> lista1 = new ArrayList<>();
        lista1.add("Element");
        
        List<String> lista2 = lista1;  // aliasing!
        lista2.add("Drugi element");
        
        System.out.println(lista1.size());  // 2! Obie zmienne wskazują na tę samą listę
    }
    
    // Defensive copying
    public List<String> bezpiecznaKopia(List<String> oryginalna) {
        return new ArrayList<>(oryginalna);  // tworzy nową listę z tą samą zawartością
    }
}
```

#### Wzorce i best practices

##### Wzorzec Value Object

```java
public final class Money {
    private final BigDecimal amount;
    private final Currency currency;
    
    public Money(BigDecimal amount, Currency currency) {
        this.amount = Objects.requireNonNull(amount);
        this.currency = Objects.requireNonNull(currency);
    }
    
    // Immutable - metody zwracają nowe instancje
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot add different currencies");
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }
    
    public Money multiply(BigDecimal factor) {
        return new Money(this.amount.multiply(factor), this.currency);
    }
    
    // Proper equals and hashCode
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Money)) return false;
        Money money = (Money) obj;
        return Objects.equals(amount, money.amount) && 
               Objects.equals(currency, money.currency);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(amount, currency);
    }
}
```

##### Wzorzec Builder z defensive copying

```java
public final class ImmutablePerson {
    private final String name;
    private final List<String> hobbies;
    private final Map<String, String> attributes;
    
    private ImmutablePerson(Builder builder) {
        this.name = Objects.requireNonNull(builder.name);
        // Defensive copying dla mutable kolekcji
        this.hobbies = List.copyOf(builder.hobbies);
        this.attributes = Map.copyOf(builder.attributes);
    }
    
    public List<String> getHobbies() {
        return hobbies;  // już immutable, bezpieczne
    }
    
    public Map<String, String> getAttributes() {
        return attributes;  // już immutable, bezpieczne
    }
    
    public static class Builder {
        private String name;
        private List<String> hobbies = new ArrayList<>();
        private Map<String, String> attributes = new HashMap<>();
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder addHobby(String hobby) {
            this.hobbies.add(hobby);
            return this;
        }
        
        public Builder addAttribute(String key, String value) {
            this.attributes.put(key, value);
            return this;
        }
        
        public ImmutablePerson build() {
            return new ImmutablePerson(this);
        }
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj klasę `DeepCopyUtil`, która potrafi wykonać głęboką kopię dowolnego obiektu używając refleksji. Uwzględnij obsługę kolekcji, tablic i obiektów zagnieżdżonych.

**Zadanie Zaawansowane 2:** Stwórz benchmark porównujący wydajność operacji na typach prymitywnych vs opakowanych w różnych scenariuszach (pętle, kolekcje, przekazywanie parametrów).

**Zadanie Zaawansowane 3:** Zaprojektuj system cache'owania obiektów, który optymalizuje zużycie pamięci przez reużywanie immutable obiektów (podobnie do String pool).

#### ❓ Pytania Kontrolne - Poziom Senior

1. Dlaczego Java nie pozwala na przeciążanie operatorów dla typów referencyjnych (poza String)?
2. Jak wpływa na wydajność częste boxing/unboxing w kolekcjach generycznych?
3. Jakie są implikacje bezpieczeństwa związane z przekazywaniem mutable obiektów między wątkami?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static void dodajLiczbe(List<Integer> lista, int liczba) {
    lista.add(liczba);  // modyfikuje oryginalną listę
}

// Test:
List<Integer> mojaLista = new ArrayList<>();
mojaLista.add(1);
dodajLiczbe(mojaLista, 2);
System.out.println(mojaLista.size()); // wypisze 2
```

**Zadanie 2:**
```java
public class Punkt {
    private int x, y;
    
    public Punkt(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public void setX(int x) { this.x = x; }
    public void setY(int y) { this.y = y; }
    public int getX() { return x; }
    public int getY() { return y; }
}

public static void zmienPunkt(Punkt p) {
    p.setX(100);  // zmienia oryginalny punkt
    p.setY(200);
}

// Test:
Punkt punkt = new Punkt(10, 20);
zmienPunkt(punkt);
System.out.println(punkt.getX()); // wypisze 100
```

**Zadanie 3:**
```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");
String s4 = new String("Hello");

System.out.println(s1 == s2);     // true (string pool)
System.out.println(s1 == s3);     // false (różne obiekty)
System.out.println(s3 == s4);     // false (różne obiekty)
System.out.println(s1.equals(s3)); // true (ta sama zawartość)
```

**Pytania kontrolne:**
1. Lista to obiekt (typ referencyjny) - metoda dostaje kopię adresu, więc może modyfikować obiekt. Int to typ prymitywny - metoda dostaje kopię wartości.
2. `==` porównuje adresy obiektów, `equals()` porównuje zawartość obiektów.
3. Tablica to typ referencyjny - nawet tablica prymitywów jest obiektem.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class DeepCopyUtil {
    public static <T> T deepCopy(T original) throws Exception {
        if (original == null) return null;
        
        Class<?> clazz = original.getClass();
        
        // Obsługa typów prymitywnych i immutable
        if (clazz.isPrimitive() || isImmutable(clazz)) {
            return original;
        }
        
        // Obsługa tablic
        if (clazz.isArray()) {
            return copyArray(original);
        }
        
        // Obsługa kolekcji
        if (Collection.class.isAssignableFrom(clazz)) {
            return copyCollection(original);
        }
        
        // Obsługa map
        if (Map.class.isAssignableFrom(clazz)) {
            return copyMap(original);
        }
        
        // Obsługa zwykłych obiektów
        return copyObject(original);
    }
    
    private static boolean isImmutable(Class<?> clazz) {
        return clazz == String.class || 
               clazz == Integer.class || 
               clazz == Long.class ||
               // ... inne immutable klasy
               clazz.isEnum();
    }
    
    // Implementacje pomocniczych metod...
}
```

**Zadanie Zaawansowane 2:**
```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class PrimitiveVsBoxedBenchmark {
    
    @Benchmark
    public long sumPrimitiveArray() {
        int[] array = new int[1000];
        long sum = 0;
        for (int i = 0; i < array.length; i++) {
            sum += array[i];
        }
        return sum;
    }
    
    @Benchmark
    public long sumBoxedArray() {
        Integer[] array = new Integer[1000];
        long sum = 0;
        for (int i = 0; i < array.length; i++) {
            sum += array[i];  // unboxing w każdej iteracji
        }
        return sum;
    }
    
    // Wyniki pokazują, że prymitywy są ~10x szybsze
}
```

**Zadanie Zaawansowane 3:**
```java
public class ObjectPool<T> {
    private final Map<T, T> pool = new ConcurrentHashMap<>();
    private final Function<T, T> copyFunction;
    
    public ObjectPool(Function<T, T> copyFunction) {
        this.copyFunction = copyFunction;
    }
    
    public T intern(T object) {
        if (object == null) return null;
        
        return pool.computeIfAbsent(object, copyFunction);
    }
    
    public int size() {
        return pool.size();
    }
    
    public void clear() {
        pool.clear();
    }
}

// Użycie:
ObjectPool<String> stringPool = new ObjectPool<>(String::new);
String interned = stringPool.intern("Hello World");
```

**Pytania kontrolne:**
1. Java nie pozwala na przeciążanie operatorów dla bezpieczeństwa typów i czytelności kodu. String ma specjalne wsparcie w JVM.
2. Boxing/unboxing tworzy nowe obiekty, co zwiększa presję na GC i zmniejsza wydajność, szczególnie w pętlach.
3. Przekazywanie mutable obiektów może prowadzić do race conditions, data races i naruszenia invariantów bez odpowiedniej synchronizacji.

---

#### 📚 Co dalej?

*Świetnie! Teraz rozumiesz jedną z najważniejszych różnic w Javie. Ta wiedza będzie Ci towarzyszyć przez całą karierę programistyczną. W następnym rozdziale porozmawiamy o autoboxing i unboxing - czyli o tym, jak Java automatycznie konwertuje między typami prymitywnymi a ich opakowanymi odpowiednikami. Przygotuj się na kolejne "aha!" momenty!*

---

*💡 Pamiętaj: Zrozumienie różnicy między typami prymitywnymi a referencyjnymi to klucz do pisania wydajnego i bezpiecznego kodu Java!*


## 3. Autoboxing i unboxing — magia (i pułapki)

*Cześć! Dziś porozmawiamy o jednej z tych funkcjonalności Javy, która wydaje się super wygodna, ale może sprawić Ci sporo problemów, jeśli nie zrozumiesz, jak działa pod maską. Autoboxing i unboxing to jak automatyczny tłumacz między typami prymitywnymi a ich "opakowanymi" braćmi. Brzmi świetnie, prawda? No to zobaczmy, gdzie czają się pułapki!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Autoboxing i unboxing to automatyczne konwersje między typami prymitywnymi a ich odpowiednikami w postaci klas (wrapper classes). To jak mieć asystenta, który automatycznie pakuje i rozpakowuje prezenty za Ciebie.

**Autoboxing** = automatyczne "opakowanie" typu prymitywnego w obiekt
**Unboxing** = automatyczne "rozpakowanie" obiektu do typu prymitywnego

```java
// Przed Javą 5 musiałaś robić to ręcznie:
Integer starySposob = new Integer(42);  // ręczne "pakowanie"
int wartoscStary = starySposob.intValue();  // ręczne "rozpakowywanie"

// Od Javy 5 możesz pisać tak:
Integer autobox = 42;        // autoboxing: int → Integer
int autounbox = autobox;     // unboxing: Integer → int
```

Oto wszystkie pary typów:

```java
// Typ prymitywny → Wrapper class
byte    → Byte
short   → Short
int     → Integer
long    → Long
float   → Float
double  → Double
char    → Character
boolean → Boolean

// Przykłady autoboxing
Integer liczba = 100;           // int → Integer
Double pi = 3.14159;           // double → Double
Boolean flaga = true;          // boolean → Boolean
Character litera = 'A';        // char → Character

// Przykłady unboxing
int x = liczba;                // Integer → int
double piValue = pi;           // Double → double
boolean flagValue = flaga;     // Boolean → boolean
char literaValue = litera;     // Character → char
```

#### Dlaczego to ważne?

Autoboxing i unboxing pozwalają Ci używać typów prymitywnych i ich wrapper classes zamiennie w większości sytuacji. To szczególnie przydatne przy pracy z kolekcjami, które mogą przechowywać tylko obiekty, nie prymitywy.

```java
// Bez autoboxing musiałabyś pisać:
List<Integer> liczby = new ArrayList<Integer>();
liczby.add(new Integer(1));
liczby.add(new Integer(2));
liczby.add(new Integer(3));

// Z autoboxing możesz pisać:
List<Integer> liczby = new ArrayList<>();
liczby.add(1);    // autoboxing: int → Integer
liczby.add(2);    // autoboxing: int → Integer
liczby.add(3);    // autoboxing: int → Integer

// I używać w pętlach:
for (int liczba : liczby) {  // unboxing: Integer → int
    System.out.println(liczba);
}
```

#### Jak to działa w praktyce?

**Przykład 1: Kolekcje**

```java
public class AutoboxingWKolekcjach {
    public static void main(String[] args) {
        List<Integer> liczby = new ArrayList<>();
        
        // Autoboxing przy dodawaniu
        liczby.add(10);      // int → Integer
        liczby.add(20);      // int → Integer
        liczby.add(30);      // int → Integer
        
        // Unboxing przy pobieraniu
        int pierwsza = liczby.get(0);  // Integer → int
        
        // Autoboxing/unboxing w operacjach
        int suma = 0;
        for (Integer liczba : liczby) {  // unboxing w każdej iteracji
            suma += liczba;              // unboxing: Integer → int
        }
        
        liczby.add(suma);  // autoboxing: int → Integer
    }
}
```

**Przykład 2: Metody**

```java
public class AutoboxingWMetodach {
    // Metoda przyjmująca wrapper
    public static void wypiszLiczbe(Integer liczba) {
        System.out.println("Liczba: " + liczba);
    }
    
    // Metoda przyjmująca prymityw
    public static void obliczKwadrat(int liczba) {
        System.out.println("Kwadrat: " + (liczba * liczba));
    }
    
    public static void main(String[] args) {
        int prymityw = 5;
        Integer wrapper = 10;
        
        // Autoboxing przy wywołaniu
        wypiszLiczbe(prymityw);    // int → Integer
        
        // Unboxing przy wywołaniu
        obliczKwadrat(wrapper);    // Integer → int
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: NullPointerException**

```java
Integer liczba = null;
int prymityw = liczba;  // BOOM! NullPointerException przy unboxing
```

**Pułapka 2: Porównywanie z ==**

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);  // true (cache dla -128 do 127)

Integer c = 200;
Integer d = 200;
System.out.println(c == d);  // false! (poza cache)

// Bezpieczne porównywanie:
System.out.println(Objects.equals(c, d));  // true
```

**Pułapka 3: Wydajność**

```java
// Źle - tworzy nowy obiekt w każdej iteracji!
Integer suma = 0;
for (int i = 0; i < 1000; i++) {
    suma += i;  // unboxing + boxing w każdej iteracji
}

// Dobrze - używa tylko prymitywów
int suma = 0;
for (int i = 0; i < 1000; i++) {
    suma += i;  // tylko prymitywy, szybko!
}
```

#### 💡 Wskazówki dla Juniorek

- **Sprawdzaj null** przed unboxing wrapper classes
- **Używaj `equals()`** do porównywania wrapper classes, nie `==`
- **Unikaj autoboxing w pętlach** - może być wolne
- **Preferuj prymitywy** w obliczeniach matematycznych
- **Używaj wrapper classes** tylko gdy musisz (kolekcje, null values)

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz metodę, która przyjmuje `List<Integer>` i zwraca sumę wszystkich liczb. Uważaj na potencjalne NullPointerException.

```java
public static int sumujLiczby(List<Integer> liczby) {
    // Twoja implementacja
}
```

**Zadanie 2:** Stwórz metodę, która sprawdza, czy dwie listy Integer zawierają te same wartości (ale mogą być różnymi obiektami).

**Zadanie 3:** Eksperymentuj z cache Integer. Sprawdź, dla jakich wartości `==` zwraca true, a dla jakich false.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Co się stanie, jeśli spróbujesz zrobić unboxing na null?
2. Dlaczego `Integer a = 100; Integer b = 100; a == b` zwraca true, ale dla 200 zwraca false?
3. Kiedy autoboxing może wpłynąć negatywnie na wydajność?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Autoboxing i unboxing to syntactic sugar wprowadzony w Javie 5, który ukrywa przed programistą wywołania metod `valueOf()` i `xxxValue()`. Kompilator automatycznie wstawia te wywołania w odpowiednich miejscach, co ma zarówno zalety, jak i poważne implikacje wydajnościowe.

##### Mechanizm działania na poziomie bytecode

```java
// Kod źródłowy:
Integer x = 42;
int y = x;

// Jest kompilowany do:
Integer x = Integer.valueOf(42);
int y = x.intValue();
```

Przyjrzyjmy się implementacji `Integer.valueOf()`:

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

private static class IntegerCache {
    static final int low = -128;
    static final int high = 127;  // może być zwiększone przez -XX:AutoBoxCacheMax
    static final Integer cache[];
    
    static {
        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);
    }
}
```

##### Implikacje wydajnościowe

**Memory overhead:**

```java
public class MemoryOverhead {
    // Porównanie zużycia pamięci
    private int[] primitives = new int[1_000_000];     // ~4MB
    private Integer[] boxed = new Integer[1_000_000];  // ~16MB + object overhead
    
    // Każdy Integer to:
    // - 12 bytes object header (64-bit JVM z compressed OOPs)
    // - 4 bytes dla int value
    // - padding do 8-byte boundary
    // = 16 bytes vs 4 bytes dla int
}
```

**CPU overhead w pętlach:**

```java
@Benchmark
public class AutoboxingBenchmark {
    private List<Integer> boxedList = IntStream.range(0, 1000)
        .boxed()
        .collect(Collectors.toList());
    
    @Benchmark
    public long sumWithAutoboxing() {
        long sum = 0;
        for (Integer i : boxedList) {  // unboxing w każdej iteracji
            sum += i;                  // unboxing
        }
        return sum;
    }
    
    @Benchmark
    public long sumWithPrimitives() {
        long sum = 0;
        for (int i = 0; i < 1000; i++) {  // tylko prymitywy
            sum += i;
        }
        return sum;
    }
    
    // Wynik: sumWithPrimitives jest ~10x szybsze
}
```

##### Garbage Collection pressure

```java
public class GCPressure {
    // Źle - tworzy miliony obiektów
    public Integer badSum() {
        Integer sum = 0;  // autoboxing
        for (int i = 0; i < 1_000_000; i++) {
            sum += i;  // unboxing + autoboxing w każdej iteracji!
        }
        return sum;
    }
    
    // Dobrze - tylko jeden obiekt na końcu
    public Integer goodSum() {
        int sum = 0;  // prymityw
        for (int i = 0; i < 1_000_000; i++) {
            sum += i;  // tylko prymitywy
        }
        return sum;  // autoboxing tylko raz
    }
}
```

#### Pułapki i niuanse

##### Pułapka z equals() i ==

```java
public class EqualsVsEquals {
    public void demonstrateComparison() {
        // Cache range: -128 do 127
        Integer a1 = 100, a2 = 100;
        System.out.println(a1 == a2);        // true (ten sam obiekt z cache)
        System.out.println(a1.equals(a2));   // true
        
        // Poza cache
        Integer b1 = 200, b2 = 200;
        System.out.println(b1 == b2);        // false (różne obiekty)
        System.out.println(b1.equals(b2));   // true
        
        // Mieszanie z prymitywami
        int c = 200;
        Integer d = 200;
        System.out.println(c == d);          // true (unboxing d do int)
        
        // Pułapka z null
        Integer e = null;
        int f = 200;
        // System.out.println(e == f);       // NullPointerException!
        System.out.println(Objects.equals(e, f));  // false, bezpiecznie
    }
}
```

##### Pułapka z kolekcjami i null

```java
public class CollectionNullTrap {
    public void demonstrateNullTrap() {
        List<Integer> numbers = Arrays.asList(1, 2, null, 4, 5);
        
        // To spowoduje NPE:
        try {
            int sum = numbers.stream()
                .mapToInt(Integer::intValue)  // NPE na null
                .sum();
        } catch (NullPointerException e) {
            System.out.println("NPE przy unboxing null!");
        }
        
        // Bezpieczna wersja:
        int safeSum = numbers.stream()
            .filter(Objects::nonNull)
            .mapToInt(Integer::intValue)
            .sum();
    }
}
```

##### Pułapka z concurrent collections

```java
public class ConcurrentAutoboxingTrap {
    private final Map<String, Integer> counters = new ConcurrentHashMap<>();
    
    // Źle - race condition z autoboxing
    public void badIncrement(String key) {
        Integer current = counters.get(key);  // może być null
        if (current == null) {
            current = 0;
        }
        counters.put(key, current + 1);  // autoboxing, ale nie atomowe!
    }
    
    // Dobrze - atomowa operacja
    public void goodIncrement(String key) {
        counters.merge(key, 1, Integer::sum);
    }
    
    // Jeszcze lepiej - unikamy autoboxing
    private final Map<String, AtomicInteger> atomicCounters = new ConcurrentHashMap<>();
    
    public void bestIncrement(String key) {
        atomicCounters.computeIfAbsent(key, k -> new AtomicInteger(0))
                     .incrementAndGet();
    }
}
```

#### Wzorce i best practices

##### Wzorzec Primitive Specialization

```java
// Zamiast używać generycznych kolekcji z autoboxing
List<Integer> numbers = new ArrayList<>();  // boxing overhead

// Użyj specialized collections
IntList numbers = new IntArrayList();  // Eclipse Collections
TIntList numbers = new TIntArrayList(); // Trove4j

// Lub primitive streams
IntStream.range(0, 1000)
    .filter(i -> i % 2 == 0)
    .sum();  // bez autoboxing!
```

##### Wzorzec Null Object dla wrapper classes

```java
public class SafeInteger {
    private final Integer value;
    
    private SafeInteger(Integer value) {
        this.value = value;
    }
    
    public static SafeInteger of(Integer value) {
        return new SafeInteger(value);
    }
    
    public static SafeInteger empty() {
        return new SafeInteger(null);
    }
    
    public int orElse(int defaultValue) {
        return value != null ? value : defaultValue;
    }
    
    public boolean isPresent() {
        return value != null;
    }
    
    public SafeInteger map(IntUnaryOperator mapper) {
        return value != null ? of(mapper.applyAsInt(value)) : empty();
    }
}
```

##### Performance-aware autoboxing

```java
public class PerformanceAwareAutoboxing {
    // Unikaj autoboxing w hot paths
    public long calculateSum(List<Integer> numbers) {
        // Źle - autoboxing w każdej iteracji
        return numbers.stream()
            .mapToLong(i -> i)  // Integer -> long (przez int)
            .sum();
        
        // Lepiej - explicit unboxing
        return numbers.stream()
            .filter(Objects::nonNull)
            .mapToLong(Integer::longValue)
            .sum();
        
        // Najlepiej - primitive stream
        return numbers.stream()
            .filter(Objects::nonNull)
            .mapToInt(Integer::intValue)
            .asLongStream()
            .sum();
    }
    
    // Optymalizacja dla częstych operacji
    private static final Integer[] CACHE = new Integer[1000];
    static {
        for (int i = 0; i < CACHE.length; i++) {
            CACHE[i] = i;
        }
    }
    
    public Integer fastValueOf(int i) {
        return (i >= 0 && i < CACHE.length) ? CACHE[i] : Integer.valueOf(i);
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj własną wersję `IntegerCache` z konfigurowalnymi granicami i zmierz wpływ na wydajność w różnych scenariuszach.

**Zadanie Zaawansowane 2:** Stwórz analizator kodu, który znajdzie wszystkie miejsca potencjalnie problematycznego autoboxing/unboxing i zaproponuje optymalizacje.

**Zadanie Zaawansowane 3:** Zaprojektuj thread-safe licznik, który minimalizuje autoboxing i maksymalizuje wydajność w środowisku wielowątkowym.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Dlaczego autoboxing może być problematyczny w aplikacjach high-performance?
2. Jak można skonfigurować rozmiar cache dla Integer i jakie są tego implikacje?
3. Jakie są alternatywy dla kolekcji generycznych, które eliminują autoboxing?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static int sumujLiczby(List<Integer> liczby) {
    if (liczby == null) {
        return 0;
    }
    
    int suma = 0;
    for (Integer liczba : liczby) {
        if (liczba != null) {  // sprawdzenie null przed unboxing
            suma += liczba;    // unboxing: Integer → int
        }
    }
    return suma;
}

// Alternatywnie z streams:
public static int sumujLiczbyStream(List<Integer> liczby) {
    return liczby == null ? 0 : 
           liczby.stream()
                 .filter(Objects::nonNull)
                 .mapToInt(Integer::intValue)
                 .sum();
}
```

**Zadanie 2:**
```java
public static boolean majaTesamWartosci(List<Integer> lista1, List<Integer> lista2) {
    if (lista1 == null && lista2 == null) return true;
    if (lista1 == null || lista2 == null) return false;
    if (lista1.size() != lista2.size()) return false;
    
    for (int i = 0; i < lista1.size(); i++) {
        if (!Objects.equals(lista1.get(i), lista2.get(i))) {
            return false;
        }
    }
    return true;
}
```

**Zadanie 3:**
```java
// Test cache Integer
for (int i = -130; i <= 130; i++) {
    Integer a = i;
    Integer b = i;
    System.out.println(i + ": " + (a == b));
}
// Wynik: true dla -128 do 127, false dla reszty
```

**Pytania kontrolne:**
1. Wystąpi `NullPointerException` - nie można rozpakować null do typu prymitywnego.
2. Java cache'uje Integer od -128 do 127, więc dla tych wartości `==` porównuje te same obiekty.
3. W pętlach, gdzie autoboxing/unboxing występuje w każdej iteracji, tworząc niepotrzebne obiekty.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class CustomIntegerCache {
    private final int low;
    private final int high;
    private final Integer[] cache;
    
    public CustomIntegerCache(int low, int high) {
        this.low = low;
        this.high = high;
        this.cache = new Integer[high - low + 1];
        
        for (int i = 0; i < cache.length; i++) {
            cache[i] = new Integer(low + i);
        }
    }
    
    public Integer valueOf(int i) {
        if (i >= low && i <= high) {
            return cache[i - low];
        }
        return new Integer(i);
    }
    
    // Benchmark różnych rozmiarów cache
    @Benchmark
    public void testCachePerformance() {
        Random random = new Random();
        CustomIntegerCache cache = new CustomIntegerCache(-1000, 1000);
        
        for (int i = 0; i < 100000; i++) {
            int value = random.nextInt(2000) - 1000;
            Integer boxed = cache.valueOf(value);
        }
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class AutoboxingAnalyzer {
    public static class AutoboxingIssue {
        private final String location;
        private final String issue;
        private final String suggestion;
        
        // konstruktor, gettery...
    }
    
    public List<AutoboxingIssue> analyzeCode(String sourceCode) {
        List<AutoboxingIssue> issues = new ArrayList<>();
        
        // Znajdź problematyczne wzorce:
        // 1. Autoboxing w pętlach
        if (sourceCode.contains("for") && sourceCode.contains("Integer")) {
            issues.add(new AutoboxingIssue(
                "Loop with Integer",
                "Potential autoboxing in loop",
                "Use int instead of Integer for loop variables"
            ));
        }
        
        // 2. Porównywanie == z wrapper classes
        if (sourceCode.matches(".*Integer\\s*==\\s*Integer.*")) {
            issues.add(new AutoboxingIssue(
                "Integer comparison",
                "Using == to compare Integer objects",
                "Use Objects.equals() or .equals() method"
            ));
        }
        
        // 3. Null unboxing risk
        if (sourceCode.contains("Integer") && sourceCode.contains("= null")) {
            issues.add(new AutoboxingIssue(
                "Null unboxing risk",
                "Integer variable can be null",
                "Check for null before unboxing"
            ));
        }
        
        return issues;
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class HighPerformanceCounter {
    private final AtomicLong counter = new AtomicLong(0);
    
    // Unikamy autoboxing całkowicie
    public long increment() {
        return counter.incrementAndGet();
    }
    
    public long add(long delta) {
        return counter.addAndGet(delta);
    }
    
    public long get() {
        return counter.get();
    }
    
    // Jeśli potrzebujemy Integer, robimy to świadomie
    public Integer getAsInteger() {
        long value = counter.get();
        if (value > Integer.MAX_VALUE || value < Integer.MIN_VALUE) {
            throw new ArithmeticException("Counter value exceeds Integer range");
        }
        return (int) value;  // explicit cast, potem autoboxing
    }
    
    // Batch operations dla lepszej wydajności
    public long addBatch(long[] values) {
        long sum = 0;
        for (long value : values) {  // tylko prymitywy
            sum += value;
        }
        return counter.addAndGet(sum);
    }
}
```

**Pytania kontrolne:**
1. Autoboxing tworzy obiekty, zwiększa presję na GC, wymaga więcej pamięci i CPU. W hot paths może znacząco wpłynąć na wydajność.
2. Można użyć `-XX:AutoBoxCacheMax=<size>` dla Integer. Większy cache = więcej pamięci, ale mniej alokacji dla często używanych wartości.
3. Primitive collections (Eclipse Collections, Trove4j), primitive streams, specialized data structures, lub własne implementacje unikające autoboxing.

---

#### 📚 Co dalej?

*Świetnie! Teraz rozumiesz, jak działa autoboxing i unboxing, i co ważniejsze - wiesz, gdzie czyhają pułapki. Ta wiedza będzie nieoceniona przy optymalizacji wydajności Twoich aplikacji. W następnym rozdziale porozmawiamy o operatorach - tych podstawowych plus, minus, ale też o bardziej zaawansowanych sztuczkach, które Java ma w zanadrzu!*

---

*💡 Pamiętaj: Autoboxing to wygoda, ale używaj go świadomie. W krytycznych miejscach lepiej być explicit niż żałować później!*


## 4. Operatory: plusy, minusy i inne czary

*Cześć! Dziś porozmawiamy o operatorach w Javie. Na pierwszy rzut oka może się wydawać, że to proste - przecież plus to plus, prawda? Ale Java ma w zanadrzu kilka niespodzianek, które mogą Cię zaskoczyć. Od podstawowych operacji arytmetycznych, przez logiczne sztuczki, aż po bitowe czary - przygotuj się na pełen przegląd tego, co Java ma do zaoferowania!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Operatory to symbole, które mówią Javie, jaką operację ma wykonać na danych. To jak polecenia w przepisie kulinarnym - "dodaj", "odejmij", "porównaj", "sprawdź czy prawda". Java ma kilka rodzin operatorów, każda do innych zadań.

```java
// Podstawowe operatory arytmetyczne
int a = 10;
int b = 3;

int suma = a + b;        // 13 - dodawanie
int roznica = a - b;     // 7  - odejmowanie  
int iloczyn = a * b;     // 30 - mnożenie
int iloraz = a / b;      // 3  - dzielenie całkowite
int reszta = a % b;      // 1  - reszta z dzielenia (modulo)

// Operatory porównania
boolean rowne = (a == b);        // false
boolean nierowne = (a != b);     // true
boolean wieksze = (a > b);       // true
boolean mniejsze = (a < b);      // false
boolean wiekszeRowne = (a >= b); // true
boolean mniejszeRowne = (a <= b);// false
```

#### Dlaczego to ważne?

Operatory to podstawowe narzędzia do manipulacji danych w każdym programie. Bez nich nie mogłabyś wykonywać obliczeń, porównywać wartości ani podejmować decyzji w kodzie. To jak próba gotowania bez noża - teoretycznie możliwe, ale bardzo niepraktyczne!

#### Jak to działa w praktyce?

**Operatory arytmetyczne:**

```java
public class OperatoryArytmetyczne {
    public static void main(String[] args) {
        // Podstawowe operacje
        int x = 15;
        int y = 4;
        
        System.out.println("x + y = " + (x + y));  // 19
        System.out.println("x - y = " + (x - y));  // 11
        System.out.println("x * y = " + (x * y));  // 60
        System.out.println("x / y = " + (x / y));  // 3 (dzielenie całkowite!)
        System.out.println("x % y = " + (x % y));  // 3 (reszta)
        
        // Uwaga na dzielenie!
        double dokładnyIloraz = (double) x / y;  // 3.75
        System.out.println("Dokładny iloraz: " + dokładnyIloraz);
        
        // Operatory inkrementacji i dekrementacji
        int licznik = 5;
        licznik++;      // post-inkrementacja: użyj wartość, potem zwiększ
        ++licznik;      // pre-inkrementacja: zwiększ, potem użyj wartość
        licznik--;      // post-dekrementacja
        --licznik;      // pre-dekrementacja
        
        System.out.println("Końcowa wartość licznika: " + licznik); // 5
    }
}
```

**Operatory logiczne:**

```java
public class OperatoryLogiczne {
    public static void main(String[] args) {
        boolean prawda = true;
        boolean falsz = false;
        
        // Operatory logiczne
        System.out.println("prawda && falsz = " + (prawda && falsz)); // false (AND)
        System.out.println("prawda || falsz = " + (prawda || falsz)); // true (OR)
        System.out.println("!prawda = " + (!prawda));                 // false (NOT)
        
        // Praktyczny przykład
        int wiek = 25;
        boolean maLicencje = true;
        boolean mozeProwadzic = (wiek >= 18) && maLicencje;
        
        System.out.println("Może prowadzić: " + mozeProwadzic); // true
        
        // Short-circuit evaluation
        boolean wynik = falsz && (10 / 0 == 1); // Nie rzuci wyjątku!
        // Druga część nie jest sprawdzana, bo pierwsza to false
    }
}
```

**Operator ternarny (? :):**

```java
public class OperatorTernarny {
    public static void main(String[] args) {
        int wiek = 17;
        
        // Zamiast if-else:
        String status;
        if (wiek >= 18) {
            status = "pełnoletnia";
        } else {
            status = "niepełnoletnia";
        }
        
        // Możesz użyć operatora ternarnego:
        String statusTernarny = (wiek >= 18) ? "pełnoletnia" : "niepełnoletnia";
        
        System.out.println("Status: " + statusTernarny); // niepełnoletnia
        
        // Można zagnieżdżać (ale ostrożnie z czytelnością!)
        String ocena = (wiek >= 18) ? "dorosła" : 
                      (wiek >= 13) ? "nastolatka" : "dziecko";
    }
}
```

**Operatory przypisania:**

```java
public class OperatoryPrzypisania {
    public static void main(String[] args) {
        int x = 10;
        
        x += 5;   // x = x + 5;  → x = 15
        x -= 3;   // x = x - 3;  → x = 12
        x *= 2;   // x = x * 2;  → x = 24
        x /= 4;   // x = x / 4;  → x = 6
        x %= 5;   // x = x % 5;  → x = 1
        
        System.out.println("Końcowa wartość x: " + x); // 1
        
        // Dla Stringów też działa +=
        String tekst = "Hello";
        tekst += " World";  // tekst = tekst + " World";
        System.out.println(tekst); // Hello World
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Dzielenie całkowite**

```java
int a = 5;
int b = 2;
double wynik = a / b;  // 2.0, nie 2.5!

// Poprawnie:
double poprawnyWynik = (double) a / b;  // 2.5
```

**Pułapka 2: Różnica między ++ i ++**

```java
int i = 5;
int j = i++;  // j = 5, i = 6 (najpierw przypisz, potem zwiększ)
int k = ++i;  // k = 7, i = 7 (najpierw zwiększ, potem przypisz)
```

**Pułapka 3: Porównywanie obiektów**

```java
String s1 = new String("Hello");
String s2 = new String("Hello");
boolean rowne = (s1 == s2);  // false! Porównuje referencje, nie zawartość

// Poprawnie:
boolean poprawnieRowne = s1.equals(s2);  // true
```

#### 💡 Wskazówki dla Juniorek

- **Używaj nawiasów** dla jasności: `(a + b) * c` zamiast `a + b * c`
- **Uważaj na dzielenie przez zero** - sprawdzaj przed dzieleniem
- **Pamiętaj o kolejności operacji** - mnożenie i dzielenie przed dodawaniem i odejmowaniem
- **Używaj `equals()`** do porównywania obiektów, nie `==`
- **Operator ternarny** jest świetny dla prostych przypadków, ale nie przesadzaj z zagnieżdżaniem

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz kalkulator, który wykonuje podstawowe operacje arytmetyczne i obsługuje dzielenie przez zero.

```java
public class Kalkulator {
    public static double dodaj(double a, double b) {
        // Twoja implementacja
    }
    
    public static double podziel(double a, double b) {
        // Pamiętaj o dzieleniu przez zero!
    }
    
    // Dodaj pozostałe operacje
}
```

**Zadanie 2:** Stwórz metodę, która sprawdza, czy rok jest przestępny (podzielny przez 4, ale nie przez 100, chyba że przez 400).

**Zadanie 3:** Eksperymentuj z operatorami pre/post inkrementacji w pętlach i sprawdź różnice.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między `i++` a `++i`?
2. Dlaczego `5 / 2` daje `2`, a nie `2.5`?
3. Co to jest "short-circuit evaluation" w operatorach logicznych?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Operatory w Javie to nie tylko syntactic sugar - to fundamentalne elementy języka, które mają głębokie implikacje dla wydajności, semantyki i bezpieczeństwa kodu. Przyjrzyjmy się im z perspektywy architektury języka i optymalizacji JVM.

##### Hierarchia precedencji operatorów

Java ma ściśle określoną hierarchię precedencji operatorów, która wpływa na kolejność wykonywania operacji:

```java
public class PrecedencjaOperatorow {
    public void demonstracjaPrecedencji() {
        // Precedencja (od najwyższej):
        // 1. Postfix: expr++, expr--
        // 2. Unary: ++expr, --expr, +expr, -expr, ~, !
        // 3. Multiplicative: *, /, %
        // 4. Additive: +, -
        // 5. Shift: <<, >>, >>>
        // 6. Relational: <, >, <=, >=, instanceof
        // 7. Equality: ==, !=
        // 8. Bitwise AND: &
        // 9. Bitwise XOR: ^
        // 10. Bitwise OR: |
        // 11. Logical AND: &&
        // 12. Logical OR: ||
        // 13. Ternary: ? :
        // 14. Assignment: =, +=, -=, etc.
        
        int result = 2 + 3 * 4;  // 14, nie 20 (mnożenie ma wyższą precedencję)
        boolean complex = true || false && false;  // true (AND przed OR)
        
        // Dla czytelności zawsze używaj nawiasów w złożonych wyrażeniach
        int clearResult = 2 + (3 * 4);
        boolean clearComplex = true || (false && false);
    }
}
```

##### Operatory bitowe - zaawansowane zastosowania

```java
public class OperatoryBitowe {
    // Operatory bitowe działają na poziomie bitów
    public void demonstracjaBitowych() {
        int a = 60;  // 0011 1100 w binarnym
        int b = 13;  // 0000 1101 w binarnym
        
        System.out.println("a & b = " + (a & b));   // 12 (0000 1100) - AND
        System.out.println("a | b = " + (a | b));   // 61 (0011 1101) - OR
        System.out.println("a ^ b = " + (a ^ b));   // 49 (0011 0001) - XOR
        System.out.println("~a = " + (~a));         // -61 (1100 0011) - NOT
        System.out.println("a << 2 = " + (a << 2)); // 240 (przesunięcie w lewo)
        System.out.println("a >> 2 = " + (a >> 2)); // 15 (przesunięcie w prawo)
        System.out.println("a >>> 2 = " + (a >>> 2)); // 15 (unsigned right shift)
    }
    
    // Praktyczne zastosowania operatorów bitowych
    public class BitoweOptymalizacje {
        // Sprawdzenie czy liczba jest parzysta (szybsze niż % 2)
        public boolean isEven(int n) {
            return (n & 1) == 0;
        }
        
        // Mnożenie/dzielenie przez potęgi 2
        public int multiplyBy8(int n) {
            return n << 3;  // szybsze niż n * 8
        }
        
        public int divideBy4(int n) {
            return n >> 2;  // szybsze niż n / 4
        }
        
        // Swap bez dodatkowej zmiennej
        public void swapWithoutTemp(int a, int b) {
            a = a ^ b;
            b = a ^ b;
            a = a ^ b;
            // Teraz a i b są zamienione
        }
        
        // Ustawienie/czyszczenie/sprawdzanie bitów
        public int setBit(int number, int position) {
            return number | (1 << position);
        }
        
        public int clearBit(int number, int position) {
            return number & ~(1 << position);
        }
        
        public boolean isBitSet(int number, int position) {
            return (number & (1 << position)) != 0;
        }
    }
}
```

##### Operatory a autoboxing/unboxing

```java
public class OperatoryAutoboxing {
    public void demonstracjaAutoboxing() {
        Integer a = 100;
        Integer b = 200;
        
        // Operatory arytmetyczne powodują unboxing
        Integer sum = a + b;  // unboxing a i b, dodawanie, autoboxing wyniku
        
        // Operatory porównania też
        boolean greater = a > b;  // unboxing obu operandów
        
        // Ale uwaga na ==!
        Integer x = 127;
        Integer y = 127;
        System.out.println(x == y);  // true (cache)
        
        Integer m = 128;
        Integer n = 128;
        System.out.println(m == n);  // false (poza cache)
        
        // Bezpieczne porównywanie
        System.out.println(Objects.equals(m, n));  // true
    }
}
```

#### Pułapki i niuanse

##### Overflow i underflow

```java
public class OverflowUnderflow {
    public void demonstracjaOverflow() {
        // Integer overflow
        int maxInt = Integer.MAX_VALUE;
        int overflow = maxInt + 1;  // -2147483648 (wraparound)
        
        System.out.println("Max int: " + maxInt);
        System.out.println("Overflow: " + overflow);
        
        // Bezpieczne dodawanie (Java 8+)
        try {
            int safeSum = Math.addExact(maxInt, 1);
        } catch (ArithmeticException e) {
            System.out.println("Overflow detected!");
        }
        
        // Floating point overflow
        double maxDouble = Double.MAX_VALUE;
        double doubleOverflow = maxDouble * 2;  // Infinity
        
        System.out.println("Double overflow: " + doubleOverflow);
        System.out.println("Is infinite: " + Double.isInfinite(doubleOverflow));
    }
}
```

##### Floating point precision

```java
public class FloatingPointPrecision {
    public void demonstracjaPrecyzji() {
        // Klasyczny problem z floating point
        double result = 0.1 + 0.2;
        System.out.println(result);  // 0.30000000000000004, nie 0.3!
        
        // Porównywanie floating point
        double a = 0.1 + 0.2;
        double b = 0.3;
        
        // Źle
        boolean equal = (a == b);  // false!
        
        // Dobrze - z tolerancją
        double epsilon = 1e-10;
        boolean equalWithTolerance = Math.abs(a - b) < epsilon;  // true
        
        // Jeszcze lepiej - BigDecimal dla precyzyjnych obliczeń
        BigDecimal bd1 = new BigDecimal("0.1");
        BigDecimal bd2 = new BigDecimal("0.2");
        BigDecimal bd3 = new BigDecimal("0.3");
        
        BigDecimal sum = bd1.add(bd2);
        boolean exactEqual = sum.equals(bd3);  // true
    }
}
```

##### Operator instanceof i pattern matching

```java
public class InstanceofPatternMatching {
    // Tradycyjny instanceof (przed Java 14)
    public void traditionalInstanceof(Object obj) {
        if (obj instanceof String) {
            String str = (String) obj;  // explicit cast
            System.out.println("String length: " + str.length());
        }
    }
    
    // Pattern matching instanceof (Java 14+)
    public void patternMatchingInstanceof(Object obj) {
        if (obj instanceof String str) {  // pattern variable
            System.out.println("String length: " + str.length());  // no cast needed
        }
        
        // Można używać w złożonych wyrażeniach
        if (obj instanceof String str && str.length() > 5) {
            System.out.println("Long string: " + str);
        }
    }
    
    // Sealed classes i pattern matching (Java 17+)
    public sealed interface Shape permits Circle, Rectangle, Triangle {}
    public record Circle(double radius) implements Shape {}
    public record Rectangle(double width, double height) implements Shape {}
    public record Triangle(double base, double height) implements Shape {}
    
    public double calculateArea(Shape shape) {
        return switch (shape) {
            case Circle(var radius) -> Math.PI * radius * radius;
            case Rectangle(var width, var height) -> width * height;
            case Triangle(var base, var height) -> 0.5 * base * height;
        };
    }
}
```

#### Wzorce i best practices

##### Null-safe operators pattern

```java
public class NullSafeOperators {
    // Symulacja null-safe navigation (jak ?. w innych językach)
    public static <T, R> R safeGet(T object, Function<T, R> getter) {
        return object != null ? getter.apply(object) : null;
    }
    
    public static <T, R> R safeGet(T object, Function<T, R> getter, R defaultValue) {
        return object != null ? getter.apply(object) : defaultValue;
    }
    
    // Użycie
    public void demonstracja() {
        Person person = getPerson();  // może być null
        
        // Zamiast:
        String city = null;
        if (person != null && person.getAddress() != null) {
            city = person.getAddress().getCity();
        }
        
        // Możesz użyć:
        String safeCity = safeGet(person, p -> safeGet(p.getAddress(), Address::getCity));
        
        // Lub z Optional (jeszcze lepiej)
        String optionalCity = Optional.ofNullable(person)
            .map(Person::getAddress)
            .map(Address::getCity)
            .orElse("Unknown");
    }
}
```

##### Fluent interface z operatorami

```java
public class FluentCalculator {
    private double value;
    
    public FluentCalculator(double initialValue) {
        this.value = initialValue;
    }
    
    public FluentCalculator add(double operand) {
        this.value += operand;
        return this;
    }
    
    public FluentCalculator subtract(double operand) {
        this.value -= operand;
        return this;
    }
    
    public FluentCalculator multiply(double operand) {
        this.value *= operand;
        return this;
    }
    
    public FluentCalculator divide(double operand) {
        if (operand == 0) {
            throw new ArithmeticException("Division by zero");
        }
        this.value /= operand;
        return this;
    }
    
    public double result() {
        return value;
    }
    
    // Użycie
    public static void main(String[] args) {
        double result = new FluentCalculator(10)
            .add(5)
            .multiply(2)
            .subtract(3)
            .divide(4)
            .result();  // ((10 + 5) * 2 - 3) / 4 = 6.75
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj klasę `SafeMath`, która wykonuje operacje arytmetyczne z detekcją overflow/underflow i automatyczną promocją typów.

**Zadanie Zaawansowane 2:** Stwórz system flag bitowych do zarządzania uprawnieniami użytkowników, używając operatorów bitowych do efektywnego przechowywania i sprawdzania uprawnień.

**Zadanie Zaawansowane 3:** Zaprojektuj DSL (Domain Specific Language) dla obliczeń matematycznych, który używa przeciążenia operatorów (przez metody) do tworzenia czytelnych wyrażeń.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Dlaczego operatory bitowe są szybsze od operacji arytmetycznych dla potęg liczby 2?
2. Jak wpływa na wydajność częste używanie operatorów z autoboxing?
3. Jakie są implikacje bezpieczeństwa związane z overflow w operacjach arytmetycznych?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public class Kalkulator {
    public static double dodaj(double a, double b) {
        return a + b;
    }
    
    public static double odejmij(double a, double b) {
        return a - b;
    }
    
    public static double pomnoz(double a, double b) {
        return a * b;
    }
    
    public static double podziel(double a, double b) {
        if (b == 0) {
            throw new ArithmeticException("Nie można dzielić przez zero!");
        }
        return a / b;
    }
    
    public static double reszta(double a, double b) {
        if (b == 0) {
            throw new ArithmeticException("Nie można dzielić przez zero!");
        }
        return a % b;
    }
}
```

**Zadanie 2:**
```java
public static boolean czyRokPrzestepny(int rok) {
    return (rok % 4 == 0 && rok % 100 != 0) || (rok % 400 == 0);
}

// Test:
System.out.println(czyRokPrzestepny(2000)); // true (podzielny przez 400)
System.out.println(czyRokPrzestepny(1900)); // false (podzielny przez 100, ale nie przez 400)
System.out.println(czyRokPrzestepny(2024)); // true (podzielny przez 4, ale nie przez 100)
```

**Zadanie 3:**
```java
public class InkrementacjaTest {
    public static void main(String[] args) {
        // Pre-inkrementacja
        int i = 5;
        for (int j = 0; j < 3; j++) {
            System.out.println("Pre: " + (++i));  // 6, 7, 8
        }
        
        // Post-inkrementacja
        int k = 5;
        for (int j = 0; j < 3; j++) {
            System.out.println("Post: " + (k++));  // 5, 6, 7
        }
    }
}
```

**Pytania kontrolne:**
1. `i++` używa wartość, potem zwiększa; `++i` zwiększa, potem używa wartość.
2. Oba operandy to `int`, więc wynik też jest `int` - dzielenie całkowite obcina część ułamkową.
3. W `&&` jeśli pierwszy operand to `false`, drugi nie jest sprawdzany. W `||` jeśli pierwszy to `true`, drugi nie jest sprawdzany.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class SafeMath {
    public static int addExact(int a, int b) {
        long result = (long) a + (long) b;
        if (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE) {
            throw new ArithmeticException("Integer overflow");
        }
        return (int) result;
    }
    
    public static long addExact(long a, long b) {
        long result = a + b;
        // Sprawdź overflow
        if (((a ^ result) & (b ^ result)) < 0) {
            throw new ArithmeticException("Long overflow");
        }
        return result;
    }
    
    public static BigInteger addExact(BigInteger a, BigInteger b) {
        return a.add(b);  // BigInteger nie ma overflow
    }
    
    // Automatyczna promocja typów
    public static Number add(Number a, Number b) {
        if (a instanceof BigInteger || b instanceof BigInteger) {
            return toBigInteger(a).add(toBigInteger(b));
        }
        if (a instanceof BigDecimal || b instanceof BigDecimal) {
            return toBigDecimal(a).add(toBigDecimal(b));
        }
        if (a instanceof Double || b instanceof Double) {
            return a.doubleValue() + b.doubleValue();
        }
        if (a instanceof Float || b instanceof Float) {
            return a.floatValue() + b.floatValue();
        }
        if (a instanceof Long || b instanceof Long) {
            return addExact(a.longValue(), b.longValue());
        }
        return addExact(a.intValue(), b.intValue());
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class PermissionSystem {
    // Definicja uprawnień jako potęgi 2
    public static final int READ = 1;      // 0001
    public static final int WRITE = 2;     // 0010
    public static final int EXECUTE = 4;   // 0100
    public static final int DELETE = 8;    // 1000
    public static final int ADMIN = 16;    // 10000
    
    private int permissions = 0;
    
    // Dodaj uprawnienie
    public void grantPermission(int permission) {
        permissions |= permission;
    }
    
    // Usuń uprawnienie
    public void revokePermission(int permission) {
        permissions &= ~permission;
    }
    
    // Sprawdź uprawnienie
    public boolean hasPermission(int permission) {
        return (permissions & permission) == permission;
    }
    
    // Sprawdź czy ma wszystkie uprawnienia
    public boolean hasAllPermissions(int... requiredPermissions) {
        int combined = 0;
        for (int perm : requiredPermissions) {
            combined |= perm;
        }
        return (permissions & combined) == combined;
    }
    
    // Sprawdź czy ma którekolwiek z uprawnień
    public boolean hasAnyPermission(int... requiredPermissions) {
        for (int perm : requiredPermissions) {
            if ((permissions & perm) != 0) {
                return true;
            }
        }
        return false;
    }
    
    // Użycie
    public static void main(String[] args) {
        PermissionSystem user = new PermissionSystem();
        user.grantPermission(READ | WRITE);  // Nadaj READ i WRITE
        
        System.out.println(user.hasPermission(READ));    // true
        System.out.println(user.hasPermission(DELETE));  // false
        System.out.println(user.hasAllPermissions(READ, WRITE)); // true
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class MathDSL {
    private final double value;
    
    private MathDSL(double value) {
        this.value = value;
    }
    
    public static MathDSL val(double value) {
        return new MathDSL(value);
    }
    
    public MathDSL plus(double other) {
        return new MathDSL(this.value + other);
    }
    
    public MathDSL plus(MathDSL other) {
        return new MathDSL(this.value + other.value);
    }
    
    public MathDSL minus(double other) {
        return new MathDSL(this.value - other);
    }
    
    public MathDSL times(double other) {
        return new MathDSL(this.value * other);
    }
    
    public MathDSL dividedBy(double other) {
        return new MathDSL(this.value / other);
    }
    
    public MathDSL pow(double exponent) {
        return new MathDSL(Math.pow(this.value, exponent));
    }
    
    public double result() {
        return value;
    }
    
    // Użycie - czytelne wyrażenia matematyczne
    public static void main(String[] args) {
        double result = val(10)
            .plus(5)
            .times(2)
            .minus(val(3).times(4))
            .dividedBy(2)
            .pow(2)
            .result();  // ((10 + 5) * 2 - (3 * 4)) / 2)^2 = 49
    }
}
```

**Pytania kontrolne:**
1. Operatory bitowe działają bezpośrednio na bitach w rejestrach CPU, podczas gdy operacje arytmetyczne mogą wymagać dodatkowych cykli procesora.
2. Autoboxing z operatorami tworzy nowe obiekty w każdej operacji, zwiększając presję na GC i zmniejszając wydajność.
3. Overflow może prowadzić do nieprzewidywalnych wyników, potencjalnych luk bezpieczeństwa (np. buffer overflow) i błędów logicznych w aplikacji.

---

#### 📚 Co dalej?

*Świetnie! Teraz masz solidne podstawy operatorów w Javie. Od prostych dodawań po zaawansowane operacje bitowe - to wszystko będzie Ci towarzyszyć w codziennej pracy. W następnym rozdziale porozmawiamy o warunkach - if, else, switch i innych życiowych wyborach, które Twój kod musi podejmować!*

---

*💡 Pamiętaj: Operatory to narzędzia - używaj ich świadomie i zawsze myśl o czytelności kodu dla innych programistek!*


## 5. Warunki: if, else, switch i inne życiowe wybory

*Cześć! Dziś porozmawiamy o jednej z najważniejszych rzeczy w programowaniu - podejmowaniu decyzji. Każdy program musi umieć wybierać między różnymi opcjami, reagować na różne sytuacje i podejmować "życiowe wybory". W Javie mamy do tego kilka narzędzi, od prostego if-else po nowoczesne switch expressions. Przygotuj się na poznanie wszystkich sposobów, jak Twój kod może myśleć!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Instrukcje warunkowe to sposób, w jaki Twój program podejmuje decyzje. To jak rozwidlenie drogi - w zależności od warunków, program idzie w jedną lub drugą stronę. Bez nich każdy program robiłby zawsze to samo, niezależnie od sytuacji.

```java
// Podstawowa struktura if
int wiek = 20;

if (wiek >= 18) {
    System.out.println("Jesteś pełnoletnia!");
}

// If z else
if (wiek >= 18) {
    System.out.println("Jesteś pełnoletnia!");
} else {
    System.out.println("Jesteś niepełnoletnia.");
}

// If-else if-else (łańcuch warunków)
if (wiek < 13) {
    System.out.println("Jesteś dzieckiem.");
} else if (wiek < 18) {
    System.out.println("Jesteś nastolatką.");
} else if (wiek < 65) {
    System.out.println("Jesteś dorosła.");
} else {
    System.out.println("Jesteś seniorką.");
}
```

#### Dlaczego to ważne?

Bez instrukcji warunkowych programy byłyby jak roboty wykonujące zawsze te same czynności. Warunki pozwalają programom reagować na różne sytuacje, dostosowywać się do danych wejściowych i podejmować inteligentne decyzje. To podstawa interaktywności i logiki biznesowej.

#### Jak to działa w praktyce?

**Podstawowe if-else:**

```java
public class PodstawoweWarunki {
    public static void main(String[] args) {
        int temperatura = 25;
        
        // Prosty warunek
        if (temperatura > 30) {
            System.out.println("Jest gorąco!");
        }
        
        // Warunek z else
        if (temperatura > 20) {
            System.out.println("Przyjemna temperatura.");
        } else {
            System.out.println("Trochę chłodno.");
        }
        
        // Złożone warunki z operatorami logicznymi
        boolean jestSlonecznie = true;
        if (temperatura > 25 && jestSlonecznie) {
            System.out.println("Idealny dzień na spacer!");
        }
        
        // Warunki z OR
        if (temperatura < 0 || temperatura > 40) {
            System.out.println("Ekstremalna temperatura!");
        }
    }
}
```

**Switch - tradycyjna wersja:**

```java
public class TradycyjnySwitch {
    public static void main(String[] args) {
        int dzienTygodnia = 3;
        String nazwaDnia;
        
        switch (dzienTygodnia) {
            case 1:
                nazwaDnia = "Poniedziałek";
                break;
            case 2:
                nazwaDnia = "Wtorek";
                break;
            case 3:
                nazwaDnia = "Środa";
                break;
            case 4:
                nazwaDnia = "Czwartek";
                break;
            case 5:
                nazwaDnia = "Piątek";
                break;
            case 6:
            case 7:
                nazwaDnia = "Weekend";
                break;
            default:
                nazwaDnia = "Nieprawidłowy dzień";
                break;
        }
        
        System.out.println("Dziś jest: " + nazwaDnia);
    }
}
```

**Switch expressions (Java 14+):**

```java
public class NowoczesnySwitch {
    public static void main(String[] args) {
        int dzienTygodnia = 3;
        
        // Switch expression - zwraca wartość
        String nazwaDnia = switch (dzienTygodnia) {
            case 1 -> "Poniedziałek";
            case 2 -> "Wtorek";
            case 3 -> "Środa";
            case 4 -> "Czwartek";
            case 5 -> "Piątek";
            case 6, 7 -> "Weekend";  // Można grupować przypadki
            default -> "Nieprawidłowy dzień";
        };
        
        System.out.println("Dziś jest: " + nazwaDnia);
        
        // Switch z blokami kodu
        String opis = switch (dzienTygodnia) {
            case 1 -> {
                System.out.println("Początek tygodnia!");
                yield "Poniedziałek - czas na nowe wyzwania";
            }
            case 5 -> {
                System.out.println("Prawie weekend!");
                yield "Piątek - ostatni dzień pracy";
            }
            default -> "Zwykły dzień";
        };
        
        System.out.println(opis);
    }
}
```

**Warunki z String:**

```java
public class WarunkiZString {
    public static void main(String[] args) {
        String komenda = "start";
        
        // If z String
        if ("start".equals(komenda)) {
            System.out.println("Uruchamianie aplikacji...");
        } else if ("stop".equals(komenda)) {
            System.out.println("Zatrzymywanie aplikacji...");
        } else if ("restart".equals(komenda)) {
            System.out.println("Restartowanie aplikacji...");
        } else {
            System.out.println("Nieznana komenda: " + komenda);
        }
        
        // Switch z String (Java 7+)
        String akcja = switch (komenda) {
            case "start" -> "Uruchamianie...";
            case "stop" -> "Zatrzymywanie...";
            case "restart" -> "Restartowanie...";
            default -> "Nieznana komenda";
        };
        
        System.out.println(akcja);
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Brak break w switch**

```java
int liczba = 2;
switch (liczba) {
    case 1:
        System.out.println("Jeden");
        // Brak break! Wykona się też case 2
    case 2:
        System.out.println("Dwa");
        // Brak break! Wykona się też case 3
    case 3:
        System.out.println("Trzy");
        break;
}
// Wypisze: "Dwa" i "Trzy"
```

**Pułapka 2: Porównywanie String z ==**

```java
String input = new String("hello");
if (input == "hello") {  // ŹLE! Porównuje referencje
    System.out.println("To nie zadziała");
}

if ("hello".equals(input)) {  // DOBRZE!
    System.out.println("To zadziała");
}
```

**Pułapka 3: Null w warunkach**

```java
String tekst = null;
if (tekst.equals("hello")) {  // NullPointerException!
    System.out.println("Nigdy się nie wykona");
}

// Bezpieczne podejście:
if ("hello".equals(tekst)) {  // Bezpieczne
    System.out.println("To jest bezpieczne");
}

// Lub z Objects.equals:
if (Objects.equals(tekst, "hello")) {  // Też bezpieczne
    System.out.println("To też jest bezpieczne");
}
```

#### 💡 Wskazówki dla Juniorek

- **Zawsze używaj nawiasów klamrowych** `{}` nawet dla jednej linii - czytelność!
- **Pamiętaj o break** w tradycyjnym switch
- **Używaj `equals()`** do porównywania String, nie `==`
- **Sprawdzaj null** przed wywołaniem metod na obiektach
- **Switch expressions** są często czytelniejsze niż tradycyjny switch

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz program, który na podstawie oceny (1-6) wypisuje odpowiedni komentarz.

```java
public static String komentarzOceny(int ocena) {
    // Użyj switch expression
}
```

**Zadanie 2:** Stwórz kalkulator BMI, który nie tylko oblicza BMI, ale też kategoryzuje wynik (niedowaga, norma, nadwaga, otyłość).

**Zadanie 3:** Napisz metodę, która sprawdza, czy podany rok jest przestępny, używając warunków if-else.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między tradycyjnym switch a switch expression?
2. Dlaczego `"hello".equals(zmienna)` jest bezpieczniejsze niż `zmienna.equals("hello")`?
3. Co się stanie, jeśli zapomnisz `break` w tradycyjnym switch?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Instrukcje warunkowe w Javie to nie tylko syntactic sugar - to fundamentalne konstrukcje kontroli przepływu, które mają głębokie implikacje dla wydajności, czytelności i maintainability kodu. Przyjrzyjmy się im z perspektywy architektury języka i optymalizacji JVM.

##### Optymalizacje JVM dla instrukcji warunkowych

```java
public class OptymalizacjeWarunkow {
    // JVM optymalizuje częste ścieżki (branch prediction)
    public int optimizedBranching(int value) {
        // Jeśli ta ścieżka jest często wykonywana, JVM ją zoptymalizuje
        if (value > 0) {  // "hot path"
            return value * 2;
        } else {  // "cold path"
            return value * -1;
        }
    }
    
    // Eliminacja martwego kodu
    public void deadCodeElimination() {
        final boolean DEBUG = false;
        
        if (DEBUG) {
            System.out.println("Debug info");  // Kompilator usunie ten kod
        }
        
        // JVM może też optymalizować runtime
        boolean condition = Math.random() > 0.5;
        if (condition) {
            // Jeśli JVM stwierdzi, że ta ścieżka nigdy nie jest wykonywana,
            // może ją usunąć z skompilowanego kodu
        }
    }
    
    // Inlining metod w warunkach
    public boolean expensiveCondition() {
        // Ta metoda może zostać "wstawiona" bezpośrednio do miejsca wywołania
        return System.currentTimeMillis() % 2 == 0;
    }
    
    public void methodInlining() {
        if (expensiveCondition()) {  // Może zostać zastąpione bezpośrednim kodem
            System.out.println("Even timestamp");
        }
    }
}
```

##### Pattern matching i sealed classes

```java
// Sealed classes dla exhaustive pattern matching
public sealed interface PaymentMethod 
    permits CreditCard, DebitCard, PayPal, BankTransfer {
}

public record CreditCard(String number, String cvv) implements PaymentMethod {}
public record DebitCard(String number, String pin) implements PaymentMethod {}
public record PayPal(String email) implements PaymentMethod {}
public record BankTransfer(String accountNumber, String routingNumber) implements PaymentMethod {}

public class PaymentProcessor {
    // Exhaustive pattern matching (Java 17+)
    public double calculateFee(PaymentMethod method, double amount) {
        return switch (method) {
            case CreditCard(var number, var cvv) -> amount * 0.03;  // 3% fee
            case DebitCard(var number, var pin) -> amount * 0.01;   // 1% fee
            case PayPal(var email) -> amount * 0.025;               // 2.5% fee
            case BankTransfer(var account, var routing) -> 5.0;     // flat $5 fee
            // Nie potrzeba default - kompilator wie, że wszystkie przypadki są pokryte
        };
    }
    
    // Guard conditions w pattern matching
    public String categorizePayment(PaymentMethod method, double amount) {
        return switch (method) {
            case CreditCard cc when amount > 1000 -> "High-value credit transaction";
            case CreditCard cc -> "Regular credit transaction";
            case DebitCard dd when amount < 10 -> "Micro debit transaction";
            case DebitCard dd -> "Regular debit transaction";
            case PayPal pp when pp.email().endsWith("@business.com") -> "Business PayPal";
            case PayPal pp -> "Personal PayPal";
            case BankTransfer bt -> "Bank transfer";
        };
    }
}
```

##### Zaawansowane wzorce warunkowe

```java
public class ZaawansowaneWzorce {
    // Null Object Pattern
    public interface Logger {
        void log(String message);
    }
    
    public static class ConsoleLogger implements Logger {
        public void log(String message) {
            System.out.println(message);
        }
    }
    
    public static class NullLogger implements Logger {
        public void log(String message) {
            // Nic nie rób
        }
    }
    
    // Zamiast sprawdzania null w każdym miejscu
    public void processWithNullChecks(Logger logger, String message) {
        if (logger != null) {
            logger.log(message);
        }
    }
    
    // Używamy Null Object Pattern
    public void processWithNullObject(Logger logger, String message) {
        logger.log(message);  // logger nigdy nie jest null
    }
    
    // Strategy Pattern z enum
    public enum DiscountStrategy {
        NONE {
            @Override
            public double apply(double price) {
                return price;
            }
        },
        STUDENT {
            @Override
            public double apply(double price) {
                return price * 0.9;  // 10% discount
            }
        },
        SENIOR {
            @Override
            public double apply(double price) {
                return price * 0.8;  // 20% discount
            }
        },
        VIP {
            @Override
            public double apply(double price) {
                return price * 0.7;  // 30% discount
            }
        };
        
        public abstract double apply(double price);
    }
    
    // Zamiast długiego if-else if
    public double calculatePrice(double basePrice, DiscountStrategy strategy) {
        return strategy.apply(basePrice);
    }
}
```

#### Pułapki i niuanse

##### Performance considerations

```java
public class PerformanceConsiderations {
    // Kolejność warunków ma znaczenie
    public String categorizeUser(User user) {
        // Umieść najczęstsze przypadki na początku
        if (user.isRegularUser()) {      // 80% przypadków
            return "regular";
        } else if (user.isPremiumUser()) { // 15% przypadków
            return "premium";
        } else if (user.isAdminUser()) {   // 4% przypadków
            return "admin";
        } else if (user.isGuestUser()) {   // 1% przypadków
            return "guest";
        }
        return "unknown";
    }
    
    // Unikaj kosztownych operacji w warunkach
    public boolean expensiveConditionBad(String data) {
        // Źle - kosztowna operacja wykonywana za każdym razem
        if (data.toLowerCase().trim().startsWith("prefix")) {
            return true;
        }
        return false;
    }
    
    public boolean expensiveConditionGood(String data) {
        // Dobrze - wykonaj kosztowną operację raz
        String normalized = data.toLowerCase().trim();
        if (normalized.startsWith("prefix")) {
            return true;
        }
        return false;
    }
    
    // Switch vs if-else performance
    public String switchVsIfElse(int value) {
        // Dla wielu przypadków switch może być szybszy (jump table)
        return switch (value) {
            case 1 -> "one";
            case 2 -> "two";
            case 3 -> "three";
            // ... wiele przypadków
            case 100 -> "hundred";
            default -> "other";
        };
    }
}
```

##### Problemy z floating point w warunkach

```java
public class FloatingPointConditions {
    public void demonstrateFloatingPointIssues() {
        double a = 0.1 + 0.2;
        double b = 0.3;
        
        // To może nie zadziałać jak oczekujesz!
        if (a == b) {
            System.out.println("Equal");  // Może się nie wykonać
        }
        
        // Poprawne porównywanie floating point
        double epsilon = 1e-10;
        if (Math.abs(a - b) < epsilon) {
            System.out.println("Equal within tolerance");
        }
        
        // Lub użyj BigDecimal dla precyzyjnych obliczeń
        BigDecimal bd1 = new BigDecimal("0.1").add(new BigDecimal("0.2"));
        BigDecimal bd2 = new BigDecimal("0.3");
        if (bd1.equals(bd2)) {
            System.out.println("Exactly equal");
        }
    }
}
```

##### Concurrent access w warunkach

```java
public class ConcurrentConditions {
    private volatile boolean flag = false;
    private final Object lock = new Object();
    
    // Race condition w warunkach
    public void raceConditionExample() {
        // Thread 1
        if (!flag) {
            // Thread 2 może zmienić flag tutaj!
            flag = true;
            // Może prowadzić do niespójnego stanu
        }
    }
    
    // Bezpieczna wersja
    public void threadSafeVersion() {
        synchronized (lock) {
            if (!flag) {
                flag = true;
                // Atomowa operacja
            }
        }
    }
    
    // Double-checked locking (dla lazy initialization)
    private volatile ExpensiveObject instance;
    
    public ExpensiveObject getInstance() {
        if (instance == null) {  // Pierwszy check bez synchronizacji
            synchronized (this) {
                if (instance == null) {  // Drugi check z synchronizacją
                    instance = new ExpensiveObject();
                }
            }
        }
        return instance;
    }
}
```

#### Wzorce i best practices

##### Command Pattern z switch expressions

```java
public class CommandPattern {
    public sealed interface Command permits StartCommand, StopCommand, RestartCommand {}
    public record StartCommand() implements Command {}
    public record StopCommand() implements Command {}
    public record RestartCommand() implements Command {}
    
    public class ServiceController {
        private boolean isRunning = false;
        
        public String execute(Command command) {
            return switch (command) {
                case StartCommand() -> {
                    if (!isRunning) {
                        isRunning = true;
                        yield "Service started";
                    } else {
                        yield "Service already running";
                    }
                }
                case StopCommand() -> {
                    if (isRunning) {
                        isRunning = false;
                        yield "Service stopped";
                    } else {
                        yield "Service not running";
                    }
                }
                case RestartCommand() -> {
                    isRunning = false;
                    isRunning = true;
                    yield "Service restarted";
                }
            };
        }
    }
}
```

##### Specification Pattern

```java
public class SpecificationPattern {
    @FunctionalInterface
    public interface Specification<T> {
        boolean isSatisfiedBy(T candidate);
        
        default Specification<T> and(Specification<T> other) {
            return candidate -> this.isSatisfiedBy(candidate) && other.isSatisfiedBy(candidate);
        }
        
        default Specification<T> or(Specification<T> other) {
            return candidate -> this.isSatisfiedBy(candidate) || other.isSatisfiedBy(candidate);
        }
        
        default Specification<T> not() {
            return candidate -> !this.isSatisfiedBy(candidate);
        }
    }
    
    // Przykład użycia
    public class UserSpecifications {
        public static Specification<User> isAdult() {
            return user -> user.getAge() >= 18;
        }
        
        public static Specification<User> hasEmail() {
            return user -> user.getEmail() != null && !user.getEmail().isEmpty();
        }
        
        public static Specification<User> isPremium() {
            return user -> user.getSubscriptionType() == SubscriptionType.PREMIUM;
        }
    }
    
    // Użycie
    public void filterUsers(List<User> users) {
        Specification<User> eligibleForPromotion = 
            UserSpecifications.isAdult()
                .and(UserSpecifications.hasEmail())
                .and(UserSpecifications.isPremium().not());
        
        List<User> eligible = users.stream()
            .filter(eligibleForPromotion::isSatisfiedBy)
            .collect(Collectors.toList());
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj system reguł biznesowych używając pattern matching i sealed classes, który może być łatwo rozszerzany o nowe reguły.

**Zadanie Zaawansowane 2:** Stwórz benchmark porównujący wydajność różnych podejść do instrukcji warunkowych (if-else vs switch vs enum strategy vs lookup table).

**Zadanie Zaawansowane 3:** Zaprojektuj thread-safe state machine używając enum i switch expressions, z obsługą concurrent transitions.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak JVM optymalizuje instrukcje warunkowe i co to jest branch prediction?
2. Jakie są zalety pattern matching z sealed classes w porównaniu do tradycyjnych podejść?
3. Dlaczego double-checked locking wymaga volatile i jakie są alternatywy?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static String komentarzOceny(int ocena) {
    return switch (ocena) {
        case 1 -> "Niedostateczny - trzeba popracować!";
        case 2 -> "Dopuszczający - można lepiej!";
        case 3 -> "Dostateczny - w porządku.";
        case 4 -> "Dobry - świetna robota!";
        case 5 -> "Bardzo dobry - brawo!";
        case 6 -> "Celujący - fantastycznie!";
        default -> "Nieprawidłowa ocena";
    };
}
```

**Zadanie 2:**
```java
public class KalkulatorBMI {
    public static double obliczBMI(double waga, double wzrost) {
        return waga / (wzrost * wzrost);
    }
    
    public static String kategoriaBMI(double bmi) {
        if (bmi < 18.5) {
            return "Niedowaga";
        } else if (bmi < 25) {
            return "Waga prawidłowa";
        } else if (bmi < 30) {
            return "Nadwaga";
        } else {
            return "Otyłość";
        }
    }
    
    public static void analizaBMI(double waga, double wzrost) {
        double bmi = obliczBMI(waga, wzrost);
        String kategoria = kategoriaBMI(bmi);
        System.out.printf("BMI: %.2f - %s%n", bmi, kategoria);
    }
}
```

**Zadanie 3:**
```java
public static boolean czyRokPrzestepny(int rok) {
    if (rok % 400 == 0) {
        return true;  // Podzielny przez 400 - przestępny
    } else if (rok % 100 == 0) {
        return false; // Podzielny przez 100, ale nie przez 400 - nie przestępny
    } else if (rok % 4 == 0) {
        return true;  // Podzielny przez 4, ale nie przez 100 - przestępny
    } else {
        return false; // Nie podzielny przez 4 - nie przestępny
    }
}
```

**Pytania kontrolne:**
1. Tradycyjny switch wymaga `break` i nie zwraca wartości. Switch expression zwraca wartość i nie wymaga `break`.
2. Jeśli `zmienna` jest `null`, to `zmienna.equals("hello")` rzuci NPE, ale `"hello".equals(zmienna)` zwróci `false`.
3. Wykonają się wszystkie kolejne case'y aż do napotkania `break` lub końca switch (fall-through behavior).

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class BusinessRulesEngine {
    public sealed interface Rule permits AgeRule, IncomeRule, CreditScoreRule, CompositeRule {}
    
    public record AgeRule(int minAge, int maxAge) implements Rule {}
    public record IncomeRule(double minIncome) implements Rule {}
    public record CreditScoreRule(int minScore) implements Rule {}
    public record CompositeRule(Rule left, LogicalOperator operator, Rule right) implements Rule {}
    
    public enum LogicalOperator { AND, OR }
    
    public record Customer(int age, double income, int creditScore) {}
    
    public class RuleEvaluator {
        public boolean evaluate(Rule rule, Customer customer) {
            return switch (rule) {
                case AgeRule(var minAge, var maxAge) -> 
                    customer.age() >= minAge && customer.age() <= maxAge;
                    
                case IncomeRule(var minIncome) -> 
                    customer.income() >= minIncome;
                    
                case CreditScoreRule(var minScore) -> 
                    customer.creditScore() >= minScore;
                    
                case CompositeRule(var left, var operator, var right) -> switch (operator) {
                    case AND -> evaluate(left, customer) && evaluate(right, customer);
                    case OR -> evaluate(left, customer) || evaluate(right, customer);
                };
            };
        }
    }
    
    // Użycie
    public void example() {
        Rule loanEligibility = new CompositeRule(
            new AgeRule(18, 65),
            LogicalOperator.AND,
            new CompositeRule(
                new IncomeRule(50000),
                LogicalOperator.AND,
                new CreditScoreRule(650)
            )
        );
        
        Customer customer = new Customer(30, 60000, 700);
        RuleEvaluator evaluator = new RuleEvaluator();
        boolean eligible = evaluator.evaluate(loanEligibility, customer);
    }
}
```

**Zadanie Zaawansowane 2:**
```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class ConditionalBenchmark {
    private static final int[] testValues = IntStream.range(0, 1000).toArray();
    
    @Benchmark
    public int ifElseChain() {
        int sum = 0;
        for (int value : testValues) {
            if (value < 100) sum += 1;
            else if (value < 200) sum += 2;
            else if (value < 300) sum += 3;
            else if (value < 400) sum += 4;
            else sum += 5;
        }
        return sum;
    }
    
    @Benchmark
    public int switchStatement() {
        int sum = 0;
        for (int value : testValues) {
            sum += switch (value / 100) {
                case 0 -> 1;
                case 1 -> 2;
                case 2 -> 3;
                case 3 -> 4;
                default -> 5;
            };
        }
        return sum;
    }
    
    @Benchmark
    public int lookupTable() {
        int[] lookup = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int value : testValues) {
            int index = Math.min(value / 100, 4);
            sum += lookup[index];
        }
        return sum;
    }
    
    // Wyniki pokazują, że lookup table jest najszybszy dla prostych przypadków
}
```

**Zadanie Zaawansowane 3:**
```java
public class ThreadSafeStateMachine {
    public enum State {
        IDLE, STARTING, RUNNING, STOPPING, ERROR
    }
    
    public enum Event {
        START, STOP, ERROR, RESET
    }
    
    private volatile State currentState = State.IDLE;
    private final Object stateLock = new Object();
    
    public State transition(Event event) {
        synchronized (stateLock) {
            State newState = switch (currentState) {
                case IDLE -> switch (event) {
                    case START -> State.STARTING;
                    case ERROR -> State.ERROR;
                    default -> currentState;
                };
                
                case STARTING -> switch (event) {
                    case START -> State.RUNNING;  // Transition completed
                    case ERROR -> State.ERROR;
                    case STOP -> State.STOPPING;
                    default -> currentState;
                };
                
                case RUNNING -> switch (event) {
                    case STOP -> State.STOPPING;
                    case ERROR -> State.ERROR;
                    default -> currentState;
                };
                
                case STOPPING -> switch (event) {
                    case STOP -> State.IDLE;  // Transition completed
                    case ERROR -> State.ERROR;
                    default -> currentState;
                };
                
                case ERROR -> switch (event) {
                    case RESET -> State.IDLE;
                    default -> currentState;
                };
            };
            
            if (newState != currentState) {
                State oldState = currentState;
                currentState = newState;
                notifyStateChange(oldState, newState);
            }
            
            return currentState;
        }
    }
    
    private void notifyStateChange(State from, State to) {
        // Notify listeners about state change
        System.out.printf("State changed: %s -> %s%n", from, to);
    }
    
    public State getCurrentState() {
        return currentState;
    }
}
```

**Pytania kontrolne:**
1. JVM używa branch prediction do przewidywania, która ścieżka będzie wykonana, i optymalizuje kod dla częstych ścieżek. Może też eliminować martwy kod i inlinować metody.
2. Pattern matching z sealed classes zapewnia exhaustiveness checking w compile time, lepszą czytelność i type safety, eliminując potrzebę default cases.
3. Volatile zapewnia visibility i ordering guarantees. Alternatywy to initialization-on-demand holder pattern lub enum singleton.

---

#### 📚 Co dalej?

*Świetnie! Teraz masz pełne zrozumienie instrukcji warunkowych w Javie - od podstawowych if-else po zaawansowane pattern matching. Ta wiedza będzie fundamentem dla wszystkich decyzji, które Twój kod będzie musiał podejmować. W następnym rozdziale porozmawiamy o pętlach - for, while i innych sposobach na "wracanie do punktu wyjścia"!*

---

*💡 Pamiętaj: Dobry kod to kod, który podejmuje mądre decyzje. Używaj odpowiednich konstrukcji warunkowych dla każdej sytuacji!*


## 6. Pętle: for, while, czyli wracamy do punktu wyjścia

*Cześć! Dziś porozmawiamy o pętlach - jednej z najważniejszych konstrukcji w programowaniu. Pętle to sposób, w jaki mówimy komputerowi: "rób to samo, dopóki nie powiem stop" lub "zrób to dla każdego elementu z tej listy". Bez pętli programowanie byłoby jak próba napisania książki, przepisując każde zdanie ręcznie zamiast użyć kopiuj-wklej. Przygotuj się na poznanie wszystkich sposobów na eleganckie powtarzanie!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Pętla to konstrukcja, która pozwala wykonywać ten sam kod wielokrotnie. To jak instrukcja "powtarzaj, aż..." w przepisie kulinarnym. Zamiast pisać ten sam kod 100 razy, piszesz go raz i mówisz komputerowi, żeby powtórzył go 100 razy.

```java
// Bez pętli - okropne!
System.out.println("Hello 1");
System.out.println("Hello 2");
System.out.println("Hello 3");
// ... i tak dalej 100 razy

// Z pętlą - elegancko!
for (int i = 1; i <= 100; i++) {
    System.out.println("Hello " + i);
}
```

#### Dlaczego to ważne?

Pętle to podstawa automatyzacji w programowaniu. Pozwalają przetwarzać duże ilości danych, wykonywać powtarzalne zadania i tworzyć interaktywne programy. Bez pętli każdy program byłby ograniczony do wykonywania z góry określonej liczby operacji.

#### Jak to działa w praktyce?

**Pętla for - klasyczna:**

```java
public class PetlaFor {
    public static void main(String[] args) {
        // Podstawowa pętla for
        for (int i = 0; i < 5; i++) {
            System.out.println("Iteracja: " + i);
        }
        // Wypisze: 0, 1, 2, 3, 4
        
        // Pętla od tyłu
        for (int i = 10; i >= 1; i--) {
            System.out.println("Odliczanie: " + i);
        }
        
        // Pętla z krokiem 2
        for (int i = 0; i < 10; i += 2) {
            System.out.println("Parzyste: " + i);
        }
        // Wypisze: 0, 2, 4, 6, 8
        
        // Pętla z wieloma zmiennymi
        for (int i = 0, j = 10; i < j; i++, j--) {
            System.out.println("i=" + i + ", j=" + j);
        }
    }
}
```

**Pętla for-each (enhanced for):**

```java
public class PetlaForEach {
    public static void main(String[] args) {
        // Z tablicą
        int[] liczby = {1, 2, 3, 4, 5};
        for (int liczba : liczby) {
            System.out.println("Liczba: " + liczba);
        }
        
        // Z listą
        List<String> imiona = Arrays.asList("Anna", "Kasia", "Ola");
        for (String imie : imiona) {
            System.out.println("Cześć " + imie + "!");
        }
        
        // Z String (każdy znak)
        String tekst = "Java";
        for (char znak : tekst.toCharArray()) {
            System.out.println("Znak: " + znak);
        }
    }
}
```

**Pętla while:**

```java
public class PetlaWhile {
    public static void main(String[] args) {
        // Podstawowa pętla while
        int licznik = 0;
        while (licznik < 5) {
            System.out.println("Licznik: " + licznik);
            licznik++;
        }
        
        // Pętla z warunkiem złożonym
        Scanner scanner = new Scanner(System.in);
        String input = "";
        while (!input.equals("quit")) {
            System.out.print("Wpisz coś (lub 'quit' aby wyjść): ");
            input = scanner.nextLine();
            System.out.println("Napisałaś: " + input);
        }
        
        // Pętla nieskończona (z break)
        int x = 0;
        while (true) {
            x++;
            if (x > 10) {
                break;  // Wyjście z pętli
            }
            if (x % 2 == 0) {
                continue;  // Przejdź do następnej iteracji
            }
            System.out.println("Nieparzyste: " + x);
        }
    }
}
```

**Pętla do-while:**

```java
public class PetlaDoWhile {
    public static void main(String[] args) {
        // Do-while wykonuje się przynajmniej raz
        int liczba = 10;
        do {
            System.out.println("Liczba: " + liczba);
            liczba--;
        } while (liczba > 5);
        
        // Praktyczny przykład - menu
        Scanner scanner = new Scanner(System.in);
        int wybor;
        do {
            System.out.println("1. Opcja A");
            System.out.println("2. Opcja B");
            System.out.println("0. Wyjście");
            System.out.print("Wybierz opcję: ");
            wybor = scanner.nextInt();
            
            switch (wybor) {
                case 1 -> System.out.println("Wybrałaś opcję A");
                case 2 -> System.out.println("Wybrałaś opcję B");
                case 0 -> System.out.println("Do widzenia!");
                default -> System.out.println("Nieprawidłowy wybór");
            }
        } while (wybor != 0);
    }
}
```

#### Kontrola przepływu w pętlach

```java
public class KontrolaPrzeplywu {
    public static void main(String[] args) {
        // break - wyjście z pętli
        for (int i = 0; i < 10; i++) {
            if (i == 5) {
                break;  // Przerywa pętlę
            }
            System.out.println("i = " + i);
        }
        // Wypisze: 0, 1, 2, 3, 4
        
        // continue - przejście do następnej iteracji
        for (int i = 0; i < 10; i++) {
            if (i % 2 == 0) {
                continue;  // Pomija resztę iteracji dla parzystych
            }
            System.out.println("Nieparzyste: " + i);
        }
        // Wypisze: 1, 3, 5, 7, 9
        
        // Etykiety dla zagnieżdżonych pętli
        outer: for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (i == 1 && j == 1) {
                    break outer;  // Przerywa zewnętrzną pętlę
                }
                System.out.println("i=" + i + ", j=" + j);
            }
        }
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Pętla nieskończona**

```java
// ŹLE - pętla nieskończona!
int i = 0;
while (i < 10) {
    System.out.println(i);
    // Zapomniałaś zwiększyć i!
}

// DOBRZE
int i = 0;
while (i < 10) {
    System.out.println(i);
    i++;  // Pamiętaj o zmianie warunku!
}
```

**Pułapka 2: Off-by-one error**

```java
int[] tablica = {1, 2, 3, 4, 5};

// ŹLE - IndexOutOfBoundsException!
for (int i = 0; i <= tablica.length; i++) {
    System.out.println(tablica[i]);
}

// DOBRZE
for (int i = 0; i < tablica.length; i++) {
    System.out.println(tablica[i]);
}

// JESZCZE LEPIEJ - for-each
for (int element : tablica) {
    System.out.println(element);
}
```

**Pułapka 3: Modyfikacja kolekcji podczas iteracji**

```java
List<String> lista = new ArrayList<>(Arrays.asList("a", "b", "c"));

// ŹLE - ConcurrentModificationException!
for (String element : lista) {
    if (element.equals("b")) {
        lista.remove(element);  // Nie rób tego!
    }
}

// DOBRZE - użyj Iterator
Iterator<String> iterator = lista.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    if (element.equals("b")) {
        iterator.remove();  // Bezpieczne usuwanie
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Używaj for-each** gdy nie potrzebujesz indeksu
- **Sprawdzaj warunki zakończenia** - unikaj pętli nieskończonych
- **Pamiętaj o break i continue** - mogą uprościć logikę
- **Uważaj na modyfikację kolekcji** podczas iteracji
- **Używaj opisowych nazw zmiennych** zamiast `i`, `j`, `k`

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz program, który oblicza silnię liczby używając pętli.

```java
public static long silnia(int n) {
    // Twoja implementacja
}
```

**Zadanie 2:** Stwórz metodę, która znajdzie największy element w tablicy używając pętli for-each.

**Zadanie 3:** Napisz program, który wypisuje tabliczkę mnożenia dla liczby podanej przez użytkownika.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest różnica między pętlą `while` a `do-while`?
2. Kiedy lepiej użyć pętli `for`, a kiedy `for-each`?
3. Co robi instrukcja `continue` w pętli?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Pętle w Javie to nie tylko konstrukcje syntaktyczne - to fundamentalne elementy kontroli przepływu, które mają głębokie implikacje dla wydajności, bezpieczeństwa i czytelności kodu. JVM wykonuje zaawansowane optymalizacje pętli, które mogą dramatycznie wpłynąć na performance aplikacji.

##### Optymalizacje JVM dla pętli

```java
public class OptymalizacjePetli {
    // Loop unrolling - JVM może "rozwinąć" małe pętle
    public int simpleLoop() {
        int sum = 0;
        for (int i = 0; i < 4; i++) {
            sum += i;
        }
        // JVM może to zoptymalizować do: sum = 0 + 1 + 2 + 3;
        return sum;
    }
    
    // Loop hoisting - wynoszenie niezmiennych obliczeń poza pętlę
    public void loopHoisting(List<String> items) {
        // Źle - size() wywoływane w każdej iteracji
        for (int i = 0; i < items.size(); i++) {
            process(items.get(i));
        }
        
        // Lepiej - JVM może to zoptymalizować automatycznie
        int size = items.size();
        for (int i = 0; i < size; i++) {
            process(items.get(i));
        }
    }
    
    // Vectorization - SIMD instructions dla prostych pętli
    public void vectorizableLoop(int[] array) {
        // Ta pętla może być zwektoryzowana przez JVM
        for (int i = 0; i < array.length; i++) {
            array[i] = array[i] * 2;
        }
    }
    
    // Loop peeling - optymalizacja pierwszej/ostatniej iteracji
    public int loopPeeling(int[] array) {
        int sum = 0;
        for (int i = 0; i < array.length; i++) {
            if (i == 0) {
                // Specjalna logika dla pierwszego elementu
                sum += array[i] * 10;
            } else {
                sum += array[i];
            }
        }
        // JVM może "oderwać" pierwszą iterację od reszty
        return sum;
    }
    
    private void process(String item) { /* implementation */ }
}
```

##### Zaawansowane wzorce iteracji

```java
public class ZaawansowaneWzorce {
    // Iterator pattern z custom implementation
    public static class Range implements Iterable<Integer> {
        private final int start;
        private final int end;
        private final int step;
        
        public Range(int start, int end, int step) {
            this.start = start;
            this.end = end;
            this.step = step;
        }
        
        @Override
        public Iterator<Integer> iterator() {
            return new Iterator<Integer>() {
                private int current = start;
                
                @Override
                public boolean hasNext() {
                    return step > 0 ? current < end : current > end;
                }
                
                @Override
                public Integer next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    int result = current;
                    current += step;
                    return result;
                }
            };
        }
    }
    
    // Użycie custom iterator
    public void demonstrateCustomIterator() {
        // Elegancka iteracja z krokiem
        for (int i : new Range(0, 100, 5)) {
            System.out.println(i);  // 0, 5, 10, 15, ...
        }
        
        // Iteracja wsteczna
        for (int i : new Range(10, 0, -1)) {
            System.out.println(i);  // 10, 9, 8, 7, ...
        }
    }
    
    // Parallel iteration patterns
    public void parallelIteration() {
        List<Integer> numbers = IntStream.range(0, 1_000_000)
            .boxed()
            .collect(Collectors.toList());
        
        // Sequential processing
        long sequentialSum = numbers.stream()
            .mapToLong(Integer::longValue)
            .sum();
        
        // Parallel processing
        long parallelSum = numbers.parallelStream()
            .mapToLong(Integer::longValue)
            .sum();
        
        // Custom parallel processing z ForkJoinPool
        ForkJoinPool customThreadPool = new ForkJoinPool(4);
        try {
            long customParallelSum = customThreadPool.submit(() ->
                numbers.parallelStream()
                    .mapToLong(Integer::longValue)
                    .sum()
            ).get();
        } catch (InterruptedException | ExecutionException e) {
            Thread.currentThread().interrupt();
        } finally {
            customThreadPool.shutdown();
        }
    }
}
```

##### Memory access patterns i cache efficiency

```java
public class CacheEfficiency {
    // Cache-friendly iteration (row-major order)
    public void cacheEfficientIteration(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Dobrze - iteracja po wierszach (cache-friendly)
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                matrix[i][j] = i * j;
            }
        }
    }
    
    // Cache-unfriendly iteration (column-major order)
    public void cacheUnfriendlyIteration(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Źle - iteracja po kolumnach (cache-unfriendly)
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                matrix[i][j] = i * j;
            }
        }
    }
    
    // Loop blocking dla dużych struktur danych
    public void blockedMatrixMultiplication(double[][] A, double[][] B, double[][] C) {
        int n = A.length;
        int blockSize = 64;  // Dopasowane do cache line
        
        for (int ii = 0; ii < n; ii += blockSize) {
            for (int jj = 0; jj < n; jj += blockSize) {
                for (int kk = 0; kk < n; kk += blockSize) {
                    // Blok operacji na mniejszych fragmentach
                    for (int i = ii; i < Math.min(ii + blockSize, n); i++) {
                        for (int j = jj; j < Math.min(jj + blockSize, n); j++) {
                            for (int k = kk; k < Math.min(kk + blockSize, n); k++) {
                                C[i][j] += A[i][k] * B[k][j];
                            }
                        }
                    }
                }
            }
        }
    }
}
```

#### Pułapki i niuanse

##### Concurrent modification i thread safety

```java
public class ConcurrentModification {
    private final List<String> sharedList = new ArrayList<>();
    
    // Race condition w pętlach
    public void unsafeIteration() {
        // Thread 1 - iteracja
        for (String item : sharedList) {
            processItem(item);
        }
        
        // Thread 2 - modyfikacja (może spowodować ConcurrentModificationException)
        sharedList.add("new item");
    }
    
    // Bezpieczne podejścia
    public void safeIteration1() {
        // Kopia defensywna
        List<String> copy = new ArrayList<>(sharedList);
        for (String item : copy) {
            processItem(item);
        }
    }
    
    public void safeIteration2() {
        // Synchronizacja
        synchronized (sharedList) {
            for (String item : sharedList) {
                processItem(item);
            }
        }
    }
    
    public void safeIteration3() {
        // CopyOnWriteArrayList dla read-heavy scenarios
        CopyOnWriteArrayList<String> concurrentList = new CopyOnWriteArrayList<>(sharedList);
        for (String item : concurrentList) {
            processItem(item);  // Bezpieczne nawet przy concurrent modifications
        }
    }
    
    private void processItem(String item) { /* implementation */ }
}
```

##### Performance anti-patterns

```java
public class PerformanceAntiPatterns {
    // Anti-pattern: String concatenation w pętli
    public String badStringConcatenation(List<String> items) {
        String result = "";
        for (String item : items) {
            result += item;  // Tworzy nowy String w każdej iteracji!
        }
        return result;
    }
    
    // Lepiej: StringBuilder
    public String goodStringConcatenation(List<String> items) {
        StringBuilder sb = new StringBuilder();
        for (String item : items) {
            sb.append(item);
        }
        return sb.toString();
    }
    
    // Jeszcze lepiej: String.join lub Streams
    public String bestStringConcatenation(List<String> items) {
        return String.join("", items);
        // lub: items.stream().collect(Collectors.joining());
    }
    
    // Anti-pattern: Autoboxing w pętlach
    public void badAutoboxing() {
        List<Integer> numbers = new ArrayList<>();
        Integer sum = 0;  // Wrapper type!
        for (Integer num : numbers) {
            sum += num;  // Unboxing + boxing w każdej iteracji
        }
    }
    
    // Lepiej: Primitive types
    public void goodPrimitives() {
        List<Integer> numbers = new ArrayList<>();
        int sum = 0;  // Primitive type
        for (Integer num : numbers) {
            sum += num;  // Tylko unboxing
        }
    }
    
    // Anti-pattern: Nested loops z O(n²) complexity
    public boolean badContainsCheck(List<String> list1, List<String> list2) {
        for (String item1 : list1) {
            for (String item2 : list2) {  // O(n²)
                if (item1.equals(item2)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    // Lepiej: Set dla O(1) lookup
    public boolean goodContainsCheck(List<String> list1, List<String> list2) {
        Set<String> set2 = new HashSet<>(list2);  // O(n)
        for (String item1 : list1) {  // O(n)
            if (set2.contains(item1)) {  // O(1)
                return true;
            }
        }
        return false;
    }
}
```

##### Advanced loop constructs

```java
public class AdvancedLoopConstructs {
    // Functional-style loops z Streams
    public void functionalLoops() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Tradycyjna pętla
        List<Integer> doubled = new ArrayList<>();
        for (Integer num : numbers) {
            if (num % 2 == 0) {
                doubled.add(num * 2);
            }
        }
        
        // Functional approach
        List<Integer> functionalDoubled = numbers.stream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * 2)
            .collect(Collectors.toList());
        
        // Parallel processing
        List<Integer> parallelDoubled = numbers.parallelStream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * 2)
            .collect(Collectors.toList());
    }
    
    // Custom loop constructs
    public static void times(int count, Runnable action) {
        for (int i = 0; i < count; i++) {
            action.run();
        }
    }
    
    public static <T> void forEach(Iterable<T> items, Consumer<T> action) {
        for (T item : items) {
            action.accept(item);
        }
    }
    
    public static <T> void forEachWithIndex(List<T> items, BiConsumer<Integer, T> action) {
        for (int i = 0; i < items.size(); i++) {
            action.accept(i, items.get(i));
        }
    }
    
    // Użycie custom constructs
    public void demonstrateCustomLoops() {
        // Repeat action
        times(5, () -> System.out.println("Hello"));
        
        // Enhanced forEach
        List<String> names = Arrays.asList("Anna", "Kasia", "Ola");
        forEach(names, name -> System.out.println("Hello " + name));
        
        // forEach with index
        forEachWithIndex(names, (index, name) -> 
            System.out.println(index + ": " + name));
    }
}
```

#### Wzorce i best practices

##### Loop invariant pattern

```java
public class LoopInvariant {
    // Binary search z loop invariant
    public int binarySearch(int[] sortedArray, int target) {
        int left = 0;
        int right = sortedArray.length - 1;
        
        // Loop invariant: jeśli target istnieje, to jest w przedziale [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;  // Unikamy overflow
            
            if (sortedArray[mid] == target) {
                return mid;
            } else if (sortedArray[mid] < target) {
                left = mid + 1;  // Zachowujemy invariant
            } else {
                right = mid - 1;  // Zachowujemy invariant
            }
        }
        
        return -1;  // Nie znaleziono
    }
    
    // Partition algorithm z loop invariant
    public int partition(int[] array, int low, int high) {
        int pivot = array[high];
        int i = low - 1;
        
        // Loop invariant: 
        // - array[low..i] zawiera elementy <= pivot
        // - array[i+1..j-1] zawiera elementy > pivot
        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }
        
        swap(array, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```

##### Producer-Consumer pattern z pętlami

```java
public class ProducerConsumer {
    private final BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);
    private volatile boolean running = true;
    
    // Producer loop
    public void producer() {
        int counter = 0;
        while (running) {
            try {
                String item = "Item " + counter++;
                queue.put(item);  // Blocking put
                Thread.sleep(100);  // Simulate work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    // Consumer loop
    public void consumer() {
        while (running || !queue.isEmpty()) {
            try {
                String item = queue.poll(1, TimeUnit.SECONDS);  // Timeout poll
                if (item != null) {
                    processItem(item);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    // Batch processing loop
    public void batchConsumer() {
        List<String> batch = new ArrayList<>();
        while (running || !queue.isEmpty()) {
            try {
                // Zbierz batch
                queue.drainTo(batch, 10);  // Max 10 items
                
                if (!batch.isEmpty()) {
                    processBatch(batch);
                    batch.clear();
                }
                
                if (batch.isEmpty()) {
                    Thread.sleep(100);  // Wait if no items
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private void processItem(String item) { /* implementation */ }
    private void processBatch(List<String> batch) { /* implementation */ }
    
    public void stop() {
        running = false;
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj cache-efficient matrix transpose algorithm, który minimalizuje cache misses przez odpowiednie wzorce dostępu do pamięci.

**Zadanie Zaawansowane 2:** Stwórz thread-safe iterator pool, który pozwala na bezpieczną iterację po kolekcji w środowisku wielowątkowym z możliwością concurrent modifications.

**Zadanie Zaawansowane 3:** Zaprojektuj adaptive loop unrolling system, który dynamicznie dostosowuje stopień rozwinięcia pętli na podstawie charakterystyki danych wejściowych.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jakie optymalizacje JVM może zastosować do pętli i jak można je wspomóc w kodzie?
2. Dlaczego cache locality jest ważna w pętlach i jak projektować cache-friendly algorithms?
3. Jakie są trade-offs między sequential a parallel processing w pętlach?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static long silnia(int n) {
    if (n < 0) {
        throw new IllegalArgumentException("Silnia nie jest zdefiniowana dla liczb ujemnych");
    }
    
    long wynik = 1;
    for (int i = 1; i <= n; i++) {
        wynik *= i;
    }
    return wynik;
}

// Test:
System.out.println(silnia(5)); // 120
System.out.println(silnia(0)); // 1
```

**Zadanie 2:**
```java
public static int znajdzNajwiekszy(int[] tablica) {
    if (tablica.length == 0) {
        throw new IllegalArgumentException("Tablica nie może być pusta");
    }
    
    int najwiekszy = tablica[0];
    for (int element : tablica) {
        if (element > najwiekszy) {
            najwiekszy = element;
        }
    }
    return najwiekszy;
}

// Test:
int[] liczby = {3, 7, 2, 9, 1, 5};
System.out.println(znajdzNajwiekszy(liczby)); // 9
```

**Zadanie 3:**
```java
public static void tabliczkaMnozenia(int liczba) {
    System.out.println("Tabliczka mnożenia dla " + liczba + ":");
    for (int i = 1; i <= 10; i++) {
        int wynik = liczba * i;
        System.out.println(liczba + " x " + i + " = " + wynik);
    }
}

// Test:
tabliczkaMnozenia(7);
// Wypisze: 7 x 1 = 7, 7 x 2 = 14, ..., 7 x 10 = 70
```

**Pytania kontrolne:**
1. `while` sprawdza warunek przed wykonaniem, `do-while` wykonuje kod przynajmniej raz, potem sprawdza warunek.
2. `for` gdy potrzebujesz indeksu lub określonej liczby iteracji, `for-each` gdy iterujesz po wszystkich elementach kolekcji.
3. `continue` pomija resztę bieżącej iteracji i przechodzi do następnej iteracji pętli.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class CacheEfficientTranspose {
    // Naive transpose - cache unfriendly
    public static void naiveTranspose(double[][] matrix, double[][] result) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[j][i] = matrix[i][j];  // Poor cache locality
            }
        }
    }
    
    // Cache-efficient blocked transpose
    public static void blockedTranspose(double[][] matrix, double[][] result) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int blockSize = 64;  // Tuned for cache line size
        
        for (int ii = 0; ii < rows; ii += blockSize) {
            for (int jj = 0; jj < cols; jj += blockSize) {
                // Transpose block
                int maxI = Math.min(ii + blockSize, rows);
                int maxJ = Math.min(jj + blockSize, cols);
                
                for (int i = ii; i < maxI; i++) {
                    for (int j = jj; j < maxJ; j++) {
                        result[j][i] = matrix[i][j];
                    }
                }
            }
        }
    }
    
    // In-place transpose for square matrices
    public static void inPlaceTranspose(double[][] matrix) {
        int n = matrix.length;
        int blockSize = 32;
        
        for (int ii = 0; ii < n; ii += blockSize) {
            for (int jj = ii; jj < n; jj += blockSize) {
                int maxI = Math.min(ii + blockSize, n);
                int maxJ = Math.min(jj + blockSize, n);
                
                for (int i = ii; i < maxI; i++) {
                    int startJ = (ii == jj) ? i + 1 : jj;  // Avoid double swap
                    for (int j = startJ; j < maxJ; j++) {
                        // Swap elements
                        double temp = matrix[i][j];
                        matrix[i][j] = matrix[j][i];
                        matrix[j][i] = temp;
                    }
                }
            }
        }
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class ThreadSafeIteratorPool {
    private final ConcurrentLinkedQueue<SafeIterator<?>> pool = new ConcurrentLinkedQueue<>();
    private final int maxPoolSize;
    
    public ThreadSafeIteratorPool(int maxPoolSize) {
        this.maxPoolSize = maxPoolSize;
    }
    
    public <T> SafeIterator<T> borrowIterator(Collection<T> collection) {
        SafeIterator<T> iterator = (SafeIterator<T>) pool.poll();
        if (iterator == null) {
            iterator = new SafeIterator<>();
        }
        iterator.reset(collection);
        return iterator;
    }
    
    public void returnIterator(SafeIterator<?> iterator) {
        if (pool.size() < maxPoolSize) {
            iterator.clear();
            pool.offer(iterator);
        }
    }
    
    public static class SafeIterator<T> implements Iterator<T> {
        private volatile List<T> snapshot;
        private volatile int position;
        private final AtomicInteger version = new AtomicInteger();
        
        public void reset(Collection<T> collection) {
            this.snapshot = new ArrayList<>(collection);
            this.position = 0;
            this.version.incrementAndGet();
        }
        
        @Override
        public boolean hasNext() {
            return position < snapshot.size();
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            return snapshot.get(position++);
        }
        
        public void clear() {
            this.snapshot = null;
            this.position = 0;
        }
        
        // Thread-safe forEach
        public void forEach(Consumer<T> action) {
            List<T> currentSnapshot = this.snapshot;
            if (currentSnapshot != null) {
                for (T item : currentSnapshot) {
                    action.accept(item);
                }
            }
        }
    }
    
    // Usage example
    public void demonstrateUsage() {
        ThreadSafeIteratorPool pool = new ThreadSafeIteratorPool(10);
        List<String> sharedList = new CopyOnWriteArrayList<>();
        
        // Thread 1 - iteration
        SafeIterator<String> iterator = pool.borrowIterator(sharedList);
        try {
            iterator.forEach(System.out::println);
        } finally {
            pool.returnIterator(iterator);
        }
        
        // Thread 2 - modification (safe)
        sharedList.add("new item");
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class AdaptiveLoopUnroller {
    private static final int MIN_UNROLL_FACTOR = 2;
    private static final int MAX_UNROLL_FACTOR = 8;
    private static final int SAMPLE_SIZE = 1000;
    
    public static class UnrollStrategy {
        private final int unrollFactor;
        private final long avgExecutionTime;
        
        public UnrollStrategy(int unrollFactor, long avgExecutionTime) {
            this.unrollFactor = unrollFactor;
            this.avgExecutionTime = avgExecutionTime;
        }
        
        public int getUnrollFactor() { return unrollFactor; }
        public long getAvgExecutionTime() { return avgExecutionTime; }
    }
    
    public static UnrollStrategy findOptimalUnrollFactor(int[] data, IntUnaryOperator operation) {
        UnrollStrategy bestStrategy = null;
        long bestTime = Long.MAX_VALUE;
        
        for (int factor = MIN_UNROLL_FACTOR; factor <= MAX_UNROLL_FACTOR; factor *= 2) {
            long totalTime = 0;
            
            // Benchmark multiple runs
            for (int run = 0; run < 5; run++) {
                long startTime = System.nanoTime();
                executeUnrolledLoop(data, operation, factor);
                long endTime = System.nanoTime();
                totalTime += (endTime - startTime);
            }
            
            long avgTime = totalTime / 5;
            if (avgTime < bestTime) {
                bestTime = avgTime;
                bestStrategy = new UnrollStrategy(factor, avgTime);
            }
        }
        
        return bestStrategy;
    }
    
    private static void executeUnrolledLoop(int[] data, IntUnaryOperator operation, int unrollFactor) {
        int length = data.length;
        int unrolledLength = (length / unrollFactor) * unrollFactor;
        
        // Unrolled loop
        for (int i = 0; i < unrolledLength; i += unrollFactor) {
            switch (unrollFactor) {
                case 8:
                    data[i + 7] = operation.applyAsInt(data[i + 7]);
                case 7:
                    data[i + 6] = operation.applyAsInt(data[i + 6]);
                case 6:
                    data[i + 5] = operation.applyAsInt(data[i + 5]);
                case 5:
                    data[i + 4] = operation.applyAsInt(data[i + 4]);
                case 4:
                    data[i + 3] = operation.applyAsInt(data[i + 3]);
                case 3:
                    data[i + 2] = operation.applyAsInt(data[i + 2]);
                case 2:
                    data[i + 1] = operation.applyAsInt(data[i + 1]);
                case 1:
                    data[i] = operation.applyAsInt(data[i]);
            }
        }
        
        // Handle remaining elements
        for (int i = unrolledLength; i < length; i++) {
            data[i] = operation.applyAsInt(data[i]);
        }
    }
    
    // Adaptive processor that learns optimal unroll factor
    public static class AdaptiveProcessor {
        private final Map<String, UnrollStrategy> strategyCache = new ConcurrentHashMap<>();
        
        public void processArray(int[] data, IntUnaryOperator operation, String operationId) {
            UnrollStrategy strategy = strategyCache.computeIfAbsent(operationId, 
                id -> findOptimalUnrollFactor(Arrays.copyOf(data, Math.min(data.length, SAMPLE_SIZE)), operation));
            
            executeUnrolledLoop(data, operation, strategy.getUnrollFactor());
        }
    }
}
```

**Pytania kontrolne:**
1. JVM może zastosować loop unrolling, hoisting, vectorization, peeling. Można pomóc przez unikanie side effects, używanie final variables, i pisanie prostych loop bodies.
2. Cache locality redukuje cache misses. Projektuj algorithms iterując po danych w kolejności ich układu w pamięci (row-major dla arrays), używaj loop blocking dla dużych struktur.
3. Sequential: prostsze, deterministyczne, mniejszy overhead. Parallel: szybsze dla CPU-intensive tasks, ale wymaga thread-safe operations i może mieć overhead synchronizacji.

---

#### 📚 Co dalej?

*Świetnie! Teraz masz pełne zrozumienie pętli w Javie - od podstawowych for i while po zaawansowane optymalizacje i wzorce. Pętle to narzędzie, które będziesz używać codziennie, więc warto je znać na wylot. W następnym rozdziale porozmawiamy o String - czyli o tym, co można robić z tekstem (a to naprawdę dużo!) plus poznamy nowoczesne API, które Java ma do zaoferowania!*

---

*💡 Pamiętaj: Dobra pętla to taka, która robi dokładnie to, co powinna, ani więcej, ani mniej. Myśl o wydajności, ale nie kosztem czytelności!*


## 7. String: co można robić z tekstem (dużo!) + nowoczesne API

*Cześć! Dziś porozmawiamy o String - jednej z najważniejszych klas w Javie. Może się wydawać, że tekst to tekst, ale String w Javie to prawdziwy szwajcarski scyzoryk do pracy z tekstem. Od podstawowych operacji po nowoczesne API wprowadzone w najnowszych wersjach Javy - przygotuj się na odkrycie wszystkich możliwości, jakie daje Ci praca z tekstem!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

String w Javie to obiekt reprezentujący sekwencję znaków. Ale uwaga - String jest **immutable** (niezmienialny), co oznacza, że raz utworzony String nigdy się nie zmienia. Każda "modyfikacja" tworzy nowy obiekt String.

```java
String imie = "Anna";
String powitanie = "Cześć " + imie + "!";  // Tworzy nowy String
System.out.println(powitanie);  // "Cześć Anna!"

// imie nadal zawiera "Anna" - nie zmienił się!
```

#### Dlaczego to ważne?

String to podstawa komunikacji w każdej aplikacji. Czy to nazwy użytkowników, komunikaty błędów, czy dane z plików - wszystko to tekst. Umiejętność efektywnej pracy ze String pozwala tworzyć czytelne, wydajne i bezpieczne aplikacje.

#### Jak to działa w praktyce?

**Podstawowe operacje na String:**

```java
public class PodstawoweOperacje {
    public static void main(String[] args) {
        String tekst = "Java Programming";
        
        // Długość
        System.out.println("Długość: " + tekst.length());  // 16
        
        // Pobieranie znaków
        System.out.println("Pierwszy znak: " + tekst.charAt(0));  // 'J'
        System.out.println("Ostatni znak: " + tekst.charAt(tekst.length() - 1));  // 'g'
        
        // Podciągi
        System.out.println("Podciąg: " + tekst.substring(5));     // "Programming"
        System.out.println("Podciąg: " + tekst.substring(0, 4));  // "Java"
        
        // Wyszukiwanie
        System.out.println("Indeks 'P': " + tekst.indexOf('P'));        // 5
        System.out.println("Indeks 'gram': " + tekst.indexOf("gram"));   // 8
        System.out.println("Ostatni 'a': " + tekst.lastIndexOf('a'));   // 3
        
        // Sprawdzanie zawartości
        System.out.println("Zawiera 'Java': " + tekst.contains("Java"));     // true
        System.out.println("Zaczyna się od 'Java': " + tekst.startsWith("Java")); // true
        System.out.println("Kończy się na 'ing': " + tekst.endsWith("ing"));     // true
    }
}
```

**Porównywanie String:**

```java
public class PorownywanieString {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "Hello";
        String s3 = new String("Hello");
        String s4 = "hello";
        
        // Porównywanie referencji vs zawartości
        System.out.println("s1 == s2: " + (s1 == s2));         // true (string pool)
        System.out.println("s1 == s3: " + (s1 == s3));         // false (różne obiekty)
        System.out.println("s1.equals(s3): " + s1.equals(s3)); // true (ta sama zawartość)
        
        // Porównywanie z ignorowaniem wielkości liter
        System.out.println("s1.equalsIgnoreCase(s4): " + s1.equalsIgnoreCase(s4)); // true
        
        // Porównywanie leksykograficzne
        System.out.println("s1.compareTo(s4): " + s1.compareTo(s4));  // ujemna (H < h w ASCII)
        System.out.println("s1.compareToIgnoreCase(s4): " + s1.compareToIgnoreCase(s4)); // 0
        
        // Bezpieczne porównywanie z null
        String nullString = null;
        System.out.println("Objects.equals: " + Objects.equals(s1, nullString)); // false
    }
}
```

**Modyfikowanie String (tworzenie nowych):**

```java
public class ModyfikowanieString {
    public static void main(String[] args) {
        String tekst = "  Java Programming  ";
        
        // Zmiana wielkości liter
        System.out.println("Wielkie: " + tekst.toUpperCase());    // "  JAVA PROGRAMMING  "
        System.out.println("Małe: " + tekst.toLowerCase());       // "  java programming  "
        
        // Usuwanie białych znaków
        System.out.println("Trim: '" + tekst.trim() + "'");       // "Java Programming"
        
        // Zastępowanie
        System.out.println("Replace: " + tekst.replace("Java", "Python"));  // "  Python Programming  "
        System.out.println("ReplaceAll: " + tekst.replaceAll("\\s+", "-")); // "--Java-Programming--"
        
        // Dzielenie
        String csv = "Anna,Kasia,Ola,Magda";
        String[] imiona = csv.split(",");
        for (String imie : imiona) {
            System.out.println("Imię: " + imie);
        }
        
        // Łączenie
        String polaczone = String.join(" | ", imiona);
        System.out.println("Połączone: " + polaczone);  // "Anna | Kasia | Ola | Magda"
    }
}
```

**Nowoczesne API String (Java 11+):**

```java
public class NowoczesneStringAPI {
    public static void main(String[] args) {
        // isBlank() - sprawdza czy String jest pusty lub zawiera tylko białe znaki
        String pusty = "";
        String biale = "   ";
        String tekst = "Java";
        
        System.out.println("pusty.isEmpty(): " + pusty.isEmpty());     // true
        System.out.println("pusty.isBlank(): " + pusty.isBlank());     // true
        System.out.println("biale.isEmpty(): " + biale.isEmpty());     // false
        System.out.println("biale.isBlank(): " + biale.isBlank());     // true
        
        // strip() - lepszy trim (obsługuje Unicode whitespace)
        String unicode = "\u2000Java\u2000";  // Unicode spaces
        System.out.println("trim: '" + unicode.trim() + "'");     // Może nie usunąć wszystkich
        System.out.println("strip: '" + unicode.strip() + "'");   // Usuwa wszystkie Unicode spaces
        System.out.println("stripLeading: '" + unicode.stripLeading() + "'");
        System.out.println("stripTrailing: '" + unicode.stripTrailing() + "'");
        
        // repeat() - powtarzanie String
        String gwiazdki = "*".repeat(10);
        System.out.println(gwiazdki);  // "**********"
        
        String linia = "-".repeat(20);
        System.out.println(linia);     // "--------------------"
        
        // lines() - dzielenie na linie
        String wielolinijkowy = "Pierwsza linia\nDruga linia\nTrzecia linia";
        wielolinijkowy.lines()
            .forEach(System.out::println);
    }
}
```

#### Formatowanie String

```java
public class FormatowanieString {
    public static void main(String[] args) {
        String imie = "Anna";
        int wiek = 25;
        double wzrost = 165.5;
        
        // String.format() - jak printf w C
        String sformatowany = String.format("Cześć %s! Masz %d lat i %,.1f cm wzrostu.", 
                                           imie, wiek, wzrost);
        System.out.println(sformatowany);
        
        // formatted() - metoda instancyjna (Java 15+)
        String szablon = "Cześć %s! Masz %d lat.";
        String wynik = szablon.formatted(imie, wiek);
        System.out.println(wynik);
        
        // Różne formaty
        double liczba = 1234.5678;
        System.out.println(String.format("Domyślnie: %f", liczba));        // 1234.567800
        System.out.println(String.format("2 miejsca: %.2f", liczba));      // 1234.57
        System.out.println(String.format("Z separatorami: %,.2f", liczba)); // 1,234.57
        System.out.println(String.format("Padding: %10.2f", liczba));      // "   1234.57"
        System.out.println(String.format("Zero padding: %010.2f", liczba)); // "0001234.57"
        
        // Formatowanie dat
        LocalDateTime teraz = LocalDateTime.now();
        System.out.println(String.format("Data: %tF %tT", teraz, teraz));
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Konkatenacja w pętlach**

```java
// ŹLE - bardzo wolne!
String wynik = "";
for (int i = 0; i < 1000; i++) {
    wynik += "element " + i + ", ";  // Tworzy nowy String w każdej iteracji!
}

// DOBRZE - użyj StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append("element ").append(i).append(", ");
}
String wynik = sb.toString();
```

**Pułapka 2: Porównywanie z ==**

```java
String s1 = new String("Hello");
String s2 = new String("Hello");
if (s1 == s2) {  // ŹLE! Porównuje referencje
    System.out.println("Nigdy się nie wykona");
}

if (s1.equals(s2)) {  // DOBRZE!
    System.out.println("To się wykona");
}
```

**Pułapka 3: NullPointerException**

```java
String tekst = null;
if (tekst.equals("Hello")) {  // ŹLE - NPE!
    System.out.println("Nigdy się nie wykona");
}

// DOBRZE - bezpieczne podejścia:
if ("Hello".equals(tekst)) {  // Bezpieczne
    System.out.println("To jest bezpieczne");
}

if (Objects.equals(tekst, "Hello")) {  // Też bezpieczne
    System.out.println("To też jest bezpieczne");
}
```

#### 💡 Wskazówki dla Juniorek

- **Używaj `equals()`** do porównywania String, nie `==`
- **StringBuilder** dla wielu konkatenacji, zwykły `+` dla pojedynczych
- **Sprawdzaj null** przed wywołaniem metod na String
- **Używaj nowoczesnego API** - `isBlank()`, `strip()`, `repeat()`
- **String.format()** dla złożonego formatowania

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz metodę, która sprawdza, czy podany String jest palindromem (czyta się tak samo od przodu i od tyłu).

```java
public static boolean czyPalindrom(String tekst) {
    // Twoja implementacja (ignoruj wielkość liter i spacje)
}
```

**Zadanie 2:** Stwórz metodę, która zlicza wystąpienia każdej litery w tekście.

**Zadanie 3:** Napisz funkcję, która "maskuje" numer karty kredytowej, pokazując tylko ostatnie 4 cyfry.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Dlaczego String jest immutable i jakie to ma konsekwencje?
2. Jaka jest różnica między `trim()` a `strip()`?
3. Kiedy używać `StringBuilder` zamiast konkatenacji z `+`?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

String w Javie to znacznie więcej niż prosta reprezentacja tekstu. To jedna z najbardziej zoptymalizowanych klas w JDK, z wieloma ukrytymi mechanizmami optymalizacji, które wpływają na wydajność i zużycie pamięci aplikacji.

##### Wewnętrzna reprezentacja String

```java
public class StringInternals {
    // Od Java 9: String używa byte[] zamiast char[]
    // Compact Strings optimization - Latin-1 vs UTF-16
    
    public void demonstrateStringCompaction() {
        String latin1 = "Hello";      // 1 byte per character
        String unicode = "Cześć";     // 2 bytes per character
        
        // JVM automatycznie wybiera reprezentację
        // Latin-1 dla ASCII, UTF-16 dla Unicode
        
        // Można sprawdzić używając reflection (nie rób tego w produkcji!)
        try {
            Field valueField = String.class.getDeclaredField("value");
            valueField.setAccessible(true);
            
            byte[] latin1Bytes = (byte[]) valueField.get(latin1);
            byte[] unicodeBytes = (byte[]) valueField.get(unicode);
            
            System.out.println("Latin1 bytes: " + latin1Bytes.length);  // 5
            System.out.println("Unicode bytes: " + unicodeBytes.length); // 10 (2 * 5)
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

##### String Pool i interning

```java
public class StringPoolAnalysis {
    public void demonstrateStringPool() {
        // String literals trafiają do String Pool
        String s1 = "Hello";
        String s2 = "Hello";
        System.out.println(s1 == s2);  // true - ten sam obiekt z pool
        
        // new String() tworzy nowy obiekt
        String s3 = new String("Hello");
        System.out.println(s1 == s3);  // false - różne obiekty
        
        // intern() dodaje do pool lub zwraca istniejący
        String s4 = s3.intern();
        System.out.println(s1 == s4);  // true - s4 to obiekt z pool
        
        // Concatenation nie trafia do pool automatycznie
        String s5 = "Hel" + "lo";      // Compile-time constant - trafia do pool
        String s6 = "Hel" + new String("lo");  // Runtime - nie trafia do pool
        System.out.println(s1 == s5);  // true
        System.out.println(s1 == s6);  // false
    }
    
    // Custom string interning dla oszczędności pamięci
    private final Map<String, String> customPool = new ConcurrentHashMap<>();
    
    public String customIntern(String str) {
        return customPool.computeIfAbsent(str, Function.identity());
    }
    
    // Weak reference pool - pozwala na GC
    private final Map<String, WeakReference<String>> weakPool = new ConcurrentHashMap<>();
    
    public String weakIntern(String str) {
        WeakReference<String> ref = weakPool.get(str);
        String interned = (ref != null) ? ref.get() : null;
        
        if (interned == null) {
            interned = str;
            weakPool.put(str, new WeakReference<>(str));
        }
        
        return interned;
    }
}
```

##### Performance considerations

```java
public class StringPerformance {
    // String concatenation performance
    @Benchmark
    public String concatenationWithPlus() {
        String result = "";
        for (int i = 0; i < 1000; i++) {
            result += "item" + i;  // O(n²) complexity!
        }
        return result;
    }
    
    @Benchmark
    public String concatenationWithStringBuilder() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append("item").append(i);  // O(n) complexity
        }
        return sb.toString();
    }
    
    @Benchmark
    public String concatenationWithStringJoiner() {
        StringJoiner joiner = new StringJoiner("");
        for (int i = 0; i < 1000; i++) {
            joiner.add("item" + i);
        }
        return joiner.toString();
    }
    
    // String comparison performance
    @Benchmark
    public boolean equalsComparison(String s1, String s2) {
        return s1.equals(s2);  // Optimized for common cases
    }
    
    @Benchmark
    public boolean equalsIgnoreCaseComparison(String s1, String s2) {
        return s1.equalsIgnoreCase(s2);  // More expensive
    }
    
    // Substring performance (Java 7+ vs Java 6)
    public void demonstrateSubstringBehavior() {
        String large = "A".repeat(1_000_000);
        
        // Java 7+: substring tworzy nowy array
        String small = large.substring(0, 10);  // Nie trzyma referencji do large
        
        // W Java 6: substring dzielił array z oryginalnym String
        // Mogło powodować memory leaks
    }
}
```

##### Advanced String operations

```java
public class AdvancedStringOperations {
    // Efficient string searching - Boyer-Moore algorithm simulation
    public int efficientIndexOf(String text, String pattern) {
        // Simplified Boyer-Moore-like approach
        if (pattern.isEmpty()) return 0;
        if (text.length() < pattern.length()) return -1;
        
        // Build bad character table
        Map<Character, Integer> badChar = new HashMap<>();
        for (int i = 0; i < pattern.length(); i++) {
            badChar.put(pattern.charAt(i), i);
        }
        
        int shift = 0;
        while (shift <= text.length() - pattern.length()) {
            int j = pattern.length() - 1;
            
            while (j >= 0 && pattern.charAt(j) == text.charAt(shift + j)) {
                j--;
            }
            
            if (j < 0) {
                return shift;  // Found match
            } else {
                char badCharacter = text.charAt(shift + j);
                int badCharShift = badChar.getOrDefault(badCharacter, -1);
                shift += Math.max(1, j - badCharShift);
            }
        }
        
        return -1;  // Not found
    }
    
    // String similarity algorithms
    public int levenshteinDistance(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= s2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]);
                }
            }
        }
        
        return dp[s1.length()][s2.length()];
    }
    
    // Fuzzy string matching
    public double jaccardSimilarity(String s1, String s2) {
        Set<String> set1 = new HashSet<>();
        Set<String> set2 = new HashSet<>();
        
        // Create n-grams (bigrams in this case)
        for (int i = 0; i < s1.length() - 1; i++) {
            set1.add(s1.substring(i, i + 2));
        }
        for (int i = 0; i < s2.length() - 1; i++) {
            set2.add(s2.substring(i, i + 2));
        }
        
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        
        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();
    }
}
```

#### Pułapki i niuanse

##### Memory leaks z String

```java
public class StringMemoryLeaks {
    // Potential memory leak z substring (pre-Java 7)
    public class TokenHolder {
        private final String token;
        
        // Problematyczne w starych wersjach Java
        public TokenHolder(String largeDocument, int start, int end) {
            this.token = largeDocument.substring(start, end);
            // W Java 6: token dzielił char[] z largeDocument
            // Cały largeDocument nie mógł być GC'd
        }
        
        // Bezpieczna wersja
        public TokenHolder(String largeDocument, int start, int end) {
            this.token = new String(largeDocument.substring(start, end));
            // Tworzy nowy String z własnym char[]
        }
    }
    
    // String interning memory leak
    private final Set<String> internedStrings = new HashSet<>();
    
    public void problematicInterning(String userInput) {
        // NIGDY nie rób tego z user input!
        String interned = userInput.intern();
        internedStrings.add(interned);
        // String pool nigdy nie jest czyszczony - memory leak!
    }
    
    // Bezpieczna alternatywa
    private final Map<String, String> safeInternPool = new WeakHashMap<>();
    
    public String safeIntern(String str) {
        return safeInternPool.computeIfAbsent(str, Function.identity());
    }
}
```

##### Security considerations

```java
public class StringSecurity {
    // Password handling - String vs char[]
    public void demonstratePasswordSecurity() {
        // ŹLE - String jest immutable i może zostać w pamięci
        String password = "secretPassword123";
        // password może być widoczny w heap dump
        
        // DOBRZE - char[] można wyczyścić
        char[] passwordChars = "secretPassword123".toCharArray();
        try {
            // Użyj password
            authenticateUser(passwordChars);
        } finally {
            // Wyczyść pamięć
            Arrays.fill(passwordChars, '\0');
        }
    }
    
    // SQL Injection prevention
    public void safeDatabaseQuery(String userInput) {
        // ŹLE - podatne na SQL injection
        String unsafeQuery = "SELECT * FROM users WHERE name = '" + userInput + "'";
        
        // DOBRZE - prepared statements
        String safeQuery = "SELECT * FROM users WHERE name = ?";
        // Użyj PreparedStatement z parametrami
    }
    
    // XSS prevention
    public String escapeHtml(String input) {
        if (input == null) return null;
        
        return input.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#x27;");
    }
    
    private void authenticateUser(char[] password) {
        // Implementation
    }
}
```

##### Internationalization i Unicode

```java
public class StringInternationalization {
    // Unicode normalization
    public void demonstrateUnicodeNormalization() {
        // Te String mogą wyglądać identycznie, ale być różne
        String s1 = "café";  // é jako jeden znak
        String s2 = "cafe\u0301";  // e + combining acute accent
        
        System.out.println(s1.equals(s2));  // false!
        System.out.println(s1.length());    // 4
        System.out.println(s2.length());    // 5
        
        // Normalizacja Unicode
        String normalized1 = Normalizer.normalize(s1, Normalizer.Form.NFC);
        String normalized2 = Normalizer.normalize(s2, Normalizer.Form.NFC);
        System.out.println(normalized1.equals(normalized2));  // true
    }
    
    // Locale-sensitive operations
    public void demonstrateLocaleOperations() {
        String turkish = "İstanbul";
        
        // Problematyczne - używa domyślnego Locale
        String lower1 = turkish.toLowerCase();
        
        // Poprawne - explicit Locale
        String lower2 = turkish.toLowerCase(Locale.ENGLISH);
        String lower3 = turkish.toLowerCase(new Locale("tr", "TR"));
        
        System.out.println("Default: " + lower1);
        System.out.println("English: " + lower2);
        System.out.println("Turkish: " + lower3);
        // W tureckim 'İ' -> 'i', w angielskim 'İ' -> 'i̇'
    }
    
    // Collation for sorting
    public void demonstrateCollation() {
        List<String> names = Arrays.asList("Müller", "Mueller", "Møller");
        
        // Default sorting
        names.sort(String::compareTo);
        System.out.println("Default: " + names);
        
        // Locale-specific collation
        Collator germanCollator = Collator.getInstance(Locale.GERMAN);
        names.sort(germanCollator::compare);
        System.out.println("German: " + names);
        
        // Custom collation rules
        Collator customCollator = Collator.getInstance();
        customCollator.setStrength(Collator.PRIMARY);  // Ignore case and accents
        names.sort(customCollator::compare);
        System.out.println("Custom: " + names);
    }
}
```

#### Wzorce i best practices

##### String Builder patterns

```java
public class StringBuilderPatterns {
    // Fluent StringBuilder
    public static class FluentStringBuilder {
        private final StringBuilder sb = new StringBuilder();
        
        public FluentStringBuilder append(String str) {
            sb.append(str);
            return this;
        }
        
        public FluentStringBuilder appendLine(String str) {
            sb.append(str).append(System.lineSeparator());
            return this;
        }
        
        public FluentStringBuilder appendIf(boolean condition, String str) {
            if (condition) {
                sb.append(str);
            }
            return this;
        }
        
        public FluentStringBuilder repeat(String str, int times) {
            for (int i = 0; i < times; i++) {
                sb.append(str);
            }
            return this;
        }
        
        @Override
        public String toString() {
            return sb.toString();
        }
    }
    
    // Template pattern
    public static class StringTemplate {
        private final String template;
        private final Map<String, String> placeholders = new HashMap<>();
        
        public StringTemplate(String template) {
            this.template = template;
        }
        
        public StringTemplate set(String key, String value) {
            placeholders.put(key, value);
            return this;
        }
        
        public String build() {
            String result = template;
            for (Map.Entry<String, String> entry : placeholders.entrySet()) {
                result = result.replace("${" + entry.getKey() + "}", entry.getValue());
            }
            return result;
        }
    }
    
    // Usage examples
    public void demonstratePatterns() {
        // Fluent builder
        String html = new FluentStringBuilder()
            .append("<html>")
            .appendLine("<head><title>My Page</title></head>")
            .append("<body>")
            .appendIf(true, "<h1>Welcome!</h1>")
            .repeat("<p>Content</p>", 3)
            .append("</body></html>")
            .toString();
        
        // Template
        String email = new StringTemplate("Hello ${name}, your order ${orderId} is ready!")
            .set("name", "Anna")
            .set("orderId", "12345")
            .build();
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj wydajny algorytm wyszukiwania wzorca w tekście (np. KMP lub Boyer-Moore) i porównaj jego wydajność z wbudowanym `indexOf()`.

**Zadanie Zaawansowane 2:** Stwórz thread-safe String pool z automatycznym czyszczeniem nieużywanych String używając WeakReference i scheduled cleanup.

**Zadanie Zaawansowane 3:** Zaprojektuj system template'ów z obsługą zagnieżdżonych placeholder'ów, conditional blocks i loops, zoptymalizowany pod kątem wydajności.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak działa String pool i jakie są implikacje używania `intern()` w aplikacjach produkcyjnych?
2. Dlaczego String jest immutable i jakie optymalizacje JVM z tego wynikają?
3. Jakie są różnice w reprezentacji String między Java 8 a Java 9+ i jak wpływa to na zużycie pamięci?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static boolean czyPalindrom(String tekst) {
    if (tekst == null) return false;
    
    // Usuń spacje i zmień na małe litery
    String oczyszczony = tekst.replaceAll("\\s+", "").toLowerCase();
    
    int left = 0;
    int right = oczyszczony.length() - 1;
    
    while (left < right) {
        if (oczyszczony.charAt(left) != oczyszczony.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

// Test:
System.out.println(czyPalindrom("A man a plan a canal Panama")); // true
System.out.println(czyPalindrom("race a car")); // false
```

**Zadanie 2:**
```java
public static Map<Character, Integer> zliczLitery(String tekst) {
    Map<Character, Integer> licznik = new HashMap<>();
    
    for (char c : tekst.toLowerCase().toCharArray()) {
        if (Character.isLetter(c)) {
            licznik.put(c, licznik.getOrDefault(c, 0) + 1);
        }
    }
    
    return licznik;
}

// Test:
Map<Character, Integer> wynik = zliczLitery("Hello World");
wynik.forEach((litera, ilosc) -> 
    System.out.println(litera + ": " + ilosc));
```

**Zadanie 3:**
```java
public static String maskujKarte(String numerKarty) {
    if (numerKarty == null || numerKarty.length() < 4) {
        return numerKarty;
    }
    
    // Usuń wszystkie nie-cyfry
    String cyfry = numerKarty.replaceAll("\\D", "");
    
    if (cyfry.length() < 4) {
        return numerKarty;
    }
    
    String ostatnieCztery = cyfry.substring(cyfry.length() - 4);
    String maska = "*".repeat(cyfry.length() - 4);
    
    return maska + ostatnieCztery;
}

// Test:
System.out.println(maskujKarte("1234-5678-9012-3456")); // ************3456
System.out.println(maskujKarte("4111 1111 1111 1111")); // ************1111
```

**Pytania kontrolne:**
1. String jest immutable dla bezpieczeństwa (String pool, hash codes), thread safety i optymalizacji. Konsekwencja: każda "modyfikacja" tworzy nowy obiekt.
2. `trim()` usuwa tylko ASCII whitespace, `strip()` usuwa wszystkie Unicode whitespace characters.
3. StringBuilder gdy robisz wiele konkatenacji (szczególnie w pętlach), `+` dla pojedynczych operacji.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class KMPStringSearch {
    // Knuth-Morris-Pratt algorithm
    public static int kmpSearch(String text, String pattern) {
        if (pattern.isEmpty()) return 0;
        
        int[] lps = computeLPSArray(pattern);
        int i = 0; // index for text
        int j = 0; // index for pattern
        
        while (i < text.length()) {
            if (pattern.charAt(j) == text.charAt(i)) {
                i++;
                j++;
            }
            
            if (j == pattern.length()) {
                return i - j; // Found match
            } else if (i < text.length() && pattern.charAt(j) != text.charAt(i)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1; // Not found
    }
    
    private static int[] computeLPSArray(String pattern) {
        int[] lps = new int[pattern.length()];
        int len = 0;
        int i = 1;
        
        while (i < pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    // Benchmark comparison
    @Benchmark
    public int builtinIndexOf(String text, String pattern) {
        return text.indexOf(pattern);
    }
    
    @Benchmark
    public int kmpIndexOf(String text, String pattern) {
        return kmpSearch(text, pattern);
    }
}
```

**Zadanie Zaawansowane 2:**
```java
public class ThreadSafeStringPool {
    private final ConcurrentHashMap<String, WeakReference<String>> pool = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cleanupExecutor = Executors.newSingleThreadScheduledExecutor();
    private final AtomicLong accessCounter = new AtomicLong();
    
    public ThreadSafeStringPool() {
        // Cleanup co 5 minut
        cleanupExecutor.scheduleAtFixedRate(this::cleanup, 5, 5, TimeUnit.MINUTES);
    }
    
    public String intern(String str) {
        if (str == null) return null;
        
        accessCounter.incrementAndGet();
        
        return pool.compute(str, (key, ref) -> {
            String existing = (ref != null) ? ref.get() : null;
            if (existing != null) {
                return ref; // Reuse existing reference
            } else {
                return new WeakReference<>(str); // Create new reference
            }
        }).get();
    }
    
    private void cleanup() {
        int removed = 0;
        Iterator<Map.Entry<String, WeakReference<String>>> iterator = pool.entrySet().iterator();
        
        while (iterator.hasNext()) {
            Map.Entry<String, WeakReference<String>> entry = iterator.next();
            if (entry.getValue().get() == null) {
                iterator.remove();
                removed++;
            }
        }
        
        System.out.printf("Cleanup: removed %d entries, pool size: %d, total accesses: %d%n", 
                         removed, pool.size(), accessCounter.get());
    }
    
    public void shutdown() {
        cleanupExecutor.shutdown();
    }
    
    public int getPoolSize() {
        return pool.size();
    }
    
    public long getAccessCount() {
        return accessCounter.get();
    }
}
```

**Zadanie Zaawansowane 3:**
```java
public class AdvancedTemplateEngine {
    private final Pattern placeholderPattern = Pattern.compile("\\$\\{([^}]+)\\}");
    private final Pattern conditionalPattern = Pattern.compile("\\{\\{#if\\s+([^}]+)\\}\\}(.*?)\\{\\{/if\\}\\}", Pattern.DOTALL);
    private final Pattern loopPattern = Pattern.compile("\\{\\{#each\\s+([^}]+)\\}\\}(.*?)\\{\\{/each\\}\\}", Pattern.DOTALL);
    
    public static class Template {
        private final String compiledTemplate;
        private final List<String> placeholders;
        
        private Template(String compiledTemplate, List<String> placeholders) {
            this.compiledTemplate = compiledTemplate;
            this.placeholders = placeholders;
        }
        
        public String render(Map<String, Object> context) {
            String result = compiledTemplate;
            
            for (String placeholder : placeholders) {
                Object value = getNestedValue(context, placeholder);
                String replacement = value != null ? value.toString() : "";
                result = result.replace("${" + placeholder + "}", replacement);
            }
            
            return result;
        }
        
        private Object getNestedValue(Map<String, Object> context, String path) {
            String[] parts = path.split("\\.");
            Object current = context;
            
            for (String part : parts) {
                if (current instanceof Map) {
                    current = ((Map<?, ?>) current).get(part);
                } else {
                    return null;
                }
            }
            
            return current;
        }
    }
    
    public Template compile(String template) {
        String processed = template;
        List<String> placeholders = new ArrayList<>();
        
        // Process conditionals
        processed = processConditionals(processed);
        
        // Process loops
        processed = processLoops(processed);
        
        // Extract placeholders
        Matcher matcher = placeholderPattern.matcher(processed);
        while (matcher.find()) {
            String placeholder = matcher.group(1);
            if (!placeholders.contains(placeholder)) {
                placeholders.add(placeholder);
            }
        }
        
        return new Template(processed, placeholders);
    }
    
    private String processConditionals(String template) {
        Matcher matcher = conditionalPattern.matcher(template);
        StringBuffer result = new StringBuffer();
        
        while (matcher.find()) {
            String condition = matcher.group(1);
            String content = matcher.group(2);
            
            // Simplified condition processing
            String replacement = "{{CONDITIONAL:" + condition + ":" + content + "}}";
            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));
        }
        
        matcher.appendTail(result);
        return result.toString();
    }
    
    private String processLoops(String template) {
        Matcher matcher = loopPattern.matcher(template);
        StringBuffer result = new StringBuffer();
        
        while (matcher.find()) {
            String collection = matcher.group(1);
            String content = matcher.group(2);
            
            String replacement = "{{LOOP:" + collection + ":" + content + "}}";
            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));
        }
        
        matcher.appendTail(result);
        return result.toString();
    }
}
```

**Pytania kontrolne:**
1. String pool przechowuje unique String instances w pamięci. `intern()` może prowadzić do memory leaks w produkcji, bo pool nigdy nie jest czyszczony. Lepiej używać custom pools z WeakReference.
2. Immutability zapewnia thread safety, pozwala na hash code caching, String pool optimization i bezpieczne przekazywanie referencji. JVM może optymalizować przez constant folding i escape analysis.
3. Java 9+ używa Compact Strings (byte[] zamiast char[]), automatycznie wybierając Latin-1 vs UTF-16. Oszczędza ~50% pamięci dla ASCII strings.

---

#### 📚 Co dalej?

*Świetnie! Teraz masz pełne zrozumienie String w Javie - od podstawowych operacji po zaawansowane optymalizacje i wzorce. String to narzędzie, którego będziesz używać w każdym programie, więc warto znać wszystkie jego możliwości. W następnym rozdziale porozmawiamy o StringBuilder i StringBuffer - czyli o tym, jak ogarnąć dużo tekstu wydajnie!*

---

*💡 Pamiętaj: String jest immutable z bardzo dobrych powodów. Używaj go świadomie i pamiętaj o wydajności przy intensywnych operacjach tekstowych!*


## 8. StringBuilder i StringBuffer: jak ogarnąć dużo tekstu

*Cześć! Dziś porozmawiamy o StringBuilder i StringBuffer - czyli o tym, jak efektywnie budować długie teksty w Javie. Jeśli w poprzednim rozdziale String był jak niezmienialny notes, to StringBuilder to jak tablica, na której możesz pisać, mazać i przepisywać do woli. To narzędzie, które uratuje Cię przed problemami wydajnościowymi przy intensywnej pracy z tekstem!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

StringBuilder i StringBuffer to **mutable** (zmienialny) odpowiednik String. Podczas gdy każda operacja na String tworzy nowy obiekt, StringBuilder pozwala modyfikować zawartość bez tworzenia nowych obiektów.

```java
// String - każda operacja tworzy nowy obiekt
String tekst = "Hello";
tekst += " World";  // Tworzy nowy String!
tekst += "!";       // Znowu nowy String!

// StringBuilder - modyfikuje istniejący obiekt
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");  // Modyfikuje istniejący obiekt
sb.append("!");       // Nadal ten sam obiekt
String wynik = sb.toString();  // Konwersja do String tylko na końcu
```

#### Dlaczego to ważne?

Gdy budujesz długie teksty (szczególnie w pętlach), StringBuilder jest znacznie wydajniejszy niż konkatenacja String. To różnica między O(n²) a O(n) złożonością czasową!

```java
// ŹLE - O(n²) złożoność!
String wynik = "";
for (int i = 0; i < 1000; i++) {
    wynik += "element " + i + ", ";  // Każda iteracja tworzy nowy String
}

// DOBRZE - O(n) złożoność!
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append("element ").append(i).append(", ");
}
String wynik = sb.toString();
```

#### Jak to działa w praktyce?

**Podstawowe operacje StringBuilder:**

```java
public class PodstawoweStringBuilder {
    public static void main(String[] args) {
        // Tworzenie StringBuilder
        StringBuilder sb1 = new StringBuilder();                    // Pusty
        StringBuilder sb2 = new StringBuilder("Hello");             // Z początkową wartością
        StringBuilder sb3 = new StringBuilder(100);                 // Z początkową pojemnością
        
        // Dodawanie tekstu
        sb1.append("Java");
        sb1.append(" ");
        sb1.append("Programming");
        System.out.println(sb1);  // "Java Programming"
        
        // Łańcuchowe wywołania (method chaining)
        StringBuilder sb4 = new StringBuilder()
            .append("Cześć ")
            .append("Anna")
            .append("! ")
            .append("Masz ")
            .append(25)
            .append(" lat.");
        System.out.println(sb4);  // "Cześć Anna! Masz 25 lat."
        
        // Wstawianie w określonym miejscu
        StringBuilder sb5 = new StringBuilder("Hello World");
        sb5.insert(6, "Beautiful ");
        System.out.println(sb5);  // "Hello Beautiful World"
        
        // Usuwanie fragmentów
        sb5.delete(6, 16);  // Usuwa "Beautiful "
        System.out.println(sb5);  // "Hello World"
        
        // Zastępowanie fragmentów
        sb5.replace(0, 5, "Hi");
        System.out.println(sb5);  // "Hi World"
        
        // Odwracanie
        StringBuilder sb6 = new StringBuilder("Java");
        sb6.reverse();
        System.out.println(sb6);  // "avaJ"
    }
}
```

**StringBuilder vs StringBuffer:**

```java
public class StringBuilderVsStringBuffer {
    public static void main(String[] args) {
        // StringBuilder - NIE jest thread-safe, ale szybszy
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        sb.append(" World");
        
        // StringBuffer - JEST thread-safe, ale wolniejszy
        StringBuffer sbf = new StringBuffer();
        sbf.append("Hello");
        sbf.append(" World");
        
        // W praktyce: używaj StringBuilder, chyba że potrzebujesz thread safety
        
        // Konwersja do String
        String fromBuilder = sb.toString();
        String fromBuffer = sbf.toString();
        
        System.out.println("StringBuilder: " + fromBuilder);
        System.out.println("StringBuffer: " + fromBuffer);
    }
}
```

**Praktyczne przykłady użycia:**

```java
public class PraktyczneStringBuilder {
    // Budowanie HTML
    public static String buildHtml(String title, List<String> items) {
        StringBuilder html = new StringBuilder();
        html.append("<!DOCTYPE html>")
            .append("<html>")
            .append("<head><title>").append(title).append("</title></head>")
            .append("<body>")
            .append("<h1>").append(title).append("</h1>")
            .append("<ul>");
        
        for (String item : items) {
            html.append("<li>").append(item).append("</li>");
        }
        
        html.append("</ul>")
            .append("</body>")
            .append("</html>");
        
        return html.toString();
    }
    
    // Budowanie CSV
    public static String buildCsv(List<String[]> rows) {
        StringBuilder csv = new StringBuilder();
        
        for (String[] row : rows) {
            for (int i = 0; i < row.length; i++) {
                if (i > 0) csv.append(",");
                csv.append("\"").append(row[i].replace("\"", "\"\"")).append("\"");
            }
            csv.append("\n");
        }
        
        return csv.toString();
    }
    
    // Formatowanie liczb z separatorami
    public static String formatNumber(long number) {
        StringBuilder sb = new StringBuilder(Long.toString(number));
        
        // Dodaj separatory co 3 cyfry od końca
        for (int i = sb.length() - 3; i > 0; i -= 3) {
            sb.insert(i, ",");
        }
        
        return sb.toString();
    }
    
    public static void main(String[] args) {
        // Test HTML
        List<String> items = Arrays.asList("Java", "Python", "JavaScript");
        System.out.println(buildHtml("Języki programowania", items));
        
        // Test CSV
        List<String[]> rows = Arrays.asList(
            new String[]{"Imię", "Wiek", "Miasto"},
            new String[]{"Anna", "25", "Warszawa"},
            new String[]{"Kasia", "30", "Kraków"}
        );
        System.out.println(buildCsv(rows));
        
        // Test formatowania liczb
        System.out.println(formatNumber(1234567));  // "1,234,567"
    }
}
```

#### Zarządzanie pojemnością

```java
public class ZarzadzaniePojemnoscia {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        
        // Sprawdzanie pojemności
        System.out.println("Początkowa pojemność: " + sb.capacity());  // 16
        System.out.println("Długość: " + sb.length());                  // 0
        
        // Dodawanie tekstu
        sb.append("Hello World Programming");
        System.out.println("Po dodaniu tekstu:");
        System.out.println("Pojemność: " + sb.capacity());  // Automatycznie zwiększona
        System.out.println("Długość: " + sb.length());
        
        // Ręczne ustawianie pojemności
        sb.ensureCapacity(100);  // Zapewnia minimum 100 znaków
        System.out.println("Po ensureCapacity(100): " + sb.capacity());
        
        // Zmniejszanie pojemności do rzeczywistej długości
        sb.trimToSize();
        System.out.println("Po trimToSize(): " + sb.capacity());
        
        // Ustawianie długości (może obciąć tekst)
        sb.setLength(5);
        System.out.println("Po setLength(5): '" + sb + "'");  // "Hello"
    }
}
```

#### Pułapki, na które warto uważać

**Pułapka 1: Thread safety**

```java
// ŹLE - StringBuilder w środowisku wielowątkowym
StringBuilder shared = new StringBuilder();

// Thread 1
shared.append("Hello ");

// Thread 2 (jednocześnie)
shared.append("World");

// Wynik może być nieprzewidywalny!

// DOBRZE - StringBuffer lub synchronizacja
StringBuffer threadSafe = new StringBuffer();
// lub
StringBuilder sb = new StringBuilder();
synchronized(sb) {
    sb.append("Hello ");
}
```

**Pułapka 2: Zapominanie o toString()**

```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");

// ŹLE - porównujesz obiekty StringBuilder
if (sb.equals("Hello World")) {  // Zawsze false!
    System.out.println("Nigdy się nie wykona");
}

// DOBRZE - konwertuj do String
if (sb.toString().equals("Hello World")) {
    System.out.println("To się wykona");
}
```

#### 💡 Wskazówki dla Juniorek

- **Używaj StringBuilder** dla konkatenacji w pętlach
- **StringBuffer tylko** gdy potrzebujesz thread safety
- **Ustaw początkową pojemność** jeśli znasz przybliżony rozmiar
- **Method chaining** czyni kod bardziej czytelnym
- **Pamiętaj o toString()** na końcu

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Napisz metodę, która tworzy "drabinkę" z gwiazdek o podanej wysokości.

```java
public static String stworzDrabinke(int wysokosc) {
    // Przykład dla wysokosc=3:
    // *
    // **
    // ***
}
```

**Zadanie 2:** Stwórz metodę, która odwraca słowa w zdaniu, ale zachowuje ich kolejność.

**Zadanie 3:** Napisz funkcję, która tworzy prosty raport z listy produktów (nazwa, cena, ilość).

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest główna różnica między String a StringBuilder?
2. Kiedy używać StringBuffer zamiast StringBuilder?
3. Dlaczego StringBuilder jest wydajniejszy przy wielu konkatenacjach?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

StringBuilder i StringBuffer to nie tylko wygodne narzędzia - to przykłady przemyślanej architektury, która balansuje między wydajnością, bezpieczeństwem i użytecznością. Przyjrzyjmy się ich wewnętrznej implementacji i zaawansowanym wzorcom użycia.

##### Wewnętrzna implementacja

```java
public class StringBuilderInternals {
    // Uproszczona implementacja pokazująca kluczowe koncepty
    public static class SimpleStringBuilder {
        private char[] buffer;
        private int length;
        
        public SimpleStringBuilder(int capacity) {
            this.buffer = new char[capacity];
            this.length = 0;
        }
        
        public SimpleStringBuilder append(String str) {
            int newLength = length + str.length();
            ensureCapacity(newLength);
            
            str.getChars(0, str.length(), buffer, length);
            length = newLength;
            return this;
        }
        
        private void ensureCapacity(int minimumCapacity) {
            if (minimumCapacity > buffer.length) {
                int newCapacity = Math.max(minimumCapacity, buffer.length * 2 + 2);
                buffer = Arrays.copyOf(buffer, newCapacity);
            }
        }
        
        @Override
        public String toString() {
            return new String(buffer, 0, length);
        }
    }
    
    // Performance analysis
    public void analyzeGrowthStrategy() {
        StringBuilder sb = new StringBuilder(1);  // Start small
        
        for (int i = 0; i < 20; i++) {
            int capacityBefore = sb.capacity();
            sb.append("x");
            int capacityAfter = sb.capacity();
            
            if (capacityBefore != capacityAfter) {
                System.out.printf("Growth: %d -> %d (factor: %.2f)%n", 
                    capacityBefore, capacityAfter, (double)capacityAfter / capacityBefore);
            }
        }
    }
}
```

##### Advanced patterns i optymalizacje

```java
public class AdvancedStringBuilderPatterns {
    // Object pooling dla StringBuilder
    public static class StringBuilderPool {
        private final Queue<StringBuilder> pool = new ConcurrentLinkedQueue<>();
        private final int maxPoolSize;
        private final int initialCapacity;
        
        public StringBuilderPool(int maxPoolSize, int initialCapacity) {
            this.maxPoolSize = maxPoolSize;
            this.initialCapacity = initialCapacity;
        }
        
        public StringBuilder acquire() {
            StringBuilder sb = pool.poll();
            if (sb == null) {
                sb = new StringBuilder(initialCapacity);
            } else {
                sb.setLength(0);  // Clear content
            }
            return sb;
        }
        
        public void release(StringBuilder sb) {
            if (pool.size() < maxPoolSize && sb.capacity() <= initialCapacity * 4) {
                pool.offer(sb);
            }
        }
        
        public String buildString(Function<StringBuilder, StringBuilder> builder) {
            StringBuilder sb = acquire();
            try {
                return builder.apply(sb).toString();
            } finally {
                release(sb);
            }
        }
    }
    
    // Template-based string building
    public static class StringTemplate {
        private final List<Object> parts = new ArrayList<>();
        
        public StringTemplate text(String text) {
            parts.add(text);
            return this;
        }
        
        public StringTemplate placeholder(String name) {
            parts.add(new Placeholder(name));
            return this;
        }
        
        public String build(Map<String, Object> values) {
            StringBuilder sb = new StringBuilder();
            for (Object part : parts) {
                if (part instanceof String) {
                    sb.append(part);
                } else if (part instanceof Placeholder) {
                    Object value = values.get(((Placeholder) part).name);
                    sb.append(value != null ? value : "");
                }
            }
            return sb.toString();
        }
        
        private static class Placeholder {
            final String name;
            Placeholder(String name) { this.name = name; }
        }
    }
    
    // Streaming string builder
    public static class StreamingStringBuilder {
        private final StringBuilder sb = new StringBuilder();
        
        public StreamingStringBuilder appendIf(boolean condition, String text) {
            if (condition) sb.append(text);
            return this;
        }
        
        public StreamingStringBuilder appendForEach(Iterable<?> items, 
                                                   Function<Object, String> mapper) {
            for (Object item : items) {
                sb.append(mapper.apply(item));
            }
            return this;
        }
        
        public StreamingStringBuilder appendJoin(Iterable<?> items, 
                                               String delimiter,
                                               Function<Object, String> mapper) {
            boolean first = true;
            for (Object item : items) {
                if (!first) sb.append(delimiter);
                sb.append(mapper.apply(item));
                first = false;
            }
            return this;
        }
        
        @Override
        public String toString() {
            return sb.toString();
        }
    }
}
```

#### Performance benchmarks

```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public class StringBuilderBenchmarks {
    private static final int ITERATIONS = 1000;
    
    @Benchmark
    public String stringConcatenation() {
        String result = "";
        for (int i = 0; i < ITERATIONS; i++) {
            result += "item" + i;
        }
        return result;
    }
    
    @Benchmark
    public String stringBuilderDefault() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < ITERATIONS; i++) {
            sb.append("item").append(i);
        }
        return sb.toString();
    }
    
    @Benchmark
    public String stringBuilderPreSized() {
        StringBuilder sb = new StringBuilder(ITERATIONS * 10);  // Pre-allocate
        for (int i = 0; i < ITERATIONS; i++) {
            sb.append("item").append(i);
        }
        return sb.toString();
    }
    
    @Benchmark
    public String stringJoiner() {
        StringJoiner joiner = new StringJoiner("");
        for (int i = 0; i < ITERATIONS; i++) {
            joiner.add("item" + i);
        }
        return joiner.toString();
    }
    
    @Benchmark
    public String streamJoining() {
        return IntStream.range(0, ITERATIONS)
            .mapToObj(i -> "item" + i)
            .collect(Collectors.joining());
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj thread-safe StringBuilder pool z automatycznym zarządzaniem rozmiarem i metrykami użycia.

**Zadanie Zaawansowane 2:** Stwórz system template'ów z lazy evaluation i caching, zoptymalizowany pod kątem wydajności dla częstych renderowań.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak działa strategia wzrostu pojemności w StringBuilder i dlaczego jest efektywna?
2. Jakie są trade-offs między StringBuilder pooling a tworzeniem nowych instancji?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static String stworzDrabinke(int wysokosc) {
    StringBuilder sb = new StringBuilder();
    
    for (int i = 1; i <= wysokosc; i++) {
        for (int j = 0; j < i; j++) {
            sb.append("*");
        }
        if (i < wysokosc) {  // Nie dodawaj nowej linii po ostatnim wierszu
            sb.append("\n");
        }
    }
    
    return sb.toString();
}
```

**Zadanie 2:**
```java
public static String odwrocSlowa(String zdanie) {
    String[] slowa = zdanie.split(" ");
    StringBuilder sb = new StringBuilder();
    
    for (int i = 0; i < slowa.length; i++) {
        if (i > 0) sb.append(" ");
        
        // Odwróć każde słowo
        StringBuilder slowoSb = new StringBuilder(slowa[i]);
        sb.append(slowoSb.reverse());
    }
    
    return sb.toString();
}
```

**Zadanie 3:**
```java
public static String stworzRaport(List<Produkt> produkty) {
    StringBuilder sb = new StringBuilder();
    
    sb.append("RAPORT PRODUKTÓW\n");
    sb.append("================\n\n");
    
    double sumaWartosci = 0;
    
    for (Produkt p : produkty) {
        double wartosc = p.getCena() * p.getIlosc();
        sumaWartosci += wartosc;
        
        sb.append(String.format("%-20s | %8.2f zł | %5d szt | %10.2f zł\n",
            p.getNazwa(), p.getCena(), p.getIlosc(), wartosc));
    }
    
    sb.append("\n");
    sb.append("SUMA WARTOŚCI: ").append(String.format("%.2f zł", sumaWartosci));
    
    return sb.toString();
}
```

**Pytania kontrolne:**
1. String jest immutable - każda operacja tworzy nowy obiekt. StringBuilder jest mutable - modyfikuje istniejący obiekt.
2. StringBuffer gdy potrzebujesz thread safety (metody są synchronized). StringBuilder jest szybszy ale nie thread-safe.
3. StringBuilder unika tworzenia wielu pośrednich obiektów String, co redukuje alokacje pamięci i presję na GC.

#### Odpowiedzi - Poziom Senior

**Zadanie Zaawansowane 1:**
```java
public class ThreadSafeStringBuilderPool {
    private final ConcurrentLinkedQueue<StringBuilder> pool = new ConcurrentLinkedQueue<>();
    private final AtomicInteger poolSize = new AtomicInteger(0);
    private final AtomicLong totalAcquisitions = new AtomicLong(0);
    private final AtomicLong poolHits = new AtomicLong(0);
    
    private final int maxPoolSize;
    private final int initialCapacity;
    private final int maxRetainedCapacity;
    
    public ThreadSafeStringBuilderPool(int maxPoolSize, int initialCapacity, int maxRetainedCapacity) {
        this.maxPoolSize = maxPoolSize;
        this.initialCapacity = initialCapacity;
        this.maxRetainedCapacity = maxRetainedCapacity;
    }
    
    public StringBuilder acquire() {
        totalAcquisitions.incrementAndGet();
        
        StringBuilder sb = pool.poll();
        if (sb != null) {
            poolSize.decrementAndGet();
            poolHits.incrementAndGet();
            sb.setLength(0);
            return sb;
        }
        
        return new StringBuilder(initialCapacity);
    }
    
    public void release(StringBuilder sb) {
        if (sb.capacity() <= maxRetainedCapacity && poolSize.get() < maxPoolSize) {
            if (pool.offer(sb)) {
                poolSize.incrementAndGet();
            }
        }
    }
    
    public PoolMetrics getMetrics() {
        long total = totalAcquisitions.get();
        long hits = poolHits.get();
        return new PoolMetrics(
            poolSize.get(),
            total,
            hits,
            total > 0 ? (double) hits / total : 0.0
        );
    }
    
    public static class PoolMetrics {
        public final int currentPoolSize;
        public final long totalAcquisitions;
        public final long poolHits;
        public final double hitRate;
        
        public PoolMetrics(int currentPoolSize, long totalAcquisitions, long poolHits, double hitRate) {
            this.currentPoolSize = currentPoolSize;
            this.totalAcquisitions = totalAcquisitions;
            this.poolHits = poolHits;
            this.hitRate = hitRate;
        }
    }
}
```

**Pytania kontrolne:**
1. StringBuilder podwaja pojemność + 2 gdy potrzebuje więcej miejsca. To amortyzuje koszt kopiowania do O(1) per operacja, minimalizując liczbę realokacji.
2. Pooling redukuje GC pressure ale zwiększa memory footprint i complexity. Opłaca się dla high-frequency, short-lived StringBuilder usage patterns.

---

#### 📚 Co dalej?

*Świetnie! Teraz rozumiesz, jak efektywnie budować długie teksty w Javie. StringBuilder to narzędzie, które znacznie przyspieszy Twoje aplikacje przy intensywnej pracy z tekstem. W następnym rozdziale porozmawiamy o Text Blocks - czyli o wielolinijkowych String bez bólu!*


## 9. Text Blocks (""") — czyli wielolinijkowe Stringi bez bólu

*Cześć! Na koniec pierwszej sekcji porozmawiamy o Text Blocks - jednej z najfajniejszych funkcjonalności dodanych do Javy w ostatnich latach. Jeśli kiedykolwiek męczyłaś się z budowaniem wielolinijkowych String używając \n i konkatenacji, to Text Blocks to Twój nowy najlepszy przyjaciel. Przygotuj się na odkrycie, jak elegancko można pisać kod z długimi tekstami!*

---

### 🌱 Część dla Juniorek

#### Co to właściwie jest?

Text Blocks (wprowadzone w Javie 15) to sposób na tworzenie wielolinijkowych String bez używania escape sequences i konkatenacji. Zamiast męczyć się z `\n` i `\"`, po prostu piszesz tekst tak, jak chcesz, żeby wyglądał.

```java
// Stary sposób - okropny!
String html = "<html>\n" +
              "  <head>\n" +
              "    <title>Moja strona</title>\n" +
              "  </head>\n" +
              "  <body>\n" +
              "    <h1>Witaj!</h1>\n" +
              "  </body>\n" +
              "</html>";

// Nowy sposób - piękny!
String html = """
              <html>
                <head>
                  <title>Moja strona</title>
                </head>
                <body>
                  <h1>Witaj!</h1>
                </body>
              </html>
              """;
```

#### Dlaczego to ważne?

Text Blocks znacznie poprawiają czytelność kodu, szczególnie gdy pracujesz z:
- HTML/XML
- JSON
- SQL queries
- Wielolinijkowymi komunikatami
- Dokumentacją w kodzie

#### Jak to działa w praktyce?

**Podstawowa składnia:**

```java
public class PodstawoweTextBlocks {
    public static void main(String[] args) {
        // Podstawowy text block
        String powitanie = """
                          Cześć!
                          Jak się masz?
                          Miłego dnia!
                          """;
        System.out.println(powitanie);
        
        // Text block z interpolacją
        String imie = "Anna";
        int wiek = 25;
        String wiadomosc = """
                          Cześć %s!
                          Masz %d lat.
                          Miło Cię poznać!
                          """.formatted(imie, wiek);
        System.out.println(wiadomosc);
        
        // Pusty text block
        String pusty = """
                      """;
        System.out.println("Długość pustego: " + pusty.length());  // 0
    }
}
```

**Praktyczne przykłady:**

```java
public class PraktyczneTextBlocks {
    // JSON
    public static String createJsonUser(String name, String email, int age) {
        return """
               {
                 "name": "%s",
                 "email": "%s",
                 "age": %d,
                 "active": true
               }
               """.formatted(name, email, age);
    }
    
    // SQL Query
    public static String getUsersQuery(String city, int minAge) {
        return """
               SELECT u.id, u.name, u.email, p.phone
               FROM users u
               LEFT JOIN profiles p ON u.id = p.user_id
               WHERE u.city = '%s'
                 AND u.age >= %d
                 AND u.active = true
               ORDER BY u.name
               """.formatted(city, minAge);
    }
    
    // HTML Template
    public static String createHtmlPage(String title, String content) {
        return """
               <!DOCTYPE html>
               <html lang="pl">
               <head>
                   <meta charset="UTF-8">
                   <meta name="viewport" content="width=device-width, initial-scale=1.0">
                   <title>%s</title>
                   <style>
                       body { font-family: Arial, sans-serif; margin: 40px; }
                       h1 { color: #333; }
                   </style>
               </head>
               <body>
                   <h1>%s</h1>
                   <div class="content">
                       %s
                   </div>
               </body>
               </html>
               """.formatted(title, title, content);
    }
    
    public static void main(String[] args) {
        // Test JSON
        System.out.println(createJsonUser("Anna Kowalska", "anna@example.com", 25));
        
        // Test SQL
        System.out.println(getUsersQuery("Warszawa", 18));
        
        // Test HTML
        System.out.println(createHtmlPage("Moja strona", "<p>Witaj na mojej stronie!</p>"));
    }
}
```

**Zarządzanie wcięciami:**

```java
public class ZarzadzanieWcieciami {
    public static void main(String[] args) {
        // Text block automatycznie usuwa wspólne wcięcia
        String tekst1 = """
                        Pierwsza linia
                        Druga linia
                        Trzecia linia
                        """;
        
        // To samo co:
        String tekst2 = """
Pierwsza linia
Druga linia
Trzecia linia
""";
        
        System.out.println("Tekst1 equals Tekst2: " + tekst1.equals(tekst2));  // true
        
        // Kontrolowanie wcięć
        String sformatowany = """
                             Linia z wcięciem
                               Linia z większym wcięciem
                             Znowu normalne wcięcie
                             """;
        System.out.println(sformatowany);
        
        // Metody do manipulacji wcięć
        String bezWciec = tekst1.stripIndent();
        String zWcieciem = tekst1.indent(4);
        
        System.out.println("Bez wcięć:\n" + bezWciec);
        System.out.println("Z wcięciem:\n" + zWcieciem);
    }
}
```

#### Escape sequences w Text Blocks

```java
public class EscapeSequences {
    public static void main(String[] args) {
        // Większość escape sequences działa normalnie
        String tekst = """
                      Linia z \ttabulatorem
                      Linia z "cudzysłowami"
                      Linia z 'apostrofami'
                      """;
        System.out.println(tekst);
        
        // Specjalne przypadki
        String specjalne = """
                          Backslash: \\
                          Potrójny cudzysłów: \"\"\"
                          Nowa linia na końcu: \
                          kontynuacja tej samej linii
                          """;
        System.out.println(specjalne);
        
        // Zachowanie białych znaków na końcu linii
        String bialezZnaki = """
                            Linia bez spacji na końcu
                            Linia ze spacjami na końcu   \s
                            Kolejna linia
                            """;
        System.out.println("'" + bialezZnaki + "'");
    }
}
```

#### 💡 Wskazówki dla Juniorek

- **Text blocks** świetne do HTML, JSON, SQL
- **Automatyczne usuwanie wcięć** - nie martw się o formatowanie
- **Używaj `.formatted()`** zamiast String.format()
- **Uważaj na białe znaki** na końcu linii
- **Kombinuj z StringBuilder** dla dynamicznej zawartości

#### 🎯 Zadania dla Juniorek

**Zadanie 1:** Stwórz metodę generującą email HTML z szablonem powitalnym.

**Zadanie 2:** Napisz funkcję tworzącą konfigurację JSON dla aplikacji.

**Zadanie 3:** Zbuduj generator prostych raportów w formacie tekstowym.

#### ❓ Pytania Kontrolne - Poziom Junior

1. Jaka jest główna zaleta Text Blocks nad tradycyjną konkatenacją?
2. Jak Text Blocks radzą sobie z wcięciami?
3. Kiedy warto używać Text Blocks zamiast StringBuilder?

---

### 🚀 Część dla Seniorek

#### Głębsza analiza tematu

Text Blocks to nie tylko syntactic sugar - to przemyślana funkcjonalność, która wpływa na czytelność, maintainability i bezpieczeństwo kodu. Przyjrzyjmy się zaawansowanym aspektom i wzorcom użycia.

##### Kompilacja i optymalizacje

```java
public class TextBlockInternals {
    // Text blocks są kompilowane do zwykłych String literals
    public void demonstrateCompilation() {
        String textBlock = """
                          Hello
                          World
                          """;
        
        String traditional = "Hello\nWorld\n";
        
        // Te dwa String są identyczne na poziomie bytecode
        System.out.println(textBlock.equals(traditional));  // true
        System.out.println(textBlock == traditional);       // true (string pool)
    }
    
    // Performance implications
    @Benchmark
    public String textBlockCreation() {
        return """
               {
                 "name": "test",
                 "value": 123
               }
               """;
    }
    
    @Benchmark
    public String traditionalCreation() {
        return "{\n  \"name\": \"test\",\n  \"value\": 123\n}";
    }
    // Wyniki są identyczne - text blocks nie mają overhead
}
```

##### Zaawansowane wzorce

```java
public class AdvancedTextBlockPatterns {
    // Template system z text blocks
    public static class TextTemplate {
        private final String template;
        
        public TextTemplate(String template) {
            this.template = template;
        }
        
        public String render(Object... args) {
            return template.formatted(args);
        }
        
        public String render(Map<String, Object> context) {
            String result = template;
            for (Map.Entry<String, Object> entry : context.entrySet()) {
                result = result.replace("${" + entry.getKey() + "}", 
                                      String.valueOf(entry.getValue()));
            }
            return result;
        }
    }
    
    // SQL Builder z text blocks
    public static class SqlBuilder {
        private final StringBuilder query = new StringBuilder();
        
        public SqlBuilder select(String... columns) {
            query.append("SELECT ").append(String.join(", ", columns));
            return this;
        }
        
        public SqlBuilder from(String table) {
            query.append("\nFROM ").append(table);
            return this;
        }
        
        public SqlBuilder where(String condition) {
            query.append("\nWHERE ").append(condition);
            return this;
        }
        
        public SqlBuilder orderBy(String... columns) {
            query.append("\nORDER BY ").append(String.join(", ", columns));
            return this;
        }
        
        @Override
        public String toString() {
            return query.toString();
        }
    }
    
    // Configuration DSL
    public static String createDockerfile(String baseImage, List<String> commands) {
        StringBuilder dockerfile = new StringBuilder();
        dockerfile.append("""
                         FROM %s
                         
                         WORKDIR /app
                         """.formatted(baseImage));
        
        for (String command : commands) {
            dockerfile.append("RUN ").append(command).append("\n");
        }
        
        dockerfile.append("""
                         
                         EXPOSE 8080
                         CMD ["java", "-jar", "app.jar"]
                         """);
        
        return dockerfile.toString();
    }
}
```

#### Security considerations

```java
public class TextBlockSecurity {
    // SQL Injection prevention
    public static class SafeSqlBuilder {
        public static String createParameterizedQuery() {
            return """
                   SELECT u.id, u.name, u.email
                   FROM users u
                   WHERE u.city = ?
                     AND u.age >= ?
                     AND u.active = true
                   ORDER BY u.name
                   """;
        }
        
        // NIGDY nie rób tego z user input!
        public static String unsafeQuery(String userInput) {
            return """
                   SELECT * FROM users
                   WHERE name = '%s'
                   """.formatted(userInput);  // SQL Injection risk!
        }
    }
    
    // XSS prevention w HTML templates
    public static String safeHtmlTemplate(String userContent) {
        String escaped = userContent
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#x27;");
        
        return """
               <div class="user-content">
                   %s
               </div>
               """.formatted(escaped);
    }
}
```

#### 🔧 Zadania dla Seniorek

**Zadanie Zaawansowane 1:** Zaimplementuj system template'ów z obsługą includes, conditionals i loops używając text blocks jako base.

#### ❓ Pytania Kontrolne - Poziom Senior

1. Jak text blocks wpływają na string pool i internowanie?
2. Jakie są security implications używania text blocks z user input?

---

### 🔑 Klucz Odpowiedzi

#### Odpowiedzi - Poziom Junior

**Zadanie 1:**
```java
public static String generateWelcomeEmail(String name, String company) {
    return """
           <!DOCTYPE html>
           <html>
           <head>
               <title>Witamy w %s!</title>
           </head>
           <body>
               <h1>Cześć %s!</h1>
               <p>Witamy w %s. Cieszymy się, że do nas dołączyłaś!</p>
               <p>Życzymy powodzenia!</p>
           </body>
           </html>
           """.formatted(company, name, company);
}
```

**Zadanie 2:**
```java
public static String generateAppConfig(String appName, String version, int port) {
    return """
           {
               "application": {
                   "name": "%s",
                   "version": "%s",
                   "port": %d
               },
               "database": {
                   "host": "localhost",
                   "port": 5432,
                   "name": "app_db"
               },
               "logging": {
                   "level": "INFO",
                   "file": "app.log"
               }
           }
           """.formatted(appName, version, port);
}
```

**Pytania kontrolne:**
1. Czytelność - nie trzeba używać \n i konkatenacji, kod wygląda jak docelowy tekst.
2. Automatycznie usuwają wspólne wcięcia z lewej strony, zachowując relatywne wcięcia.
3. Text blocks dla statycznych template'ów, StringBuilder dla dynamicznego budowania.

#### Odpowiedzi - Poziom Senior

**Pytania kontrolne:**
1. Text blocks są kompilowane do zwykłych String literals, więc działają identycznie z string pool - mogą być internowane.
2. Nigdy nie wstawiaj raw user input do text blocks bez escapowania - ryzyko injection attacks (SQL, XSS, etc.).

---

### 📚 Koniec pierwszej sekcji!

*Gratulacje! Ukończyłaś pierwszą sekcję przewodnika - "Podstawy Javy i środowiska uruchomieniowego". Poznałaś zmienne, typy danych, operatory, warunki, pętle i wszystko związane z tekstem w Javie. To solidny fundament, na którym będziesz budować całą resztę swojej wiedzy o Javie.*

*W następnej sekcji zagłębimy się w klasy i struktury danych - enumy, kolekcje, Optional i rekordy. To będzie kolejny krok w Twojej podróży do mistrzostwa w Javie!*

---

*💡 Pamiętaj: Podstawy to fundament. Im lepiej je znasz, tym łatwiej będzie Ci zrozumieć zaawansowane koncepty!*

